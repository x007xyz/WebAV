{"version":3,"file":"internal-utils.umd.cjs","sources":["../src/event-tool.ts","../src/worker-timer.ts","../src/stream-utils.ts","../src/meta-box.ts","../src/log.ts","../src/recodemux.ts"],"sourcesContent":["type EventKey = string | symbol;\n\ntype EventToolType = Record<EventKey, (...args: any[]) => any>;\n\n/**\n * 事件工具类\n *\n * @example\n * const evtTool = new EventTool<{\n *   timeupdate: (time: number) => void;\n *   paused: () => void;\n *   playing: () => void;\n * }>()\n * evtTool.on('paused', () => {})\n * evtTool.emit('paused')\n */\nexport class EventTool<T extends EventToolType> {\n  /**\n   * 在两个 EventTool 实例间转发消息\n   * @param from\n   * @param to\n   * @param evtTypes 需转发的消息类型\n   *\n   * @example\n   * EventTool.forwardEvent(from, to, ['evtName']),\n   */\n  static forwardEvent<\n    T1 extends EventToolType,\n    T2 extends EventToolType,\n    EvtType extends (keyof T1 | [keyof T1, keyof T2])[],\n  >(\n    from: { on: EventTool<T1>['on'] },\n    to: { emit: EventTool<T2>['emit'] },\n    // 转发的事件名，如果 evtTypes 为序对（元组）表示事件名称需要映射\n    evtTypes: EvtType,\n  ): () => void {\n    const removeHandlers = evtTypes.map((evtType) => {\n      const [fromEvtType, toEvtType] = (\n        Array.isArray(evtType) ? evtType : [evtType, evtType]\n      ) as [keyof T1, keyof T2];\n\n      // @ts-expect-error\n      return from.on(fromEvtType, (...args) => {\n        // @ts-expect-error\n        to.emit(toEvtType, ...args);\n      });\n    });\n    return () => {\n      removeHandlers.forEach((fn) => fn());\n    };\n  }\n\n  #listeners = new Map<keyof T, Set<T[keyof T]>>();\n\n  /**\n   * 监听 EventType 中定义的事件\n   */\n  on = <Type extends keyof T>(type: Type, listener: T[Type]): (() => void) => {\n    const handlers = this.#listeners.get(type) ?? new Set<T[keyof T]>();\n    handlers.add(listener);\n\n    if (!this.#listeners.has(type)) {\n      this.#listeners.set(type, handlers);\n    }\n\n    return () => {\n      handlers.delete(listener);\n      if (handlers.size === 0) {\n        this.#listeners.delete(type);\n      }\n    };\n  };\n\n  /**\n   * 监听事件，首次触发后自动移除监听\n   *\n   * 期望回调一次的事件，使用 once; 期望多次回调使用 on\n   */\n  once = <Type extends keyof T>(\n    type: Type,\n    listener: T[Type],\n  ): (() => void) => {\n    // @ts-ignore\n    const off = this.on(type, (...args) => {\n      off();\n      listener(...args);\n    });\n\n    return off;\n  };\n\n  /**\n   * 触发事件\n   * @param type\n   * @param args\n   * @returns\n   */\n  emit = <Type extends keyof T>(\n    type: Type,\n    ...args: Type extends string\n      ? T[Type] extends (...args: any[]) => any\n        ? Parameters<T[Type]>\n        : never\n      : never\n  ): void => {\n    const handlers = this.#listeners.get(type);\n    if (handlers == null) return;\n\n    handlers.forEach((handler) => handler(...args));\n  };\n\n  destroy(): void {\n    this.#listeners.clear();\n  }\n}\n","const setup = (): void => {\n  let timerId: number;\n\n  let interval: number = 16.6;\n\n  self.onmessage = (e) => {\n    if (e.data.event === 'start') {\n      self.clearInterval(timerId);\n      timerId = self.setInterval(() => {\n        self.postMessage({});\n      }, interval);\n    }\n\n    if (e.data.event === 'stop') {\n      self.clearInterval(timerId);\n    }\n  };\n};\n\nconst createWorker = (): Worker => {\n  const blob = new Blob([`(${setup.toString()})()`]);\n  const url = URL.createObjectURL(blob);\n  return new Worker(url);\n};\n\nconst handlerMap = new Map<number, Set<() => void>>();\nlet runCount = 1;\n\nlet worker: Worker | null = null;\nif (globalThis.Worker != null) {\n  worker = createWorker();\n  worker.onmessage = () => {\n    runCount += 1;\n    for (const [k, v] of handlerMap) {\n      if (runCount % k === 0) for (const fn of v) fn();\n    }\n  };\n}\n\n/**\n * 专门解决页面长时间处于后台时，定时器不（或延迟）执行的问题\n *\n * 跟 `setInterval` 很相似，⚠️ 但 time 会有一定偏差，请优先使用 `setInterval`\n *\n * @see [JS 定时器时长控制细节](https://hughfenghen.github.io/posts/2023/06/15/timer-delay/)\n */\nexport const workerTimer = (\n  handler: () => void,\n  time: number,\n): (() => void) => {\n  const groupId = Math.round(time / 16.6);\n  const fns = handlerMap.get(groupId) ?? new Set();\n  fns.add(handler);\n  handlerMap.set(groupId, fns);\n\n  if (handlerMap.size === 1 && fns.size === 1) {\n    worker?.postMessage({ event: 'start' });\n  }\n\n  return () => {\n    fns.delete(handler);\n    if (fns.size === 0) handlerMap.delete(groupId);\n    if (handlerMap.size === 0) {\n      runCount = 0;\n      worker?.postMessage({ event: 'stop' });\n    }\n  };\n};\n","import mp4box, { MP4File } from '@webav/mp4box.js';\n/**\n * 自动读取流并处理每个数据块。\n *\n * @template ST - 可读流的类型。\n * @param stream - 要读取的流。\n * @param cbs - 回调函数对象。\n * @param cbs.onChunk - 当读取到新的数据块时调用的函数。该函数接收一个参数，即数据块，并返回一个 Promise。\n * @param cbs.onDone - 当读取完所有数据块时调用的函数。\n * @returns - 返回一个函数，调用该函数可以停止读取流。\n *\n * @example\n * const stream = getSomeReadableStream();\n * const onChunk = async (chunk) => {\n *   console.log('New chunk:', chunk);\n * };\n * const onDone = () => {\n *   console.log('Done reading stream');\n * };\n * const stopReading = autoReadStream(stream, { onChunk, onDone });\n * // Later...\n * stopReading();\n */\nexport function autoReadStream<ST extends ReadableStream>(\n  stream: ST,\n  cbs: {\n    onChunk: ST extends ReadableStream<infer DT>\n      ? (chunk: DT) => Promise<void>\n      : never;\n    onDone: () => void;\n  },\n) {\n  let stoped = false;\n  async function run() {\n    const reader = stream.getReader();\n\n    while (!stoped) {\n      const { value, done } = await reader.read();\n      if (done) {\n        cbs.onDone();\n        return;\n      }\n      await cbs.onChunk(value);\n    }\n\n    reader.releaseLock();\n    await stream.cancel();\n  }\n\n  run().catch(console.error);\n\n  return () => {\n    stoped = true;\n  };\n}\n\n/**\n * 将 mp4box file 转换为文件流，用于上传服务器或存储到本地\n * @param file - MP4 文件实例 {@link MP4File}。\n * @param timeSlice - 时间片，用于控制流的发送速度。\n * @param onCancel - 当返回的流被取消时触发该回调函数\n */\nexport function file2stream(\n  file: MP4File,\n  timeSlice: number,\n  onCancel?: () => void,\n): {\n  /**\n   * 可读流，流的数据是 `Uint8Array`\n   */\n  stream: ReadableStream<Uint8Array>;\n  /**\n   * 流的生产者主动停止向流中输出数据，可向消费者传递错误信息\n   */\n  stop: (err?: Error) => void;\n} {\n  let timerId = 0;\n\n  let sendedBoxIdx = 0;\n  const boxes = file.boxes;\n\n  let firstMoofReady = false;\n  const deltaBuf = (): Uint8Array | null => {\n    // 避免 moov 未完成时写入文件，导致文件无法被识别\n    if (!firstMoofReady) {\n      if (boxes.find((box) => box.type === 'moof') != null) {\n        firstMoofReady = true;\n      } else {\n        return null;\n      }\n    }\n    if (sendedBoxIdx >= boxes.length) return null;\n\n    const ds = new mp4box.DataStream();\n    ds.endianness = mp4box.DataStream.BIG_ENDIAN;\n\n    let i = sendedBoxIdx;\n    try {\n      for (; i < boxes.length; ) {\n        boxes[i].write(ds);\n        delete boxes[i];\n        i += 1;\n      }\n    } catch (err) {\n      const errBox = boxes[i];\n      if (err instanceof Error && errBox != null) {\n        throw Error(\n          `${err.message} | deltaBuf( boxType: ${errBox.type}, boxSize: ${errBox.size}, boxDataLen: ${errBox.data?.length ?? -1})`,\n        );\n      }\n      throw err;\n    }\n\n    unsafeReleaseMP4BoxFile(file);\n\n    sendedBoxIdx = boxes.length;\n    return new Uint8Array(ds.buffer);\n  };\n\n  let stoped = false;\n  let canceled = false;\n  let exit: ((err?: Error) => void) | null = null;\n  const stream = new ReadableStream({\n    start(ctrl) {\n      timerId = self.setInterval(() => {\n        const d = deltaBuf();\n        if (d != null && !canceled) ctrl.enqueue(d);\n      }, timeSlice);\n\n      exit = (err) => {\n        clearInterval(timerId);\n        file.flush();\n        if (err != null) {\n          ctrl.error(err);\n          return;\n        }\n\n        const d = deltaBuf();\n        if (d != null && !canceled) ctrl.enqueue(d);\n\n        if (!canceled) ctrl.close();\n      };\n\n      // 安全起见，检测如果start触发时已经 stoped\n      if (stoped) exit();\n    },\n    cancel() {\n      canceled = true;\n      clearInterval(timerId);\n      onCancel?.();\n    },\n  });\n\n  return {\n    stream,\n    stop: (err) => {\n      if (stoped) return;\n      stoped = true;\n      exit?.(err);\n    },\n  };\n}\n\n/**\n * 强行回收 mp4boxfile 尽量降低内存占用，会破坏 file 导致无法正常使用\n * 仅用于获取二进制后，不再需要任何 file 功能的场景\n */\nfunction unsafeReleaseMP4BoxFile(file: MP4File) {\n  if (file.moov == null) return;\n  for (var j = 0; j < file.moov.traks.length; j++) {\n    file.moov.traks[j].samples = [];\n  }\n  file.mdats = [];\n  file.moofs = [];\n}\n","const createBoxHeader = (type: string, size: number): Uint8Array => {\n  const buffer = new Uint8Array(8);\n  const view = new DataView(buffer.buffer);\n  view.setUint32(0, size); // Write size as a 32-bit unsigned integer\n  for (let i = 0; i < 4; i++) {\n    buffer[4 + i] = type.charCodeAt(i); // Write type as a 4-character string\n  }\n  return buffer;\n};\n\nconst createHdlrBox = (): Uint8Array => {\n  const tec = new TextEncoder();\n  const handlerType = tec.encode('mdta');\n  const nameBytes = tec.encode('mp4 handler');\n  // header8 + ?8 + mdta4 + ?12 + nameSize + endFlag1\n  const size = 8 + 8 + 4 + 12 + nameBytes.byteLength + 1;\n  const buffer = new Uint8Array(size);\n  const view = new DataView(buffer.buffer);\n\n  // Box header\n  buffer.set(createBoxHeader('hdlr', size), 0);\n\n  // Full box header (version and flags)\n  view.setUint32(8, 0);\n\n  buffer.set(handlerType, 16);\n  buffer.set(nameBytes, 32);\n\n  return buffer;\n};\n\nconst createKeysBox = (keys: string[]): Uint8Array => {\n  const tec = new TextEncoder();\n  const keyNamespace = tec.encode('mdta');\n  const keyData = keys.map((key) => {\n    const keyBuf = tec.encode(key);\n    // size4 + namespace4 + keyBuf\n    const size = 4 + 4 + keyBuf.byteLength;\n\n    const entryBuf = new Uint8Array(size);\n    const dv = new DataView(entryBuf.buffer);\n    dv.setUint32(0, size);\n    entryBuf.set(keyNamespace, 4);\n    entryBuf.set(keyBuf, 4 + keyNamespace.byteLength);\n\n    return entryBuf;\n  });\n  const keyDataSize = keyData.reduce((acc, cur) => acc + cur.byteLength, 0);\n\n  const size = 16 + keyDataSize; // 16 bytes for the header and version/flags\n  const buffer = new Uint8Array(size);\n  const view = new DataView(buffer.buffer);\n\n  // Box header\n  buffer.set(createBoxHeader('keys', size), 0);\n\n  // Full box header (version and flags)\n  view.setUint32(8, 0);\n  view.setUint32(12, keys.length); // Entry count\n\n  // Keys\n  let offset = 16;\n  for (const keyBuf of keyData) {\n    buffer.set(keyBuf, offset);\n    offset += keyBuf.byteLength;\n  }\n\n  return buffer;\n};\n\nconst createIlstBox = (data: Record<string, string>): Uint8Array => {\n  const tec = new TextEncoder();\n  const dataStrBuf = tec.encode('data');\n  const valueData = Object.entries(data).map(([_, value], index) => {\n    const keyId = index + 1; // Assuming keys start from 1\n    const valueBytes = tec.encode(value);\n    // size4 + keyId4 + valueSize4 + data4 + idx4 + ?4 + value\n    const entrySize = 4 + 4 + 4 + 4 + 4 + 4 + valueBytes.byteLength;\n\n    const buffer = new Uint8Array(entrySize);\n    const view = new DataView(buffer.buffer);\n    view.setUint32(0, entrySize);\n    view.setUint32(4, keyId);\n\n    view.setUint32(8, 16 + valueBytes.byteLength);\n    buffer.set(dataStrBuf, 12); // 'data' type\n\n    // data idx=1\n    view.setUint32(16, 1);\n    // Value\n    buffer.set(valueBytes, 24);\n\n    return buffer;\n  });\n\n  const valueDataSize = valueData.reduce((acc, cur) => acc + cur.byteLength, 0);\n  const totalSizwe = 8 + valueDataSize;\n  const buffer = new Uint8Array(totalSizwe);\n  buffer.set(createBoxHeader('ilst', totalSizwe), 0);\n\n  let offset = 8;\n  for (const entry of valueData) {\n    buffer.set(entry, offset);\n    offset += entry.byteLength;\n  }\n\n  return buffer;\n};\n\nexport const createMetaBox = (data: Record<string, string>): Uint8Array => {\n  const hdlrBox = createHdlrBox();\n  const keysBox = createKeysBox(Object.keys(data));\n  const ilstBox = createIlstBox(data);\n\n  const size = hdlrBox.length + keysBox.length + ilstBox.length;\n  const buffer = new Uint8Array(size);\n\n  // buffer.set(createBoxHeader('meta', size), 0);\n  buffer.set(hdlrBox, 0);\n  buffer.set(keysBox, hdlrBox.length);\n  buffer.set(ilstBox, hdlrBox.length + keysBox.length);\n\n  return buffer;\n};\n","/**\n * 将任意对象转换成String，如果包含Error，则将Error转换为err.toString()\n * @param val any\n */\nfunction any2Str(val: any): string {\n  if (val instanceof Error) return String(val);\n  return typeof val === 'object'\n    ? JSON.stringify(val, (_, v) => (v instanceof Error ? String(v) : v))\n    : String(val);\n}\n\nfunction getTimeStr() {\n  const d = new Date();\n  return `${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}.${d.getMilliseconds()}`;\n}\n\nlet THRESHOLD = 1;\n\ntype LvName = 'debug' | 'info' | 'warn' | 'error';\nconst history: Array<{ lvName: string; timeStr: string; args: any[] }> = [];\nconst lvHandler = ['debug', 'info', 'warn', 'error'].reduce(\n  (acc, lvName, lvThres) =>\n    Object.assign(acc, {\n      [lvName]: (...args: any[]) => {\n        if (THRESHOLD <= lvThres) {\n          console[lvName as LvName](...args);\n          history.push({\n            lvName,\n            timeStr: getTimeStr(),\n            args,\n          });\n        }\n      },\n    }),\n  {} as Record<LvName, typeof console.log>,\n);\n\nconst map = new Map<Function, number>();\n\n/**\n * 全局日志对象，将日志内容写入 OPFS 临时文件\n */\nexport const Log = {\n  /**\n   * 设置记录日志的级别\n   *\n   * @example\n   * Log.setLogLevel(Log.warn) // 记录 warn，error 日志\n   */\n  setLogLevel: <T extends Function>(logfn: T) => {\n    THRESHOLD = map.get(logfn) ?? 1;\n  },\n  ...lvHandler,\n  /**\n   * 生成一个 log 实例，所有输出前都会附加 tag\n   *\n   * @example\n   * const log = Log.create('<prefix>')\n   * log.info('xxx') // '<prefix> xxx'\n   */\n  create: (tag: string) => {\n    return Object.fromEntries(\n      Object.entries(lvHandler).map(([k, h]) => [\n        k,\n        (...args: any[]) => h(tag, ...args),\n      ]),\n    );\n  },\n\n  /**\n   * 将所有日志导出为一个字符串\n   *\n   * @example\n   * Log.dump() // => [level][time]  内容...\n   *\n   */\n  async dump() {\n    return history.reduce(\n      (acc, { lvName, timeStr, args }) =>\n        acc +\n        `[${lvName}][${timeStr}]  ${args.map((a) => any2Str(a)).join(' ')}\\n`,\n      '',\n    );\n  },\n};\n\nmap.set(Log.debug, 0);\nmap.set(Log.info, 1);\nmap.set(Log.warn, 2);\nmap.set(Log.error, 3);\n\ndeclare const PKG_VERSION: string;\n\ndeclare class PressureObserver {\n  constructor(\n    callback: (changes: PressureRecord[], observer: PressureObserver) => void,\n  );\n  observe(\n    resource: string,\n    options?: { sampleInterval?: number },\n  ): Promise<void>;\n  unobserve(): void;\n  takeRecords(): PressureRecord[];\n}\n\ninterface PressureRecord {\n  state: 'critical' | 'serious' | 'normal';\n}\n\n(async function init() {\n  await Promise.resolve();\n  if (globalThis.navigator == null || globalThis.document == null) return;\n  Log.info(\n    `@webav version: ${PKG_VERSION}, date: ${new Date().toLocaleDateString()}`,\n  );\n  Log.info(globalThis.navigator.userAgent);\n  document.addEventListener('visibilitychange', () => {\n    Log.info(`visibilitychange: ${document.visibilityState}`);\n  });\n\n  if ('PressureObserver' in globalThis) {\n    const observer = new PressureObserver((records) => {\n      Log.info(\n        `cpu state change: ${JSON.stringify(records.map((r) => r.state))}`,\n      );\n    });\n    observer.observe('cpu');\n  }\n})();\n\nif (import.meta.env?.DEV) {\n  Log.setLogLevel(Log.debug);\n}\n\nif (import.meta.env?.MODE === 'test') {\n  Log.setLogLevel(Log.warn);\n}\n","import mp4box, { MP4File, SampleOpts } from '@webav/mp4box.js';\nimport { EventTool } from './event-tool';\nimport { createMetaBox } from './meta-box';\nimport { workerTimer } from './worker-timer';\nimport { Log } from './log';\n\ntype TCleanFn = () => void;\n\n/**\n * 定义 recodemux 函数的配置选项\n */\ninterface IRecodeMuxOpts {\n  /**\n   * 视频配置选项，如果为 null 则不处理视频。\n   */\n  video: {\n    width: number;\n    height: number;\n    expectFPS: number;\n    codec: string;\n    bitrate: number;\n    /**\n     * 不安全，随时可能废弃\n     */\n    __unsafe_hardwareAcceleration__?: HardwareAcceleration;\n  } | null;\n  /**\n   * 音频配置选项，如果为 null 则不处理音频。\n   */\n  audio: {\n    codec: 'opus' | 'aac';\n    sampleRate: number;\n    channelCount: number;\n  } | null;\n  /**\n   * 预设时长，不代表 track 实际时长\n   */\n  duration?: number;\n  metaDataTags?: Record<string, string>;\n}\n\n/**\n * 处理音视频的编码和解码。\n * @param opts - 编码音视频数据的配置\n */\nexport function recodemux(opts: IRecodeMuxOpts): {\n  /**\n   * 编码视频帧\n   */\n  encodeVideo: (\n    frame: VideoFrame,\n    options: VideoEncoderEncodeOptions,\n    gopId?: number,\n  ) => void;\n  /**\n   * 编码音频数据\n   */\n  encodeAudio: (data: AudioData) => void;\n  /**\n   * close 编码器，停止任务\n   */\n  close: TCleanFn;\n  /**\n   * 清空编码器队列\n   */\n  flush: () => Promise<void>;\n  /**\n   * mp4box 实例\n   */\n  mp4file: MP4File;\n  /**\n   * 返回队列长度（背压），用于控制生产视频的进度，队列过大会会占用大量显存\n   */\n  getEncodeQueueSize: () => number;\n} {\n  Log.info('recodemux opts:', opts);\n  const mp4file = mp4box.createFile();\n\n  // 音视频轨道必须同时创建, 保存在 moov 中\n  const avSyncEvtTool = new EventTool<\n    Record<'VideoReady' | 'AudioReady', () => void>\n  >();\n\n  const addMetadata = (\n    moov: NonNullable<MP4File['moov']>,\n    tags: NonNullable<IRecodeMuxOpts['metaDataTags']>,\n  ) => {\n    const udtaBox = moov.add('udta');\n    const metaBox = udtaBox.add('meta');\n    metaBox.data = createMetaBox(tags);\n    metaBox.size = metaBox.data.byteLength;\n  };\n\n  let moovReady = false;\n  const onMoovReady = () => {\n    if (mp4file.moov == null || moovReady) return;\n    moovReady = true;\n\n    if (opts.metaDataTags != null) addMetadata(mp4file.moov, opts.metaDataTags);\n    if (opts.duration != null) {\n      mp4file.moov.mvhd.duration = opts.duration;\n    }\n  };\n\n  avSyncEvtTool.once('VideoReady', onMoovReady);\n  avSyncEvtTool.once('AudioReady', onMoovReady);\n\n  let vEncoder =\n    opts.video != null\n      ? encodeVideoTrack(opts.video, mp4file, avSyncEvtTool)\n      : null;\n  let aEncoder =\n    opts.audio != null\n      ? encodeAudioTrack(opts.audio, mp4file, avSyncEvtTool)\n      : null;\n  if (opts.video == null) avSyncEvtTool.emit('VideoReady');\n  if (opts.audio == null) avSyncEvtTool.emit('AudioReady');\n\n  return {\n    encodeVideo: (vf, opts) => {\n      vEncoder?.encode(vf, opts);\n      vf.close();\n    },\n    encodeAudio: (ad) => {\n      if (aEncoder == null) return;\n      try {\n        aEncoder.encode(ad);\n        ad.close();\n      } catch (err) {\n        const errMsg = `encode audio chunk error: ${(err as Error).message}, state: ${JSON.stringify(\n          {\n            qSize: aEncoder.encodeQueueSize,\n            state: aEncoder.state,\n          },\n        )}`;\n        Log.error(errMsg);\n        throw Error(errMsg);\n      }\n    },\n    getEncodeQueueSize: () =>\n      vEncoder?.encodeQueueSize ?? aEncoder?.encodeQueueSize ?? 0,\n    flush: async () => {\n      await Promise.all([\n        vEncoder?.flush(),\n        aEncoder?.state === 'configured' ? aEncoder.flush() : null,\n      ]);\n      return;\n    },\n    close: () => {\n      avSyncEvtTool.destroy();\n      vEncoder?.close();\n      if (aEncoder?.state === 'configured') aEncoder.close();\n    },\n    mp4file,\n  };\n}\n\nfunction encodeVideoTrack(\n  opts: NonNullable<IRecodeMuxOpts['video']>,\n  mp4File: MP4File,\n  avSyncEvtTool: EventTool<Record<'VideoReady' | 'AudioReady', () => void>>,\n) {\n  const videoTrackOpts = {\n    // 微秒\n    timescale: 1e6,\n    width: opts.width,\n    height: opts.height,\n    brands: ['isom', 'iso2', 'avc1', 'mp42', 'mp41'],\n    avcDecoderConfigRecord: null as ArrayBuffer | undefined | null,\n    name: 'Track created with WebAV',\n  };\n\n  let trackId = -1;\n  let audioReady = false;\n  avSyncEvtTool.once('AudioReady', () => {\n    audioReady = true;\n  });\n\n  const samplesCache: Record<\n    'encoder0' | 'encoder1',\n    Array<ReturnType<typeof chunk2MP4SampleOpts>>\n  > = {\n    encoder0: [],\n    encoder1: [],\n  };\n  const outputHandler = (\n    encId: 'encoder0' | 'encoder1',\n    chunk: EncodedVideoChunk,\n    meta?: EncodedVideoChunkMetadata,\n  ) => {\n    if (trackId === -1 && meta != null) {\n      const desc = meta.decoderConfig?.description as ArrayBuffer;\n      fixChromeConstraintSetFlagsBug(desc);\n      videoTrackOpts.avcDecoderConfigRecord = desc;\n      trackId = mp4File.addTrack(videoTrackOpts);\n      avSyncEvtTool.emit('VideoReady');\n      Log.info('VideoEncoder, video track ready, trackId:', trackId);\n    }\n\n    samplesCache[encId].push(chunk2MP4SampleOpts(chunk));\n  };\n\n  let curEncId: 'encoder0' | 'encoder1' = 'encoder1';\n  let lastAddedSampleTime = 0;\n  // 双编码器交替消费，保证帧的顺序\n  // 小于期望帧间隔帧判定为连续的\n  const deltaTime = Math.floor((1000 / opts.expectFPS) * 1e3);\n  function checkCache() {\n    if (!audioReady) return;\n    const nextEncId = curEncId === 'encoder1' ? 'encoder0' : 'encoder1';\n    const curCache = samplesCache[curEncId];\n    const nextCache = samplesCache[nextEncId];\n    // 无数据\n    if (curCache.length === 0 && nextCache.length === 0) return;\n\n    let curFirst = curCache[0];\n    // 当前队列正在进行中（非关键帧 或 时间连续），继续消费\n    if (curFirst != null) {\n      if (!curFirst.is_sync || curFirst.cts - lastAddedSampleTime < deltaTime) {\n        const lastTs = addSampleToFile(curCache);\n        if (lastTs > lastAddedSampleTime) lastAddedSampleTime = lastTs;\n      }\n    }\n\n    const nextFirst = nextCache[0];\n\n    // 另一个队列跟已消费的最后一帧是连续的，则需要切换\n    if (nextFirst?.is_sync && nextFirst.cts - lastAddedSampleTime < deltaTime) {\n      curEncId = nextEncId;\n      // 说明另一个队列有数据，尽快消费\n      checkCache();\n      return;\n    }\n\n    // 如果时间不连续，但两个队列都有数据，且都是关键帧，消费时间较早的队列\n    if (curFirst?.is_sync && nextFirst?.is_sync) {\n      if (curFirst.cts <= nextFirst.cts) {\n        const lastTs = addSampleToFile(curCache);\n        if (lastTs > lastAddedSampleTime) lastAddedSampleTime = lastTs;\n      } else {\n        curEncId = nextEncId;\n        // 说明另一个队列有数据，尽快消费\n        checkCache();\n        return;\n      }\n    }\n  }\n\n  function addSampleToFile(\n    chunks: Array<ReturnType<typeof chunk2MP4SampleOpts>>,\n  ) {\n    let lastTime = -1;\n    let i = 0;\n    for (; i < chunks.length; i++) {\n      const c = chunks[i];\n      // 每次消费到下一个关键帧结束，可能需要切换队列\n      if (i > 0 && c.is_sync) break;\n\n      mp4File.addSample(trackId, c.data, c);\n      lastTime = c.cts + c.duration;\n    }\n    chunks.splice(0, i);\n    return lastTime;\n  }\n\n  const stopTimer = workerTimer(checkCache, 15);\n\n  const encoder0 = createVideoEncoder(opts, (chunk, meta) =>\n    outputHandler('encoder0', chunk, meta),\n  );\n  const encoder1 = createVideoEncoder(opts, (chunk, meta) =>\n    outputHandler('encoder1', chunk, meta),\n  );\n\n  let gopId = 0;\n  return {\n    get encodeQueueSize() {\n      return encoder0.encodeQueueSize + encoder1.encodeQueueSize;\n    },\n    encode: (vf: VideoFrame, opts: VideoEncoderEncodeOptions) => {\n      try {\n        if (opts.keyFrame) gopId += 1;\n        const encoder = gopId % 2 === 0 ? encoder0 : encoder1;\n        encoder.encode(vf, opts);\n      } catch (err) {\n        const errMsg = `encode video frame error: ${(err as Error).message}, state: ${JSON.stringify(\n          {\n            ts: vf.timestamp,\n            keyFrame: opts.keyFrame,\n            duration: vf.duration,\n            gopId,\n          },\n        )}`;\n        Log.error(errMsg);\n        throw Error(errMsg);\n      }\n    },\n    flush: async () => {\n      await Promise.all([\n        encoder0.state === 'configured' ? await encoder0.flush() : null,\n        encoder1.state === 'configured' ? await encoder1.flush() : null,\n      ]);\n      stopTimer();\n      checkCache();\n    },\n    close: () => {\n      if (encoder0.state === 'configured') encoder0.close();\n      if (encoder1.state === 'configured') encoder1.close();\n    },\n  };\n}\n\n// https://github.com/WebAV-Tech/WebAV/issues/203\nfunction fixChromeConstraintSetFlagsBug(desc: ArrayBuffer) {\n  const u8 = new Uint8Array(desc);\n  const constraintSetFlag = u8[2];\n  // 如果 constraint_set_flags 字节二进制 第0位或第1位值为1\n  // 说明取值错误，忽略该字段避免解码异常\n  if (constraintSetFlag.toString(2).slice(-2).includes('1')) {\n    u8[2] = 0;\n  }\n}\n\nfunction createVideoEncoder(\n  videoOpts: NonNullable<IRecodeMuxOpts['video']>,\n  outHandler: EncodedVideoChunkOutputCallback,\n): VideoEncoder {\n  const encoderConf = {\n    codec: videoOpts.codec,\n    framerate: videoOpts.expectFPS,\n    hardwareAcceleration: videoOpts.__unsafe_hardwareAcceleration__,\n    // 码率\n    bitrate: videoOpts.bitrate,\n    width: videoOpts.width,\n    height: videoOpts.height,\n    // H264 不支持背景透明度\n    alpha: 'discard',\n    // macos 自带播放器只支持avc\n    avc: { format: 'avc' },\n    // mp4box.js 无法解析 annexb 的 mimeCodec ，只会显示 avc1\n    // avc: { format: 'annexb' }\n  } as const;\n  const encoder = new VideoEncoder({\n    error: (err) => {\n      const errMsg = `VideoEncoder error: ${err.message}, config: ${JSON.stringify(encoderConf)}, state: ${JSON.stringify(\n        {\n          qSize: encoder.encodeQueueSize,\n          state: encoder.state,\n        },\n      )}`;\n      Log.error(errMsg);\n      throw Error(errMsg);\n    },\n    output: outHandler,\n  });\n\n  encoder.configure(encoderConf);\n  return encoder;\n}\n\nfunction encodeAudioTrack(\n  audioOpts: NonNullable<IRecodeMuxOpts['audio']>,\n  mp4File: MP4File,\n  avSyncEvtTool: EventTool<Record<'VideoReady' | 'AudioReady', () => void>>,\n): AudioEncoder {\n  const audioTrackOpts = {\n    timescale: 1e6,\n    samplerate: audioOpts.sampleRate,\n    channel_count: audioOpts.channelCount,\n    hdlr: 'soun',\n    type: audioOpts.codec === 'aac' ? 'mp4a' : 'Opus',\n    name: 'Track created with WebAV',\n  };\n\n  let trackId = -1;\n  let cache: EncodedAudioChunk[] = [];\n  let videoReady = false;\n  avSyncEvtTool.once('VideoReady', () => {\n    videoReady = true;\n    cache.forEach((c) => {\n      const s = chunk2MP4SampleOpts(c);\n      mp4File.addSample(trackId, s.data, s);\n    });\n    cache = [];\n  });\n\n  const encoderConf = {\n    codec: audioOpts.codec === 'aac' ? 'mp4a.40.2' : 'opus',\n    sampleRate: audioOpts.sampleRate,\n    numberOfChannels: audioOpts.channelCount,\n    bitrate: 128_000,\n  } as const;\n\n  const encoder = new AudioEncoder({\n    error: (err) => {\n      const errMsg = `AudioEncoder error: ${err.message}, config: ${JSON.stringify(\n        encoderConf,\n      )}, state: ${JSON.stringify({\n        qSize: encoder.encodeQueueSize,\n        state: encoder.state,\n      })}`;\n      Log.error(errMsg);\n      throw Error(errMsg);\n    },\n    output: (chunk, meta) => {\n      if (trackId === -1) {\n        // 某些设备不会输出 description\n        const desc = meta.decoderConfig?.description;\n        trackId = mp4File.addTrack({\n          ...audioTrackOpts,\n          description: desc == null ? undefined : createESDSBox(desc),\n        });\n        avSyncEvtTool.emit('AudioReady');\n        Log.info('AudioEncoder, audio track ready, trackId:', trackId);\n      }\n\n      if (videoReady) {\n        const s = chunk2MP4SampleOpts(chunk);\n        mp4File.addSample(trackId, s.data, s);\n      } else {\n        cache.push(chunk);\n      }\n    },\n  });\n  encoder.configure(encoderConf);\n\n  return encoder;\n}\n\n/**\n * 创建 ESDS 盒子（MPEG-4 Elementary Stream Descriptor）\n * ESDS 盒子用于描述 MPEG-4 的流信息，如编解码器类型、流类型、最大比特率、平均比特率等\n * @param config - 配置信息，可以是 `ArrayBuffer` 或 `ArrayBufferView` 类型\n * @return 返回一个 ESDS box\n */\nfunction createESDSBox(config: ArrayBuffer | ArrayBufferView) {\n  const configlen = config.byteLength;\n  const buf = new Uint8Array([\n    0x00, // version 0\n    0x00,\n    0x00,\n    0x00, // flags\n\n    0x03, // descriptor_type\n    0x17 + configlen, // length\n    0x00,\n    // 0x01, // es_id\n    0x02, // es_id\n    0x00, // stream_priority\n\n    0x04, // descriptor_type\n    0x12 + configlen, // length\n    0x40, // codec : mpeg4_audio\n    0x15, // stream_type\n    0x00,\n    0x00,\n    0x00, // buffer_size\n    0x00,\n    0x00,\n    0x00,\n    0x00, // maxBitrate\n    0x00,\n    0x00,\n    0x00,\n    0x00, // avgBitrate\n\n    0x05, // descriptor_type\n\n    configlen,\n    ...new Uint8Array(config instanceof ArrayBuffer ? config : config.buffer),\n\n    0x06,\n    0x01,\n    0x02,\n  ]);\n\n  const esdsBox = new mp4box.BoxParser.esdsBox(buf.byteLength);\n  esdsBox.hdr_size = 0;\n  esdsBox.parse(new mp4box.DataStream(buf, 0, mp4box.DataStream.BIG_ENDIAN));\n  return esdsBox;\n}\n\n/**\n * EncodedAudioChunk | EncodedVideoChunk 转换为 MP4 addSample 需要的参数\n */\nfunction chunk2MP4SampleOpts(\n  chunk: EncodedAudioChunk | EncodedVideoChunk,\n): SampleOpts & {\n  data: ArrayBuffer;\n} {\n  const buf = new ArrayBuffer(chunk.byteLength);\n  chunk.copyTo(buf);\n  const dts = chunk.timestamp;\n  return {\n    duration: chunk.duration ?? 0,\n    dts,\n    cts: dts,\n    is_sync: chunk.type === 'key',\n    data: buf,\n  };\n}\n"],"names":["EventTool","__privateAdd","_listeners","__publicField","type","listener","handlers","__privateGet","off","args","handler","from","to","evtTypes","removeHandlers","evtType","fromEvtType","toEvtType","fn","setup","timerId","interval","e","createWorker","blob","url","handlerMap","runCount","worker","k","v","workerTimer","time","groupId","fns","autoReadStream","stream","cbs","stoped","run","reader","value","done","file2stream","file","timeSlice","onCancel","sendedBoxIdx","boxes","firstMoofReady","deltaBuf","box","ds","mp4box","i","err","errBox","_a","unsafeReleaseMP4BoxFile","canceled","exit","ctrl","d","j","createBoxHeader","size","buffer","createHdlrBox","tec","handlerType","nameBytes","view","createKeysBox","keys","keyNamespace","keyData","key","keyBuf","entryBuf","acc","cur","offset","createIlstBox","data","dataStrBuf","valueData","_","index","keyId","valueBytes","entrySize","totalSizwe","entry","createMetaBox","hdlrBox","keysBox","ilstBox","any2Str","val","getTimeStr","THRESHOLD","history","lvHandler","lvName","lvThres","map","Log","logfn","tag","h","timeStr","a","records","recodemux","opts","mp4file","avSyncEvtTool","addMetadata","moov","tags","metaBox","moovReady","onMoovReady","vEncoder","encodeVideoTrack","aEncoder","encodeAudioTrack","vf","ad","errMsg","mp4File","videoTrackOpts","trackId","audioReady","samplesCache","outputHandler","encId","chunk","meta","desc","fixChromeConstraintSetFlagsBug","chunk2MP4SampleOpts","curEncId","lastAddedSampleTime","deltaTime","checkCache","nextEncId","curCache","nextCache","curFirst","lastTs","addSampleToFile","nextFirst","chunks","lastTime","c","stopTimer","encoder0","createVideoEncoder","encoder1","gopId","u8","videoOpts","outHandler","encoderConf","encoder","audioOpts","audioTrackOpts","cache","videoReady","s","createESDSBox","config","configlen","buf","esdsBox","dts"],"mappings":"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"}