{"version":3,"file":"internal-utils.js","sources":["../src/event-tool.ts","../src/worker-timer.ts","../src/stream-utils.ts","../src/meta-box.ts","../src/log.ts","../src/recodemux.ts"],"sourcesContent":["type EventKey = string | symbol;\n\ntype EventToolType = Record<EventKey, (...args: any[]) => any>;\n\n/**\n * 事件工具类\n *\n * @example\n * const evtTool = new EventTool<{\n *   timeupdate: (time: number) => void;\n *   paused: () => void;\n *   playing: () => void;\n * }>()\n * evtTool.on('paused', () => {})\n * evtTool.emit('paused')\n */\nexport class EventTool<T extends EventToolType> {\n  /**\n   * 在两个 EventTool 实例间转发消息\n   * @param from\n   * @param to\n   * @param evtTypes 需转发的消息类型\n   *\n   * @example\n   * EventTool.forwardEvent(from, to, ['evtName']),\n   */\n  static forwardEvent<\n    T1 extends EventToolType,\n    T2 extends EventToolType,\n    EvtType extends (keyof T1 | [keyof T1, keyof T2])[],\n  >(\n    from: { on: EventTool<T1>['on'] },\n    to: { emit: EventTool<T2>['emit'] },\n    // 转发的事件名，如果 evtTypes 为序对（元组）表示事件名称需要映射\n    evtTypes: EvtType,\n  ): () => void {\n    const removeHandlers = evtTypes.map((evtType) => {\n      const [fromEvtType, toEvtType] = (\n        Array.isArray(evtType) ? evtType : [evtType, evtType]\n      ) as [keyof T1, keyof T2];\n\n      // @ts-expect-error\n      return from.on(fromEvtType, (...args) => {\n        // @ts-expect-error\n        to.emit(toEvtType, ...args);\n      });\n    });\n    return () => {\n      removeHandlers.forEach((fn) => fn());\n    };\n  }\n\n  #listeners = new Map<keyof T, Set<T[keyof T]>>();\n\n  /**\n   * 监听 EventType 中定义的事件\n   */\n  on = <Type extends keyof T>(type: Type, listener: T[Type]): (() => void) => {\n    const handlers = this.#listeners.get(type) ?? new Set<T[keyof T]>();\n    handlers.add(listener);\n\n    if (!this.#listeners.has(type)) {\n      this.#listeners.set(type, handlers);\n    }\n\n    return () => {\n      handlers.delete(listener);\n      if (handlers.size === 0) {\n        this.#listeners.delete(type);\n      }\n    };\n  };\n\n  /**\n   * 监听事件，首次触发后自动移除监听\n   *\n   * 期望回调一次的事件，使用 once; 期望多次回调使用 on\n   */\n  once = <Type extends keyof T>(\n    type: Type,\n    listener: T[Type],\n  ): (() => void) => {\n    // @ts-ignore\n    const off = this.on(type, (...args) => {\n      off();\n      listener(...args);\n    });\n\n    return off;\n  };\n\n  /**\n   * 触发事件\n   * @param type\n   * @param args\n   * @returns\n   */\n  emit = <Type extends keyof T>(\n    type: Type,\n    ...args: Type extends string\n      ? T[Type] extends (...args: any[]) => any\n        ? Parameters<T[Type]>\n        : never\n      : never\n  ): void => {\n    const handlers = this.#listeners.get(type);\n    if (handlers == null) return;\n\n    handlers.forEach((handler) => handler(...args));\n  };\n\n  destroy(): void {\n    this.#listeners.clear();\n  }\n}\n","const setup = (): void => {\n  let timerId: number;\n\n  let interval: number = 16.6;\n\n  self.onmessage = (e) => {\n    if (e.data.event === 'start') {\n      self.clearInterval(timerId);\n      timerId = self.setInterval(() => {\n        self.postMessage({});\n      }, interval);\n    }\n\n    if (e.data.event === 'stop') {\n      self.clearInterval(timerId);\n    }\n  };\n};\n\nconst createWorker = (): Worker => {\n  const blob = new Blob([`(${setup.toString()})()`]);\n  const url = URL.createObjectURL(blob);\n  return new Worker(url);\n};\n\nconst handlerMap = new Map<number, Set<() => void>>();\nlet runCount = 1;\n\nlet worker: Worker | null = null;\nif (globalThis.Worker != null) {\n  worker = createWorker();\n  worker.onmessage = () => {\n    runCount += 1;\n    for (const [k, v] of handlerMap) {\n      if (runCount % k === 0) for (const fn of v) fn();\n    }\n  };\n}\n\n/**\n * 专门解决页面长时间处于后台时，定时器不（或延迟）执行的问题\n *\n * 跟 `setInterval` 很相似，⚠️ 但 time 会有一定偏差，请优先使用 `setInterval`\n *\n * @see [JS 定时器时长控制细节](https://hughfenghen.github.io/posts/2023/06/15/timer-delay/)\n */\nexport const workerTimer = (\n  handler: () => void,\n  time: number,\n): (() => void) => {\n  const groupId = Math.round(time / 16.6);\n  const fns = handlerMap.get(groupId) ?? new Set();\n  fns.add(handler);\n  handlerMap.set(groupId, fns);\n\n  if (handlerMap.size === 1 && fns.size === 1) {\n    worker?.postMessage({ event: 'start' });\n  }\n\n  return () => {\n    fns.delete(handler);\n    if (fns.size === 0) handlerMap.delete(groupId);\n    if (handlerMap.size === 0) {\n      runCount = 0;\n      worker?.postMessage({ event: 'stop' });\n    }\n  };\n};\n","import mp4box, { MP4File } from '@webav/mp4box.js';\n/**\n * 自动读取流并处理每个数据块。\n *\n * @template ST - 可读流的类型。\n * @param stream - 要读取的流。\n * @param cbs - 回调函数对象。\n * @param cbs.onChunk - 当读取到新的数据块时调用的函数。该函数接收一个参数，即数据块，并返回一个 Promise。\n * @param cbs.onDone - 当读取完所有数据块时调用的函数。\n * @returns - 返回一个函数，调用该函数可以停止读取流。\n *\n * @example\n * const stream = getSomeReadableStream();\n * const onChunk = async (chunk) => {\n *   console.log('New chunk:', chunk);\n * };\n * const onDone = () => {\n *   console.log('Done reading stream');\n * };\n * const stopReading = autoReadStream(stream, { onChunk, onDone });\n * // Later...\n * stopReading();\n */\nexport function autoReadStream<ST extends ReadableStream>(\n  stream: ST,\n  cbs: {\n    onChunk: ST extends ReadableStream<infer DT>\n      ? (chunk: DT) => Promise<void>\n      : never;\n    onDone: () => void;\n  },\n) {\n  let stoped = false;\n  async function run() {\n    const reader = stream.getReader();\n\n    while (!stoped) {\n      const { value, done } = await reader.read();\n      if (done) {\n        cbs.onDone();\n        return;\n      }\n      await cbs.onChunk(value);\n    }\n\n    reader.releaseLock();\n    await stream.cancel();\n  }\n\n  run().catch(console.error);\n\n  return () => {\n    stoped = true;\n  };\n}\n\n/**\n * 将 mp4box file 转换为文件流，用于上传服务器或存储到本地\n * @param file - MP4 文件实例 {@link MP4File}。\n * @param timeSlice - 时间片，用于控制流的发送速度。\n * @param onCancel - 当返回的流被取消时触发该回调函数\n */\nexport function file2stream(\n  file: MP4File,\n  timeSlice: number,\n  onCancel?: () => void,\n): {\n  /**\n   * 可读流，流的数据是 `Uint8Array`\n   */\n  stream: ReadableStream<Uint8Array>;\n  /**\n   * 流的生产者主动停止向流中输出数据，可向消费者传递错误信息\n   */\n  stop: (err?: Error) => void;\n} {\n  let timerId = 0;\n\n  let sendedBoxIdx = 0;\n  const boxes = file.boxes;\n\n  let firstMoofReady = false;\n  const deltaBuf = (): Uint8Array | null => {\n    // 避免 moov 未完成时写入文件，导致文件无法被识别\n    if (!firstMoofReady) {\n      if (boxes.find((box) => box.type === 'moof') != null) {\n        firstMoofReady = true;\n      } else {\n        return null;\n      }\n    }\n    if (sendedBoxIdx >= boxes.length) return null;\n\n    const ds = new mp4box.DataStream();\n    ds.endianness = mp4box.DataStream.BIG_ENDIAN;\n\n    let i = sendedBoxIdx;\n    try {\n      for (; i < boxes.length; ) {\n        boxes[i].write(ds);\n        delete boxes[i];\n        i += 1;\n      }\n    } catch (err) {\n      const errBox = boxes[i];\n      if (err instanceof Error && errBox != null) {\n        throw Error(\n          `${err.message} | deltaBuf( boxType: ${errBox.type}, boxSize: ${errBox.size}, boxDataLen: ${errBox.data?.length ?? -1})`,\n        );\n      }\n      throw err;\n    }\n\n    unsafeReleaseMP4BoxFile(file);\n\n    sendedBoxIdx = boxes.length;\n    return new Uint8Array(ds.buffer);\n  };\n\n  let stoped = false;\n  let canceled = false;\n  let exit: ((err?: Error) => void) | null = null;\n  const stream = new ReadableStream({\n    start(ctrl) {\n      timerId = self.setInterval(() => {\n        const d = deltaBuf();\n        if (d != null && !canceled) ctrl.enqueue(d);\n      }, timeSlice);\n\n      exit = (err) => {\n        clearInterval(timerId);\n        file.flush();\n        if (err != null) {\n          ctrl.error(err);\n          return;\n        }\n\n        const d = deltaBuf();\n        if (d != null && !canceled) ctrl.enqueue(d);\n\n        if (!canceled) ctrl.close();\n      };\n\n      // 安全起见，检测如果start触发时已经 stoped\n      if (stoped) exit();\n    },\n    cancel() {\n      canceled = true;\n      clearInterval(timerId);\n      onCancel?.();\n    },\n  });\n\n  return {\n    stream,\n    stop: (err) => {\n      if (stoped) return;\n      stoped = true;\n      exit?.(err);\n    },\n  };\n}\n\n/**\n * 强行回收 mp4boxfile 尽量降低内存占用，会破坏 file 导致无法正常使用\n * 仅用于获取二进制后，不再需要任何 file 功能的场景\n */\nfunction unsafeReleaseMP4BoxFile(file: MP4File) {\n  if (file.moov == null) return;\n  for (var j = 0; j < file.moov.traks.length; j++) {\n    file.moov.traks[j].samples = [];\n  }\n  file.mdats = [];\n  file.moofs = [];\n}\n","const createBoxHeader = (type: string, size: number): Uint8Array => {\n  const buffer = new Uint8Array(8);\n  const view = new DataView(buffer.buffer);\n  view.setUint32(0, size); // Write size as a 32-bit unsigned integer\n  for (let i = 0; i < 4; i++) {\n    buffer[4 + i] = type.charCodeAt(i); // Write type as a 4-character string\n  }\n  return buffer;\n};\n\nconst createHdlrBox = (): Uint8Array => {\n  const tec = new TextEncoder();\n  const handlerType = tec.encode('mdta');\n  const nameBytes = tec.encode('mp4 handler');\n  // header8 + ?8 + mdta4 + ?12 + nameSize + endFlag1\n  const size = 8 + 8 + 4 + 12 + nameBytes.byteLength + 1;\n  const buffer = new Uint8Array(size);\n  const view = new DataView(buffer.buffer);\n\n  // Box header\n  buffer.set(createBoxHeader('hdlr', size), 0);\n\n  // Full box header (version and flags)\n  view.setUint32(8, 0);\n\n  buffer.set(handlerType, 16);\n  buffer.set(nameBytes, 32);\n\n  return buffer;\n};\n\nconst createKeysBox = (keys: string[]): Uint8Array => {\n  const tec = new TextEncoder();\n  const keyNamespace = tec.encode('mdta');\n  const keyData = keys.map((key) => {\n    const keyBuf = tec.encode(key);\n    // size4 + namespace4 + keyBuf\n    const size = 4 + 4 + keyBuf.byteLength;\n\n    const entryBuf = new Uint8Array(size);\n    const dv = new DataView(entryBuf.buffer);\n    dv.setUint32(0, size);\n    entryBuf.set(keyNamespace, 4);\n    entryBuf.set(keyBuf, 4 + keyNamespace.byteLength);\n\n    return entryBuf;\n  });\n  const keyDataSize = keyData.reduce((acc, cur) => acc + cur.byteLength, 0);\n\n  const size = 16 + keyDataSize; // 16 bytes for the header and version/flags\n  const buffer = new Uint8Array(size);\n  const view = new DataView(buffer.buffer);\n\n  // Box header\n  buffer.set(createBoxHeader('keys', size), 0);\n\n  // Full box header (version and flags)\n  view.setUint32(8, 0);\n  view.setUint32(12, keys.length); // Entry count\n\n  // Keys\n  let offset = 16;\n  for (const keyBuf of keyData) {\n    buffer.set(keyBuf, offset);\n    offset += keyBuf.byteLength;\n  }\n\n  return buffer;\n};\n\nconst createIlstBox = (data: Record<string, string>): Uint8Array => {\n  const tec = new TextEncoder();\n  const dataStrBuf = tec.encode('data');\n  const valueData = Object.entries(data).map(([_, value], index) => {\n    const keyId = index + 1; // Assuming keys start from 1\n    const valueBytes = tec.encode(value);\n    // size4 + keyId4 + valueSize4 + data4 + idx4 + ?4 + value\n    const entrySize = 4 + 4 + 4 + 4 + 4 + 4 + valueBytes.byteLength;\n\n    const buffer = new Uint8Array(entrySize);\n    const view = new DataView(buffer.buffer);\n    view.setUint32(0, entrySize);\n    view.setUint32(4, keyId);\n\n    view.setUint32(8, 16 + valueBytes.byteLength);\n    buffer.set(dataStrBuf, 12); // 'data' type\n\n    // data idx=1\n    view.setUint32(16, 1);\n    // Value\n    buffer.set(valueBytes, 24);\n\n    return buffer;\n  });\n\n  const valueDataSize = valueData.reduce((acc, cur) => acc + cur.byteLength, 0);\n  const totalSizwe = 8 + valueDataSize;\n  const buffer = new Uint8Array(totalSizwe);\n  buffer.set(createBoxHeader('ilst', totalSizwe), 0);\n\n  let offset = 8;\n  for (const entry of valueData) {\n    buffer.set(entry, offset);\n    offset += entry.byteLength;\n  }\n\n  return buffer;\n};\n\nexport const createMetaBox = (data: Record<string, string>): Uint8Array => {\n  const hdlrBox = createHdlrBox();\n  const keysBox = createKeysBox(Object.keys(data));\n  const ilstBox = createIlstBox(data);\n\n  const size = hdlrBox.length + keysBox.length + ilstBox.length;\n  const buffer = new Uint8Array(size);\n\n  // buffer.set(createBoxHeader('meta', size), 0);\n  buffer.set(hdlrBox, 0);\n  buffer.set(keysBox, hdlrBox.length);\n  buffer.set(ilstBox, hdlrBox.length + keysBox.length);\n\n  return buffer;\n};\n","/**\n * 将任意对象转换成String，如果包含Error，则将Error转换为err.toString()\n * @param val any\n */\nfunction any2Str(val: any): string {\n  if (val instanceof Error) return String(val);\n  return typeof val === 'object'\n    ? JSON.stringify(val, (_, v) => (v instanceof Error ? String(v) : v))\n    : String(val);\n}\n\nfunction getTimeStr() {\n  const d = new Date();\n  return `${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}.${d.getMilliseconds()}`;\n}\n\nlet THRESHOLD = 1;\n\ntype LvName = 'debug' | 'info' | 'warn' | 'error';\nconst history: Array<{ lvName: string; timeStr: string; args: any[] }> = [];\nconst lvHandler = ['debug', 'info', 'warn', 'error'].reduce(\n  (acc, lvName, lvThres) =>\n    Object.assign(acc, {\n      [lvName]: (...args: any[]) => {\n        if (THRESHOLD <= lvThres) {\n          console[lvName as LvName](...args);\n          history.push({\n            lvName,\n            timeStr: getTimeStr(),\n            args,\n          });\n        }\n      },\n    }),\n  {} as Record<LvName, typeof console.log>,\n);\n\nconst map = new Map<Function, number>();\n\n/**\n * 全局日志对象，将日志内容写入 OPFS 临时文件\n */\nexport const Log = {\n  /**\n   * 设置记录日志的级别\n   *\n   * @example\n   * Log.setLogLevel(Log.warn) // 记录 warn，error 日志\n   */\n  setLogLevel: <T extends Function>(logfn: T) => {\n    THRESHOLD = map.get(logfn) ?? 1;\n  },\n  ...lvHandler,\n  /**\n   * 生成一个 log 实例，所有输出前都会附加 tag\n   *\n   * @example\n   * const log = Log.create('<prefix>')\n   * log.info('xxx') // '<prefix> xxx'\n   */\n  create: (tag: string) => {\n    return Object.fromEntries(\n      Object.entries(lvHandler).map(([k, h]) => [\n        k,\n        (...args: any[]) => h(tag, ...args),\n      ]),\n    );\n  },\n\n  /**\n   * 将所有日志导出为一个字符串\n   *\n   * @example\n   * Log.dump() // => [level][time]  内容...\n   *\n   */\n  async dump() {\n    return history.reduce(\n      (acc, { lvName, timeStr, args }) =>\n        acc +\n        `[${lvName}][${timeStr}]  ${args.map((a) => any2Str(a)).join(' ')}\\n`,\n      '',\n    );\n  },\n};\n\nmap.set(Log.debug, 0);\nmap.set(Log.info, 1);\nmap.set(Log.warn, 2);\nmap.set(Log.error, 3);\n\ndeclare const PKG_VERSION: string;\n\ndeclare class PressureObserver {\n  constructor(\n    callback: (changes: PressureRecord[], observer: PressureObserver) => void,\n  );\n  observe(\n    resource: string,\n    options?: { sampleInterval?: number },\n  ): Promise<void>;\n  unobserve(): void;\n  takeRecords(): PressureRecord[];\n}\n\ninterface PressureRecord {\n  state: 'critical' | 'serious' | 'normal';\n}\n\n(async function init() {\n  await Promise.resolve();\n  if (globalThis.navigator == null || globalThis.document == null) return;\n  Log.info(\n    `@webav version: ${PKG_VERSION}, date: ${new Date().toLocaleDateString()}`,\n  );\n  Log.info(globalThis.navigator.userAgent);\n  document.addEventListener('visibilitychange', () => {\n    Log.info(`visibilitychange: ${document.visibilityState}`);\n  });\n\n  if ('PressureObserver' in globalThis) {\n    const observer = new PressureObserver((records) => {\n      Log.info(\n        `cpu state change: ${JSON.stringify(records.map((r) => r.state))}`,\n      );\n    });\n    observer.observe('cpu');\n  }\n})();\n\nif (import.meta.env?.DEV) {\n  Log.setLogLevel(Log.debug);\n}\n\nif (import.meta.env?.MODE === 'test') {\n  Log.setLogLevel(Log.warn);\n}\n","import mp4box, { MP4File, SampleOpts } from '@webav/mp4box.js';\nimport { EventTool } from './event-tool';\nimport { createMetaBox } from './meta-box';\nimport { workerTimer } from './worker-timer';\nimport { Log } from './log';\n\ntype TCleanFn = () => void;\n\n/**\n * 定义 recodemux 函数的配置选项\n */\ninterface IRecodeMuxOpts {\n  /**\n   * 视频配置选项，如果为 null 则不处理视频。\n   */\n  video: {\n    width: number;\n    height: number;\n    expectFPS: number;\n    codec: string;\n    bitrate: number;\n    /**\n     * 不安全，随时可能废弃\n     */\n    __unsafe_hardwareAcceleration__?: HardwareAcceleration;\n  } | null;\n  /**\n   * 音频配置选项，如果为 null 则不处理音频。\n   */\n  audio: {\n    codec: 'opus' | 'aac';\n    sampleRate: number;\n    channelCount: number;\n  } | null;\n  /**\n   * 预设时长，不代表 track 实际时长\n   */\n  duration?: number;\n  metaDataTags?: Record<string, string>;\n}\n\n/**\n * 处理音视频的编码和解码。\n * @param opts - 编码音视频数据的配置\n */\nexport function recodemux(opts: IRecodeMuxOpts): {\n  /**\n   * 编码视频帧\n   */\n  encodeVideo: (\n    frame: VideoFrame,\n    options: VideoEncoderEncodeOptions,\n    gopId?: number,\n  ) => void;\n  /**\n   * 编码音频数据\n   */\n  encodeAudio: (data: AudioData) => void;\n  /**\n   * close 编码器，停止任务\n   */\n  close: TCleanFn;\n  /**\n   * 清空编码器队列\n   */\n  flush: () => Promise<void>;\n  /**\n   * mp4box 实例\n   */\n  mp4file: MP4File;\n  /**\n   * 返回队列长度（背压），用于控制生产视频的进度，队列过大会会占用大量显存\n   */\n  getEncodeQueueSize: () => number;\n} {\n  Log.info('recodemux opts:', opts);\n  const mp4file = mp4box.createFile();\n\n  // 音视频轨道必须同时创建, 保存在 moov 中\n  const avSyncEvtTool = new EventTool<\n    Record<'VideoReady' | 'AudioReady', () => void>\n  >();\n\n  const addMetadata = (\n    moov: NonNullable<MP4File['moov']>,\n    tags: NonNullable<IRecodeMuxOpts['metaDataTags']>,\n  ) => {\n    const udtaBox = moov.add('udta');\n    const metaBox = udtaBox.add('meta');\n    metaBox.data = createMetaBox(tags);\n    metaBox.size = metaBox.data.byteLength;\n  };\n\n  let moovReady = false;\n  const onMoovReady = () => {\n    if (mp4file.moov == null || moovReady) return;\n    moovReady = true;\n\n    if (opts.metaDataTags != null) addMetadata(mp4file.moov, opts.metaDataTags);\n    if (opts.duration != null) {\n      mp4file.moov.mvhd.duration = opts.duration;\n    }\n  };\n\n  avSyncEvtTool.once('VideoReady', onMoovReady);\n  avSyncEvtTool.once('AudioReady', onMoovReady);\n\n  let vEncoder =\n    opts.video != null\n      ? encodeVideoTrack(opts.video, mp4file, avSyncEvtTool)\n      : null;\n  let aEncoder =\n    opts.audio != null\n      ? encodeAudioTrack(opts.audio, mp4file, avSyncEvtTool)\n      : null;\n  if (opts.video == null) avSyncEvtTool.emit('VideoReady');\n  if (opts.audio == null) avSyncEvtTool.emit('AudioReady');\n\n  return {\n    encodeVideo: (vf, opts) => {\n      vEncoder?.encode(vf, opts);\n      vf.close();\n    },\n    encodeAudio: (ad) => {\n      if (aEncoder == null) return;\n      try {\n        aEncoder.encode(ad);\n        ad.close();\n      } catch (err) {\n        const errMsg = `encode audio chunk error: ${(err as Error).message}, state: ${JSON.stringify(\n          {\n            qSize: aEncoder.encodeQueueSize,\n            state: aEncoder.state,\n          },\n        )}`;\n        Log.error(errMsg);\n        throw Error(errMsg);\n      }\n    },\n    getEncodeQueueSize: () =>\n      vEncoder?.encodeQueueSize ?? aEncoder?.encodeQueueSize ?? 0,\n    flush: async () => {\n      await Promise.all([\n        vEncoder?.flush(),\n        aEncoder?.state === 'configured' ? aEncoder.flush() : null,\n      ]);\n      return;\n    },\n    close: () => {\n      avSyncEvtTool.destroy();\n      vEncoder?.close();\n      if (aEncoder?.state === 'configured') aEncoder.close();\n    },\n    mp4file,\n  };\n}\n\nfunction encodeVideoTrack(\n  opts: NonNullable<IRecodeMuxOpts['video']>,\n  mp4File: MP4File,\n  avSyncEvtTool: EventTool<Record<'VideoReady' | 'AudioReady', () => void>>,\n) {\n  const videoTrackOpts = {\n    // 微秒\n    timescale: 1e6,\n    width: opts.width,\n    height: opts.height,\n    brands: ['isom', 'iso2', 'avc1', 'mp42', 'mp41'],\n    avcDecoderConfigRecord: null as ArrayBuffer | undefined | null,\n    name: 'Track created with WebAV',\n  };\n\n  let trackId = -1;\n  let audioReady = false;\n  avSyncEvtTool.once('AudioReady', () => {\n    audioReady = true;\n  });\n\n  const samplesCache: Record<\n    'encoder0' | 'encoder1',\n    Array<ReturnType<typeof chunk2MP4SampleOpts>>\n  > = {\n    encoder0: [],\n    encoder1: [],\n  };\n  const outputHandler = (\n    encId: 'encoder0' | 'encoder1',\n    chunk: EncodedVideoChunk,\n    meta?: EncodedVideoChunkMetadata,\n  ) => {\n    if (trackId === -1 && meta != null) {\n      const desc = meta.decoderConfig?.description as ArrayBuffer;\n      fixChromeConstraintSetFlagsBug(desc);\n      videoTrackOpts.avcDecoderConfigRecord = desc;\n      trackId = mp4File.addTrack(videoTrackOpts);\n      avSyncEvtTool.emit('VideoReady');\n      Log.info('VideoEncoder, video track ready, trackId:', trackId);\n    }\n\n    samplesCache[encId].push(chunk2MP4SampleOpts(chunk));\n  };\n\n  let curEncId: 'encoder0' | 'encoder1' = 'encoder1';\n  let lastAddedSampleTime = 0;\n  // 双编码器交替消费，保证帧的顺序\n  // 小于期望帧间隔帧判定为连续的\n  const deltaTime = Math.floor((1000 / opts.expectFPS) * 1e3);\n  function checkCache() {\n    if (!audioReady) return;\n    const nextEncId = curEncId === 'encoder1' ? 'encoder0' : 'encoder1';\n    const curCache = samplesCache[curEncId];\n    const nextCache = samplesCache[nextEncId];\n    // 无数据\n    if (curCache.length === 0 && nextCache.length === 0) return;\n\n    let curFirst = curCache[0];\n    // 当前队列正在进行中（非关键帧 或 时间连续），继续消费\n    if (curFirst != null) {\n      if (!curFirst.is_sync || curFirst.cts - lastAddedSampleTime < deltaTime) {\n        const lastTs = addSampleToFile(curCache);\n        if (lastTs > lastAddedSampleTime) lastAddedSampleTime = lastTs;\n      }\n    }\n\n    const nextFirst = nextCache[0];\n\n    // 另一个队列跟已消费的最后一帧是连续的，则需要切换\n    if (nextFirst?.is_sync && nextFirst.cts - lastAddedSampleTime < deltaTime) {\n      curEncId = nextEncId;\n      // 说明另一个队列有数据，尽快消费\n      checkCache();\n      return;\n    }\n\n    // 如果时间不连续，但两个队列都有数据，且都是关键帧，消费时间较早的队列\n    if (curFirst?.is_sync && nextFirst?.is_sync) {\n      if (curFirst.cts <= nextFirst.cts) {\n        const lastTs = addSampleToFile(curCache);\n        if (lastTs > lastAddedSampleTime) lastAddedSampleTime = lastTs;\n      } else {\n        curEncId = nextEncId;\n        // 说明另一个队列有数据，尽快消费\n        checkCache();\n        return;\n      }\n    }\n  }\n\n  function addSampleToFile(\n    chunks: Array<ReturnType<typeof chunk2MP4SampleOpts>>,\n  ) {\n    let lastTime = -1;\n    let i = 0;\n    for (; i < chunks.length; i++) {\n      const c = chunks[i];\n      // 每次消费到下一个关键帧结束，可能需要切换队列\n      if (i > 0 && c.is_sync) break;\n\n      mp4File.addSample(trackId, c.data, c);\n      lastTime = c.cts + c.duration;\n    }\n    chunks.splice(0, i);\n    return lastTime;\n  }\n\n  const stopTimer = workerTimer(checkCache, 15);\n\n  const encoder0 = createVideoEncoder(opts, (chunk, meta) =>\n    outputHandler('encoder0', chunk, meta),\n  );\n  const encoder1 = createVideoEncoder(opts, (chunk, meta) =>\n    outputHandler('encoder1', chunk, meta),\n  );\n\n  let gopId = 0;\n  return {\n    get encodeQueueSize() {\n      return encoder0.encodeQueueSize + encoder1.encodeQueueSize;\n    },\n    encode: (vf: VideoFrame, opts: VideoEncoderEncodeOptions) => {\n      try {\n        if (opts.keyFrame) gopId += 1;\n        const encoder = gopId % 2 === 0 ? encoder0 : encoder1;\n        encoder.encode(vf, opts);\n      } catch (err) {\n        const errMsg = `encode video frame error: ${(err as Error).message}, state: ${JSON.stringify(\n          {\n            ts: vf.timestamp,\n            keyFrame: opts.keyFrame,\n            duration: vf.duration,\n            gopId,\n          },\n        )}`;\n        Log.error(errMsg);\n        throw Error(errMsg);\n      }\n    },\n    flush: async () => {\n      await Promise.all([\n        encoder0.state === 'configured' ? await encoder0.flush() : null,\n        encoder1.state === 'configured' ? await encoder1.flush() : null,\n      ]);\n      stopTimer();\n      checkCache();\n    },\n    close: () => {\n      if (encoder0.state === 'configured') encoder0.close();\n      if (encoder1.state === 'configured') encoder1.close();\n    },\n  };\n}\n\n// https://github.com/WebAV-Tech/WebAV/issues/203\nfunction fixChromeConstraintSetFlagsBug(desc: ArrayBuffer) {\n  const u8 = new Uint8Array(desc);\n  const constraintSetFlag = u8[2];\n  // 如果 constraint_set_flags 字节二进制 第0位或第1位值为1\n  // 说明取值错误，忽略该字段避免解码异常\n  if (constraintSetFlag.toString(2).slice(-2).includes('1')) {\n    u8[2] = 0;\n  }\n}\n\nfunction createVideoEncoder(\n  videoOpts: NonNullable<IRecodeMuxOpts['video']>,\n  outHandler: EncodedVideoChunkOutputCallback,\n): VideoEncoder {\n  const encoderConf = {\n    codec: videoOpts.codec,\n    framerate: videoOpts.expectFPS,\n    hardwareAcceleration: videoOpts.__unsafe_hardwareAcceleration__,\n    // 码率\n    bitrate: videoOpts.bitrate,\n    width: videoOpts.width,\n    height: videoOpts.height,\n    // H264 不支持背景透明度\n    alpha: 'discard',\n    // macos 自带播放器只支持avc\n    avc: { format: 'avc' },\n    // mp4box.js 无法解析 annexb 的 mimeCodec ，只会显示 avc1\n    // avc: { format: 'annexb' }\n  } as const;\n  const encoder = new VideoEncoder({\n    error: (err) => {\n      const errMsg = `VideoEncoder error: ${err.message}, config: ${JSON.stringify(encoderConf)}, state: ${JSON.stringify(\n        {\n          qSize: encoder.encodeQueueSize,\n          state: encoder.state,\n        },\n      )}`;\n      Log.error(errMsg);\n      throw Error(errMsg);\n    },\n    output: outHandler,\n  });\n\n  encoder.configure(encoderConf);\n  return encoder;\n}\n\nfunction encodeAudioTrack(\n  audioOpts: NonNullable<IRecodeMuxOpts['audio']>,\n  mp4File: MP4File,\n  avSyncEvtTool: EventTool<Record<'VideoReady' | 'AudioReady', () => void>>,\n): AudioEncoder {\n  const audioTrackOpts = {\n    timescale: 1e6,\n    samplerate: audioOpts.sampleRate,\n    channel_count: audioOpts.channelCount,\n    hdlr: 'soun',\n    type: audioOpts.codec === 'aac' ? 'mp4a' : 'Opus',\n    name: 'Track created with WebAV',\n  };\n\n  let trackId = -1;\n  let cache: EncodedAudioChunk[] = [];\n  let videoReady = false;\n  avSyncEvtTool.once('VideoReady', () => {\n    videoReady = true;\n    cache.forEach((c) => {\n      const s = chunk2MP4SampleOpts(c);\n      mp4File.addSample(trackId, s.data, s);\n    });\n    cache = [];\n  });\n\n  const encoderConf = {\n    codec: audioOpts.codec === 'aac' ? 'mp4a.40.2' : 'opus',\n    sampleRate: audioOpts.sampleRate,\n    numberOfChannels: audioOpts.channelCount,\n    bitrate: 128_000,\n  } as const;\n\n  const encoder = new AudioEncoder({\n    error: (err) => {\n      const errMsg = `AudioEncoder error: ${err.message}, config: ${JSON.stringify(\n        encoderConf,\n      )}, state: ${JSON.stringify({\n        qSize: encoder.encodeQueueSize,\n        state: encoder.state,\n      })}`;\n      Log.error(errMsg);\n      throw Error(errMsg);\n    },\n    output: (chunk, meta) => {\n      if (trackId === -1) {\n        // 某些设备不会输出 description\n        const desc = meta.decoderConfig?.description;\n        trackId = mp4File.addTrack({\n          ...audioTrackOpts,\n          description: desc == null ? undefined : createESDSBox(desc),\n        });\n        avSyncEvtTool.emit('AudioReady');\n        Log.info('AudioEncoder, audio track ready, trackId:', trackId);\n      }\n\n      if (videoReady) {\n        const s = chunk2MP4SampleOpts(chunk);\n        mp4File.addSample(trackId, s.data, s);\n      } else {\n        cache.push(chunk);\n      }\n    },\n  });\n  encoder.configure(encoderConf);\n\n  return encoder;\n}\n\n/**\n * 创建 ESDS 盒子（MPEG-4 Elementary Stream Descriptor）\n * ESDS 盒子用于描述 MPEG-4 的流信息，如编解码器类型、流类型、最大比特率、平均比特率等\n * @param config - 配置信息，可以是 `ArrayBuffer` 或 `ArrayBufferView` 类型\n * @return 返回一个 ESDS box\n */\nfunction createESDSBox(config: ArrayBuffer | ArrayBufferView) {\n  const configlen = config.byteLength;\n  const buf = new Uint8Array([\n    0x00, // version 0\n    0x00,\n    0x00,\n    0x00, // flags\n\n    0x03, // descriptor_type\n    0x17 + configlen, // length\n    0x00,\n    // 0x01, // es_id\n    0x02, // es_id\n    0x00, // stream_priority\n\n    0x04, // descriptor_type\n    0x12 + configlen, // length\n    0x40, // codec : mpeg4_audio\n    0x15, // stream_type\n    0x00,\n    0x00,\n    0x00, // buffer_size\n    0x00,\n    0x00,\n    0x00,\n    0x00, // maxBitrate\n    0x00,\n    0x00,\n    0x00,\n    0x00, // avgBitrate\n\n    0x05, // descriptor_type\n\n    configlen,\n    ...new Uint8Array(config instanceof ArrayBuffer ? config : config.buffer),\n\n    0x06,\n    0x01,\n    0x02,\n  ]);\n\n  const esdsBox = new mp4box.BoxParser.esdsBox(buf.byteLength);\n  esdsBox.hdr_size = 0;\n  esdsBox.parse(new mp4box.DataStream(buf, 0, mp4box.DataStream.BIG_ENDIAN));\n  return esdsBox;\n}\n\n/**\n * EncodedAudioChunk | EncodedVideoChunk 转换为 MP4 addSample 需要的参数\n */\nfunction chunk2MP4SampleOpts(\n  chunk: EncodedAudioChunk | EncodedVideoChunk,\n): SampleOpts & {\n  data: ArrayBuffer;\n} {\n  const buf = new ArrayBuffer(chunk.byteLength);\n  chunk.copyTo(buf);\n  const dts = chunk.timestamp;\n  return {\n    duration: chunk.duration ?? 0,\n    dts,\n    cts: dts,\n    is_sync: chunk.type === 'key',\n    data: buf,\n  };\n}\n"],"names":["EventTool","__privateAdd","_listeners","__publicField","type","listener","handlers","__privateGet","off","args","handler","from","to","evtTypes","removeHandlers","evtType","fromEvtType","toEvtType","fn","setup","timerId","interval","e","createWorker","blob","url","handlerMap","runCount","worker","k","v","workerTimer","time","groupId","fns","autoReadStream","stream","cbs","stoped","run","reader","value","done","file2stream","file","timeSlice","onCancel","sendedBoxIdx","boxes","firstMoofReady","deltaBuf","box","ds","mp4box","i","err","errBox","_a","unsafeReleaseMP4BoxFile","canceled","exit","ctrl","d","j","createBoxHeader","size","buffer","createHdlrBox","tec","handlerType","nameBytes","view","createKeysBox","keys","keyNamespace","keyData","key","keyBuf","entryBuf","acc","cur","offset","createIlstBox","data","dataStrBuf","valueData","_","index","keyId","valueBytes","entrySize","totalSizwe","entry","createMetaBox","hdlrBox","keysBox","ilstBox","any2Str","val","getTimeStr","THRESHOLD","history","lvHandler","lvName","lvThres","map","Log","logfn","tag","h","timeStr","a","records","recodemux","opts","mp4file","avSyncEvtTool","addMetadata","moov","tags","metaBox","moovReady","onMoovReady","vEncoder","encodeVideoTrack","aEncoder","encodeAudioTrack","vf","ad","errMsg","mp4File","videoTrackOpts","trackId","audioReady","samplesCache","outputHandler","encId","chunk","meta","desc","fixChromeConstraintSetFlagsBug","chunk2MP4SampleOpts","curEncId","lastAddedSampleTime","deltaTime","checkCache","nextEncId","curCache","nextCache","curFirst","lastTs","addSampleToFile","nextFirst","chunks","lastTime","c","stopTimer","encoder0","createVideoEncoder","encoder1","gopId","u8","videoOpts","outHandler","encoderConf","encoder","audioOpts","audioTrackOpts","cache","videoReady","s","createESDSBox","config","configlen","buf","esdsBox","dts"],"mappings":"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"}