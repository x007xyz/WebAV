{"version":3,"file":"av-cliper.js","sources":["../src/dom-utils.ts","../src/av-utils.ts","../src/clips/iclip.ts","../src/mp4-utils/mp4box-utils.ts","../src/clips/mp4-clip.ts","../src/clips/img-clip.ts","../src/clips/audio-clip.ts","../src/clips/media-stream-clip.ts","../src/clips/embed-subtitles-clip.ts","../src/mp4-utils/sample-transform.ts","../src/mp4-utils/index.ts","../src/chromakey.ts","../src/sprite/rect.ts","../src/sprite/base-sprite.ts","../src/sprite/offscreen-sprite.ts","../src/sprite/visible-sprite.ts","../src/combinator.ts"],"sourcesContent":["// 在主线程中执行的 工具函数\n\n/**\n * 创建一个新的 HTML 元素\n * @param tagName - 要创建的元素的标签名\n * @returns 新创建的 HTML 元素\n */\nexport function createEl(tagName: string): HTMLElement {\n  return document.createElement(tagName);\n}\n\n/**\n * 将文本渲染为图片\n * @param txt - 要渲染的文本\n * @param cssText - 应用于文本的 CSS 样式\n * @returns 渲染后的图片元素\n */\nexport function renderTxt2Img(txt: string, cssText: string): HTMLImageElement {\n  const div = createEl('pre');\n  div.style.cssText = `margin: 0; ${cssText}; visibility: hidden; position: fixed;`;\n  div.textContent = txt;\n  document.body.appendChild(div);\n\n  const { width, height } = div.getBoundingClientRect();\n  // 计算出 rect，立即从dom移除\n  div.remove();\n  div.style.visibility = 'visible';\n\n  const img = new Image();\n  img.width = width;\n  img.height = height;\n  const svgStr = `\n    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\">\n    <foreignObject width=\"100%\" height=\"100%\">\n        <div xmlns=\"http://www.w3.org/1999/xhtml\">${div.outerHTML}</div>\n    </foreignObject>\n    </svg>\n  `\n    .replace(/\\t/g, '')\n    .replace(/#/g, '%23');\n\n  img.src = `data:image/svg+xml;charset=utf-8,${svgStr}`;\n  return img;\n}\n\n/**\n * 将文本渲染为 {@link ImageBitmap}，用来创建 {@link ImgClip}\n * @param txt - 要渲染的文本\n * @param cssText - 应用于文本的 CSS 样式\n *\n * @example\n * new ImgClip(\n *   await renderTxt2ImgBitmap(\n *     '水印',\n *    `font-size:40px; color: white; text-shadow: 2px 2px 6px red;`,\n *   )\n * )\n */\nexport async function renderTxt2ImgBitmap(\n  txt: string,\n  cssText: string,\n): Promise<ImageBitmap> {\n  const imgEl = renderTxt2Img(txt, cssText);\n  await new Promise((resolve) => {\n    imgEl.onload = resolve;\n  });\n  const cvs = new OffscreenCanvas(imgEl.width, imgEl.height);\n  const ctx = cvs.getContext('2d');\n  ctx?.drawImage(imgEl, 0, 0, imgEl.width, imgEl.height);\n  return await createImageBitmap(cvs);\n}\n","// 能同时在 worker 和主线程中运行的工具函数\n\nimport { workerTimer } from '@webav/internal-utils';\nimport * as waveResampler from 'wave-resampler';\n\n/**\n * 合并（串联）多个 Float32Array，通常用于合并 PCM 数据\n */\nexport function concatFloat32Array(bufs: Float32Array[]): Float32Array {\n  const rs = new Float32Array(\n    bufs.map((buf) => buf.length).reduce((a, b) => a + b),\n  );\n\n  let offset = 0;\n  for (const buf of bufs) {\n    rs.set(buf, offset);\n    offset += buf.length;\n  }\n\n  return rs;\n}\n\n/**\n * 将小片段的 PCM 合并成一个大片段\n * @param fragments 小片段 PCM，子元素是不同声道的原始 PCM 数据\n */\nexport function concatPCMFragments(\n  fragments: Float32Array[][],\n): Float32Array[] {\n  // fragments: [[chan0, chan1], [chan0, chan1]...]\n  // chanListPCM: [[chan0, chan0...], [chan1, chan1...]]\n  const chanListPCM: Float32Array[][] = [];\n  for (let i = 0; i < fragments.length; i += 1) {\n    for (let j = 0; j < fragments[i].length; j += 1) {\n      if (chanListPCM[j] == null) chanListPCM[j] = [];\n      chanListPCM[j].push(fragments[i][j]);\n    }\n  }\n  // [bigChan0, bigChan1]\n  return chanListPCM.map(concatFloat32Array);\n}\n\n/**\n * 从 AudioData 中提取 PCM 数据的工具函数\n */\nexport function extractPCM4AudioData(ad: AudioData): Float32Array[] {\n  if (ad.format === 'f32-planar') {\n    const rs = [];\n    for (let idx = 0; idx < ad.numberOfChannels; idx += 1) {\n      const chanBufSize = ad.allocationSize({ planeIndex: idx });\n      const chanBuf = new ArrayBuffer(chanBufSize);\n      ad.copyTo(chanBuf, { planeIndex: idx });\n      rs.push(new Float32Array(chanBuf));\n    }\n    return rs;\n  } else if (ad.format === 'f32') {\n    const buf = new ArrayBuffer(ad.allocationSize({ planeIndex: 0 }));\n    ad.copyTo(buf, { planeIndex: 0 });\n    return convertF32ToPlanar(new Float32Array(buf), ad.numberOfChannels);\n  } else if (ad.format === 's16') {\n    const buf = new ArrayBuffer(ad.allocationSize({ planeIndex: 0 }));\n    ad.copyTo(buf, { planeIndex: 0 });\n    return convertS16ToF32Planar(new Int16Array(buf), ad.numberOfChannels);\n  }\n  throw Error('Unsupported audio data format');\n}\n\n/**\n * Convert s16 PCM to f32-planar\n * @param  pcmS16Data - The s16 PCM data.\n * @param  numChannels - Number of audio channels.\n * @returns An array of Float32Array, each containing the audio data for one channel.\n */\nfunction convertS16ToF32Planar(pcmS16Data: Int16Array, numChannels: number) {\n  const numSamples = pcmS16Data.length / numChannels;\n  const planarData = Array.from(\n    { length: numChannels },\n    () => new Float32Array(numSamples),\n  );\n\n  for (let i = 0; i < numSamples; i++) {\n    for (let channel = 0; channel < numChannels; channel++) {\n      const sample = pcmS16Data[i * numChannels + channel];\n      planarData[channel][i] = sample / 32768; // Normalize to range [-1.0, 1.0]\n    }\n  }\n\n  return planarData;\n}\n\nfunction convertF32ToPlanar(pcmF32Data: Float32Array, numChannels: number) {\n  const numSamples = pcmF32Data.length / numChannels;\n  const planarData = Array.from(\n    { length: numChannels },\n    () => new Float32Array(numSamples),\n  );\n\n  for (let i = 0; i < numSamples; i++) {\n    for (let channel = 0; channel < numChannels; channel++) {\n      planarData[channel][i] = pcmF32Data[i * numChannels + channel];\n    }\n  }\n\n  return planarData;\n}\n\n/**\n * 从 AudioBuffer 中提取 PCM\n */\nexport function extractPCM4AudioBuffer(ab: AudioBuffer): Float32Array[] {\n  return Array(ab.numberOfChannels)\n    .fill(0)\n    .map((_, idx) => {\n      return ab.getChannelData(idx);\n    });\n}\n\n/**\n * 调整音频数据的音量\n * @param ad - 要调整的音频对象\n * @param volume - 音量调整系数（0.0 - 1.0）\n * @returns 调整音量后的新音频数据\n */\nexport function adjustAudioDataVolume(ad: AudioData, volume: number) {\n  const data = new Float32Array(\n    concatFloat32Array(extractPCM4AudioData(ad)),\n  ).map((v) => v * volume);\n  const newAd = new AudioData({\n    sampleRate: ad.sampleRate,\n    numberOfChannels: ad.numberOfChannels,\n    timestamp: ad.timestamp,\n    format: ad.format,\n    numberOfFrames: ad.numberOfFrames,\n    data,\n  });\n  ad.close();\n  return newAd;\n}\n\n/**\n * 解码图像流，返回一个视频帧数组。\n *\n * @param stream - 包含图像数据的可读流。\n * @param type - 图像的 MIME 类型，例如 'image/jpeg'。\n *\n * @returns 返回一个 Promise，该 Promise 在解码完成后解析为 {@link VideoFrame} 数组。\n *\n * @see [解码动图](https://webav-tech.github.io/WebAV/demo/1_3-decode-image)\n *\n * @example\n *\n * const frames = await decodeImg(\n *   (await fetch('<gif url>')).body!,\n *   `image/gif`,\n * );\n */\nexport async function decodeImg(\n  stream: ReadableStream<Uint8Array>,\n  type: string,\n): Promise<VideoFrame[]> {\n  const init = {\n    type,\n    data: stream,\n  };\n  const imageDecoder = new ImageDecoder(init);\n\n  await Promise.all([imageDecoder.completed, imageDecoder.tracks.ready]);\n\n  let frameCnt = imageDecoder.tracks.selectedTrack?.frameCount ?? 1;\n\n  const rs: VideoFrame[] = [];\n  for (let i = 0; i < frameCnt; i += 1) {\n    rs.push((await imageDecoder.decode({ frameIndex: i })).image);\n  }\n  return rs;\n}\n\n/**\n * 混合双通道音轨的 PCM 数据，并将多声道并排成一个 Float32Array 输出\n * @param audios - 一个二维数组，每个元素是一个 Float32Array 数组，代表一个音频流的 PCM 数据。\n * 每个 Float32Array 数组的第一个元素是左声道数据，第二个元素（如果有）是右声道数据。\n * 如果只有左声道数据，则右声道将复用左声道数据。\n *\n * @returns 返回一个 Float32Array，返回结果是将这个一个音轨的左右声道并排成 Float32Array。\n *\n * @example\n *\n * const audios = [\n *   [new Float32Array([0.1, 0.2, 0.3]), new Float32Array([0.4, 0.5, 0.6])],\n *   [new Float32Array([0.7, 0.8, 0.9])],\n * ];\n * const mixed = mixinPCM(audios);\n */\nexport function mixinPCM(audios: Float32Array[][]): Float32Array {\n  const maxLen = Math.max(...audios.map((a) => a[0]?.length ?? 0));\n  const data = new Float32Array(maxLen * 2);\n\n  for (let bufIdx = 0; bufIdx < maxLen; bufIdx++) {\n    let chan0 = 0;\n    let chan1 = 0;\n    for (let trackIdx = 0; trackIdx < audios.length; trackIdx++) {\n      const _c0 = audios[trackIdx][0]?.[bufIdx] ?? 0;\n      // 如果是单声道 PCM，第二声道复用第一声道数据\n      const _c1 = audios[trackIdx][1]?.[bufIdx] ?? _c0;\n      chan0 += _c0;\n      chan1 += _c1;\n    }\n    data[bufIdx] = chan0;\n    data[bufIdx + maxLen] = chan1;\n  }\n\n  return data;\n}\n\n/**\n * 对 PCM 音频数据进行重采样。\n *\n * @param pcmData - 一个 Float32Array 数组，每个元素代表一个声道的 PCM 数据。\n * @param curRate - 当前的采样率。\n * @param target - 目标参数对象。\n * @param target.rate - 目标采样率。\n * @param target.chanCount - 目标声道数。\n *\n * @returns 返回一个 Promise，该 Promise 在重采样完成后解析为一个 Float32Array 数组，每个元素代表一个声道的 PCM 数据。\n *\n * @example\n *\n * const pcmData = [new Float32Array([0.1, 0.2, 0.3]), new Float32Array([0.4, 0.5, 0.6])];\n * const curRate = 44100;\n * const target = { rate: 48000, chanCount: 2 };\n * const resampled = await audioResample(pcmData, curRate, target);\n */\nexport async function audioResample(\n  pcmData: Float32Array[],\n  curRate: number,\n  target: {\n    rate: number;\n    chanCount: number;\n  },\n): Promise<Float32Array[]> {\n  const chanCnt = pcmData.length;\n  const emptyPCM = Array(target.chanCount)\n    .fill(0)\n    .map(() => new Float32Array(0));\n  if (chanCnt === 0) return emptyPCM;\n\n  const len = Math.max(...pcmData.map((c) => c.length));\n  if (len === 0) return emptyPCM;\n\n  // The Worker scope does not have access to OfflineAudioContext\n  if (globalThis.OfflineAudioContext == null) {\n    return pcmData.map(\n      (p) =>\n        new Float32Array(\n          waveResampler.resample(p, curRate, target.rate, {\n            method: 'sinc',\n            LPF: false,\n          }),\n        ),\n    );\n  }\n\n  const ctx = new globalThis.OfflineAudioContext(\n    target.chanCount,\n    (len * target.rate) / curRate,\n    target.rate,\n  );\n  const abSource = ctx.createBufferSource();\n  const ab = ctx.createBuffer(chanCnt, len, curRate);\n  pcmData.forEach((d, idx) => ab.copyToChannel(d, idx));\n\n  abSource.buffer = ab;\n  abSource.connect(ctx.destination);\n  abSource.start();\n\n  return extractPCM4AudioBuffer(await ctx.startRendering());\n}\n\n/**\n * 使当前执行环境暂停一段时间。\n * @param time - 暂停的时间，单位为毫秒。\n * @example\n * await sleep(1000);  // 暂停 1 秒\n */\nexport function sleep(time: number): Promise<void> {\n  return new Promise((resolve) => {\n    const stop = workerTimer(() => {\n      stop();\n      resolve();\n    }, time);\n  });\n}\n\n/**\n * 从给定的 Float32Array 中提取一个环形切片，超出边界从 0 开始循环\n *\n * 主要用于截取 PCM 实现循环播放\n *\n * @param data - 输入的 Float32Array。\n * @param start - 切片的开始索引。\n * @param end - 切片的结束索引。\n * @returns - 返回一个新的 Float32Array，包含从 start 到 end 的数据。\n *\n * @example\n * const data = new Float32Array([0, 1, 2, 3, 4, 5]);\n * ringSliceFloat32Array(data, 4, 6); // => Float32Array [4, 5, 0]\n */\nexport function ringSliceFloat32Array(\n  data: Float32Array,\n  start: number,\n  end: number,\n): Float32Array {\n  const cnt = end - start;\n  const rs = new Float32Array(cnt);\n  let i = 0;\n  while (i < cnt) {\n    rs[i] = data[(start + i) % data.length];\n    i += 1;\n  }\n  return rs;\n}\n\n/**\n * 函数节流\n */\nexport function throttle<F extends (...args: any[]) => any>(\n  func: F,\n  wait: number,\n): (...rest: Parameters<F>) => undefined | ReturnType<F> {\n  let lastTime: number;\n  return function (this: any, ...rest) {\n    if (lastTime == null || performance.now() - lastTime > wait) {\n      lastTime = performance.now();\n      return func.apply(this, rest);\n    }\n  };\n}\n\n/**\n * 改变 PCM 数据的播放速率，1 表示正常播放，0.5 表示播放速率减半，2 表示播放速率加倍\n */\nexport function changePCMPlaybackRate(\n  pcmData: Float32Array,\n  playbackRate: number,\n) {\n  // 计算新的采样率\n  const newLength = Math.floor(pcmData.length / playbackRate);\n  const newPcmData = new Float32Array(newLength);\n\n  // 线性插值\n  for (let i = 0; i < newLength; i++) {\n    // 原始数据中的位置\n    const originalIndex = i * playbackRate;\n    const intIndex = Math.floor(originalIndex);\n    const frac = originalIndex - intIndex;\n\n    // 边界检查\n    if (intIndex + 1 < pcmData.length) {\n      newPcmData[i] =\n        pcmData[intIndex] * (1 - frac) + pcmData[intIndex + 1] * frac;\n    } else {\n      newPcmData[i] = pcmData[intIndex]; // 最后一个样本\n    }\n  }\n\n  return newPcmData;\n}\n","interface IClipMeta {\n  width: number;\n  height: number;\n  duration: number;\n}\n\n/**\n * 所有素材需要实现的接口\n *\n * 素材（Clip）是不同数据类型的抽象，给其他模块提供数据\n *\n * WebAV 内置了 {@link MP4Clip}, {@link AudioClip}, {@link ImgClip}, {@link MediaStreamClip} 等常用素材，用于给 {@link Combinator} {@link AVCanvas} 提供数据\n *\n * 你只需实现该接口即可自定义素材，拥有最大的灵活度来生成视频内容，比如动画、转场效果等\n * @see [自定义素材](https://webav-tech.github.io/WebAV/demo/2_6-custom-clip)\n *\n */\nexport interface IClip {\n  /**\n   * 从素材中提取指定时间数据\n   * @param time 时间，单位 微秒\n   */\n  tick: (time: number) => Promise<{\n    video?: VideoFrame | ImageBitmap | null;\n    audio?: Float32Array[];\n    state: 'done' | 'success';\n  }>;\n\n  /**\n   * 当素材准备完成，ready 会切换到 resolved 状态\n   */\n  readonly ready: Promise<IClipMeta>;\n\n  /**\n   * 数据元数据\n   */\n  readonly meta: IClipMeta;\n\n  /**\n   * clone，返回一个新素材\n   */\n  clone: () => Promise<this>;\n\n  /**\n   * 按指定时间切割，返回该时刻前后两个新素材，常用于剪辑场景按时间分割素材\n   *\n   * 该方法不会破坏原素材的数据\n   *\n   * @param time 时间，微秒\n   * @returns\n   */\n  split?: (time: number) => Promise<[this, this]>;\n\n  /**\n   * 销毁实例，释放资源\n   */\n  destroy: () => void;\n}\n\n/**\n * 默认的音频设置，⚠️ 不要变更它的值 ⚠️\n */\nexport const DEFAULT_AUDIO_CONF = {\n  sampleRate: 48000,\n  channelCount: 2,\n  codec: 'mp4a.40.2',\n} as const;\n","import mp4box, {\n  AudioTrackOpts,\n  ESDSBoxParser,\n  MP4ABoxParser,\n  MP4ArrayBuffer,\n  MP4File,\n  MP4Info,\n  MP4Sample,\n  TrakBoxParser,\n  VideoTrackOpts,\n} from '@webav/mp4box.js';\nimport { DEFAULT_AUDIO_CONF } from '../clips';\nimport { file } from 'opfs-tools';\n\nexport function extractFileConfig(file: MP4File, info: MP4Info) {\n  const vTrack = info.videoTracks[0];\n  const rs: {\n    videoTrackConf?: VideoTrackOpts;\n    videoDecoderConf?: Parameters<VideoDecoder['configure']>[0];\n    audioTrackConf?: AudioTrackOpts;\n    audioDecoderConf?: Parameters<AudioDecoder['configure']>[0];\n  } = {};\n  if (vTrack != null) {\n    const videoDesc = parseVideoCodecDesc(file.getTrackById(vTrack.id)).buffer;\n    const { descKey, type } = vTrack.codec.startsWith('avc1')\n      ? { descKey: 'avcDecoderConfigRecord', type: 'avc1' }\n      : vTrack.codec.startsWith('hvc1')\n        ? { descKey: 'hevcDecoderConfigRecord', type: 'hvc1' }\n        : { descKey: '', type: '' };\n    if (descKey !== '') {\n      rs.videoTrackConf = {\n        timescale: vTrack.timescale,\n        duration: vTrack.duration,\n        width: vTrack.video.width,\n        height: vTrack.video.height,\n        brands: info.brands,\n        type,\n        [descKey]: videoDesc,\n      };\n    }\n\n    rs.videoDecoderConf = {\n      codec: vTrack.codec,\n      codedHeight: vTrack.video.height,\n      codedWidth: vTrack.video.width,\n      description: videoDesc,\n    };\n  }\n\n  const aTrack = info.audioTracks[0];\n  if (aTrack != null) {\n    const esdsBox = getESDSBoxFromMP4File(file);\n    rs.audioTrackConf = {\n      timescale: aTrack.timescale,\n      samplerate: aTrack.audio.sample_rate,\n      channel_count: aTrack.audio.channel_count,\n      hdlr: 'soun',\n      type: aTrack.codec.startsWith('mp4a') ? 'mp4a' : aTrack.codec,\n      description: getESDSBoxFromMP4File(file),\n    };\n    rs.audioDecoderConf = {\n      codec: aTrack.codec.startsWith('mp4a')\n        ? DEFAULT_AUDIO_CONF.codec\n        : aTrack.codec,\n      numberOfChannels: aTrack.audio.channel_count,\n      sampleRate: aTrack.audio.sample_rate,\n      ...(esdsBox == null ? {} : parseAudioInfo4ESDSBox(esdsBox)),\n    };\n  }\n  return rs;\n}\n\n// track is H.264, H.265 or VPX.\nfunction parseVideoCodecDesc(track: TrakBoxParser): Uint8Array {\n  for (const entry of track.mdia.minf.stbl.stsd.entries) {\n    // @ts-expect-error\n    const box = entry.avcC ?? entry.hvcC ?? entry.av1C ?? entry.vpcC;\n    if (box != null) {\n      const stream = new mp4box.DataStream(\n        undefined,\n        0,\n        mp4box.DataStream.BIG_ENDIAN,\n      );\n      box.write(stream);\n      return new Uint8Array(stream.buffer.slice(8)); // Remove the box header.\n    }\n  }\n  throw Error('avcC, hvcC, av1C or VPX not found');\n}\n\nfunction getESDSBoxFromMP4File(file: MP4File, codec = 'mp4a') {\n  const mp4aBox = file.moov?.traks\n    .map((t) => t.mdia.minf.stbl.stsd.entries)\n    .flat()\n    .find(({ type }) => type === codec) as MP4ABoxParser;\n\n  return mp4aBox?.esds;\n}\n\n// 解决封装层音频信息标识错误，导致解码异常\nfunction parseAudioInfo4ESDSBox(esds: ESDSBoxParser) {\n  const decoderConf = esds.esd.descs[0]?.descs[0];\n  if (decoderConf == null) return {};\n\n  const [byte1, byte2] = decoderConf.data;\n  // sampleRate 是第一字节后 3bit + 第二字节前 1bit\n  const sampleRateIdx = ((byte1 & 0x07) << 1) + (byte2 >> 7);\n  // numberOfChannels 是第二字节 [2, 5] 4bit\n  const numberOfChannels = (byte2 & 0x7f) >> 3;\n  const sampleRateEnum = [\n    96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025,\n    8000, 7350,\n  ] as const;\n  return {\n    sampleRate: sampleRateEnum[sampleRateIdx],\n    numberOfChannels,\n  };\n}\n\n/**\n * 快速解析 mp4 文件，如果是非 fMP4 格式，会优先解析 moov box（略过 mdat）避免占用过多内存\n */\nexport async function quickParseMP4File(\n  reader: Awaited<ReturnType<ReturnType<typeof file>['createReader']>>,\n  onReady: (data: { mp4boxFile: MP4File; info: MP4Info }) => void,\n  onSamples: (\n    id: number,\n    sampleType: 'video' | 'audio',\n    samples: MP4Sample[],\n  ) => void,\n) {\n  const mp4boxFile = mp4box.createFile(false);\n  mp4boxFile.onReady = (info) => {\n    onReady({ mp4boxFile, info });\n    const vTrackId = info.videoTracks[0]?.id;\n    if (vTrackId != null)\n      mp4boxFile.setExtractionOptions(vTrackId, 'video', { nbSamples: 100 });\n\n    const aTrackId = info.audioTracks[0]?.id;\n    if (aTrackId != null)\n      mp4boxFile.setExtractionOptions(aTrackId, 'audio', { nbSamples: 100 });\n\n    mp4boxFile.start();\n  };\n  mp4boxFile.onSamples = onSamples;\n\n  await parse();\n\n  async function parse() {\n    let cursor = 0;\n    const maxReadSize = 30 * 1024 * 1024;\n    while (true) {\n      const data = (await reader.read(maxReadSize, {\n        at: cursor,\n      })) as MP4ArrayBuffer;\n      if (data.byteLength === 0) break;\n      data.fileStart = cursor;\n      const nextPos = mp4boxFile.appendBuffer(data);\n      if (nextPos == null) break;\n      cursor = nextPos;\n    }\n\n    mp4boxFile.stop();\n  }\n}\n","import { MP4Info, MP4Sample } from '@webav/mp4box.js';\nimport { audioResample, extractPCM4AudioData, sleep } from '../av-utils';\nimport { Log } from '@webav/internal-utils';\nimport {\n  extractFileConfig,\n  quickParseMP4File,\n} from '../mp4-utils/mp4box-utils';\nimport { DEFAULT_AUDIO_CONF, IClip } from './iclip';\nimport { file, tmpfile, write } from 'opfs-tools';\n\nlet CLIP_ID = 0;\n\ntype OPFSToolFile = ReturnType<typeof file>;\nfunction isOTFile(obj: any): obj is OPFSToolFile {\n  return obj.kind === 'file' && obj.createReader instanceof Function;\n}\n\n// 用于内部创建 MP4Clip 实例\ntype MPClipCloneArgs = Awaited<ReturnType<typeof mp4FileToSamples>> & {\n  localFile: OPFSToolFile;\n};\n\ninterface MP4DecoderConf {\n  video: VideoDecoderConfig | null;\n  audio: AudioDecoderConfig | null;\n}\n\ninterface MP4ClipOpts {\n  audio?: boolean | { volume: number };\n  /**\n   * 不安全，随时可能废弃\n   */\n  __unsafe_hardwareAcceleration__?: HardwarePreference;\n}\n\ntype ExtMP4Sample = Omit<MP4Sample, 'data'> & {\n  is_idr: boolean;\n  deleted?: boolean;\n  data: null | Uint8Array;\n};\n\ntype LocalFileReader = Awaited<ReturnType<OPFSToolFile['createReader']>>;\n\ntype ThumbnailOpts = {\n  start: number;\n  end: number;\n  step: number;\n};\n\n/**\n * MP4 素材，解析 MP4 文件，使用 {@link MP4Clip.tick} 按需解码指定时间的图像帧\n *\n * 可用于实现视频抽帧、生成缩略图、视频编辑等功能\n *\n * @example\n * new MP4Clip((await fetch('<mp4 url>')).body)\n * new MP4Clip(mp4File.stream())\n *\n * @see {@link Combinator}\n * @see [AVCanvas](../../av-canvas/classes/AVCanvas.html)\n *\n * @see [解码播放视频](https://webav-tech.github.io/WebAV/demo/1_1-decode-video)\n */\nexport class MP4Clip implements IClip {\n  #insId = CLIP_ID++;\n\n  #log = Log.create(`MP4Clip id:${this.#insId},`);\n\n  ready: IClip['ready'];\n\n  #destroyed = false;\n\n  #meta = {\n    // 微秒\n    duration: 0,\n    width: 0,\n    height: 0,\n    audioSampleRate: 0,\n    audioChanCount: 0,\n  };\n\n  get meta() {\n    return { ...this.#meta };\n  }\n\n  #localFile: OPFSToolFile;\n\n  #headerBoxPos: Array<{ start: number; size: number }> = [];\n  /**\n   * 提供视频头（box: ftyp, moov）的二进制数据\n   * 使用任意 mp4 demxer 解析即可获得详细的视频信息\n   * 单元测试包含使用 mp4box.js 解析示例代码\n   */\n  async getFileHeaderBinData() {\n    await this.ready;\n    const oFile = await this.#localFile.getOriginFile();\n    if (oFile == null) throw Error('MP4Clip localFile is not origin file');\n\n    return await new Blob(\n      this.#headerBoxPos.map(({ start, size }) =>\n        oFile.slice(start, start + size),\n      ),\n    ).arrayBuffer();\n  }\n\n  #volume = 1;\n\n  #videoSamples: ExtMP4Sample[] = [];\n\n  #audioSamples: ExtMP4Sample[] = [];\n\n  #videoFrameFinder: VideoFrameFinder | null = null;\n  #audioFrameFinder: AudioFrameFinder | null = null;\n\n  #decoderConf: {\n    video: VideoDecoderConfig | null;\n    audio: AudioDecoderConfig | null;\n  } = {\n    video: null,\n    audio: null,\n  };\n\n  #opts: MP4ClipOpts = { audio: true };\n\n  constructor(\n    source: OPFSToolFile | ReadableStream<Uint8Array> | MPClipCloneArgs,\n    opts: MP4ClipOpts = {},\n  ) {\n    if (\n      !(source instanceof ReadableStream) &&\n      !isOTFile(source) &&\n      !Array.isArray(source.videoSamples)\n    ) {\n      throw Error('Illegal argument');\n    }\n\n    this.#opts = { audio: true, ...opts };\n    this.#volume =\n      typeof opts.audio === 'object' && 'volume' in opts.audio\n        ? opts.audio.volume\n        : 1;\n\n    const initByStream = async (s: ReadableStream) => {\n      await write(this.#localFile, s);\n      return this.#localFile;\n    };\n\n    this.#localFile = isOTFile(source)\n      ? source\n      : 'localFile' in source\n        ? source.localFile // from clone\n        : tmpfile();\n\n    this.ready = (\n      source instanceof ReadableStream\n        ? initByStream(source).then((otFile) =>\n            mp4FileToSamples(otFile, this.#opts),\n          )\n        : isOTFile(source)\n          ? mp4FileToSamples(source, this.#opts)\n          : Promise.resolve(source)\n    ).then(\n      async ({ videoSamples, audioSamples, decoderConf, headerBoxPos }) => {\n        this.#videoSamples = videoSamples;\n        this.#audioSamples = audioSamples;\n        this.#decoderConf = decoderConf;\n        this.#headerBoxPos = headerBoxPos;\n\n        const { videoFrameFinder, audioFrameFinder } = genDecoder(\n          {\n            video:\n              decoderConf.video == null\n                ? null\n                : {\n                    ...decoderConf.video,\n                    hardwareAcceleration:\n                      this.#opts.__unsafe_hardwareAcceleration__,\n                  },\n            audio: decoderConf.audio,\n          },\n          await this.#localFile.createReader(),\n          videoSamples,\n          audioSamples,\n          this.#opts.audio !== false ? this.#volume : 0,\n        );\n        this.#videoFrameFinder = videoFrameFinder;\n        this.#audioFrameFinder = audioFrameFinder;\n\n        this.#meta = genMeta(decoderConf, videoSamples, audioSamples);\n        this.#log.info('MP4Clip meta:', this.#meta);\n        return { ...this.#meta };\n      },\n    );\n  }\n\n  /**\n   * 拦截 {@link MP4Clip.tick} 方法返回的数据，用于对图像、音频数据二次处理\n   * @param time 调用 tick 的时间\n   * @param tickRet tick 返回的数据\n   *\n   * @see [移除视频绿幕背景](https://webav-tech.github.io/WebAV/demo/3_2-chromakey-video)\n   */\n  tickInterceptor: <T extends Awaited<ReturnType<MP4Clip['tick']>>>(\n    time: number,\n    tickRet: T,\n  ) => Promise<T> = async (_, tickRet) => tickRet;\n\n  /**\n   * 获取素材指定时刻的图像帧、音频数据\n   * @param time 微秒\n   */\n  async tick(time: number): Promise<{\n    video?: VideoFrame;\n    audio: Float32Array[];\n    state: 'success' | 'done';\n  }> {\n    if (time >= this.#meta.duration) {\n      return await this.tickInterceptor(time, {\n        audio: (await this.#audioFrameFinder?.find(time)) ?? [],\n        state: 'done',\n      });\n    }\n\n    const [audio, video] = await Promise.all([\n      this.#audioFrameFinder?.find(time) ?? [],\n      this.#videoFrameFinder?.find(time),\n    ]);\n\n    if (video == null) {\n      return await this.tickInterceptor(time, {\n        audio,\n        state: 'success',\n      });\n    }\n\n    return await this.tickInterceptor(time, {\n      video,\n      audio,\n      state: 'success',\n    });\n  }\n\n  #thumbAborter = new AbortController();\n  /**\n   * 生成缩略图，默认每个关键帧生成一个 100px 宽度的缩略图。\n   *\n   * @param imgWidth 缩略图宽度，默认 100\n   * @param opts Partial<ThumbnailOpts>\n   * @returns Promise<Array<{ ts: number; img: Blob }>>\n   */\n  async thumbnails(\n    imgWidth = 100,\n    opts?: Partial<ThumbnailOpts>,\n  ): Promise<Array<{ ts: number; img: Blob }>> {\n    this.#thumbAborter.abort();\n    this.#thumbAborter = new AbortController();\n    const aborterSignal = this.#thumbAborter.signal;\n\n    await this.ready;\n    const abortMsg = 'generate thumbnails aborted';\n    if (aborterSignal.aborted) throw Error(abortMsg);\n\n    const { width, height } = this.#meta;\n    const convtr = createVF2BlobConvtr(\n      imgWidth,\n      Math.round(height * (imgWidth / width)),\n      { quality: 0.1, type: 'image/png' },\n    );\n\n    return new Promise<Array<{ ts: number; img: Blob }>>(\n      async (resolve, reject) => {\n        let pngPromises: Array<{ ts: number; img: Promise<Blob> }> = [];\n        const vc = this.#decoderConf.video;\n        if (vc == null || this.#videoSamples.length === 0) {\n          resolver();\n          return;\n        }\n        aborterSignal.addEventListener('abort', () => {\n          reject(Error(abortMsg));\n        });\n\n        async function resolver() {\n          if (aborterSignal.aborted) return;\n          resolve(\n            await Promise.all(\n              pngPromises.map(async (it) => ({\n                ts: it.ts,\n                img: await it.img,\n              })),\n            ),\n          );\n        }\n\n        function pushPngPromise(vf: VideoFrame) {\n          pngPromises.push({\n            ts: vf.timestamp,\n            img: convtr(vf),\n          });\n        }\n\n        const { start = 0, end = this.#meta.duration, step } = opts ?? {};\n        if (step) {\n          let cur = start;\n          // 创建一个新的 VideoFrameFinder 实例，避免与 tick 方法共用而导致冲突\n          const videoFrameFinder = new VideoFrameFinder(\n            await this.#localFile.createReader(),\n            this.#videoSamples,\n            {\n              ...vc,\n              hardwareAcceleration: this.#opts.__unsafe_hardwareAcceleration__,\n            },\n          );\n          while (cur <= end && !aborterSignal.aborted) {\n            const vf = await videoFrameFinder.find(cur);\n            if (vf) pushPngPromise(vf);\n            cur += step;\n          }\n          videoFrameFinder.destroy();\n          resolver();\n        } else {\n          await thumbnailByKeyFrame(\n            this.#videoSamples,\n            this.#localFile,\n            vc,\n            aborterSignal,\n            { start, end },\n            (vf, done) => {\n              if (vf != null) pushPngPromise(vf);\n              if (done) resolver();\n            },\n          );\n        }\n      },\n    );\n  }\n\n  async split(time: number) {\n    await this.ready;\n\n    if (time <= 0 || time >= this.#meta.duration)\n      throw Error('\"time\" out of bounds');\n\n    const [preVideoSlice, postVideoSlice] = splitVideoSampleByTime(\n      this.#videoSamples,\n      time,\n    );\n    const [preAudioSlice, postAudioSlice] = splitAudioSampleByTime(\n      this.#audioSamples,\n      time,\n    );\n    const preClip = new MP4Clip(\n      {\n        localFile: this.#localFile,\n        videoSamples: preVideoSlice ?? [],\n        audioSamples: preAudioSlice ?? [],\n        decoderConf: this.#decoderConf,\n        headerBoxPos: this.#headerBoxPos,\n      },\n      this.#opts,\n    );\n    const postClip = new MP4Clip(\n      {\n        localFile: this.#localFile,\n        videoSamples: postVideoSlice ?? [],\n        audioSamples: postAudioSlice ?? [],\n        decoderConf: this.#decoderConf,\n        headerBoxPos: this.#headerBoxPos,\n      },\n      this.#opts,\n    );\n    await Promise.all([preClip.ready, postClip.ready]);\n\n    return [preClip, postClip] as [this, this];\n  }\n\n  async clone() {\n    await this.ready;\n    const clip = new MP4Clip(\n      {\n        localFile: this.#localFile,\n        videoSamples: [...this.#videoSamples],\n        audioSamples: [...this.#audioSamples],\n        decoderConf: this.#decoderConf,\n        headerBoxPos: this.#headerBoxPos,\n      },\n      this.#opts,\n    );\n    await clip.ready;\n    clip.tickInterceptor = this.tickInterceptor;\n    return clip as this;\n  }\n\n  /**\n   * 拆分 MP4Clip 为仅包含视频轨道和音频轨道的 MP4Clip\n   * @returns Mp4CLip[]\n   */\n  async splitTrack() {\n    await this.ready;\n    const clips: MP4Clip[] = [];\n    if (this.#videoSamples.length > 0) {\n      const videoClip = new MP4Clip(\n        {\n          localFile: this.#localFile,\n          videoSamples: [...this.#videoSamples],\n          audioSamples: [],\n          decoderConf: {\n            video: this.#decoderConf.video,\n            audio: null,\n          },\n          headerBoxPos: this.#headerBoxPos,\n        },\n        this.#opts,\n      );\n      await videoClip.ready;\n      videoClip.tickInterceptor = this.tickInterceptor;\n      clips.push(videoClip);\n    }\n    if (this.#audioSamples.length > 0) {\n      const audioClip = new MP4Clip(\n        {\n          localFile: this.#localFile,\n          videoSamples: [],\n          audioSamples: [...this.#audioSamples],\n          decoderConf: {\n            audio: this.#decoderConf.audio,\n            video: null,\n          },\n          headerBoxPos: this.#headerBoxPos,\n        },\n        this.#opts,\n      );\n      await audioClip.ready;\n      audioClip.tickInterceptor = this.tickInterceptor;\n      clips.push(audioClip);\n    }\n\n    return clips;\n  }\n\n  destroy(): void {\n    if (this.#destroyed) return;\n    this.#log.info('MP4Clip destroy');\n    this.#destroyed = true;\n\n    this.#videoFrameFinder?.destroy();\n    this.#audioFrameFinder?.destroy();\n  }\n}\n\nfunction genMeta(\n  decoderConf: MP4DecoderConf,\n  videoSamples: ExtMP4Sample[],\n  audioSamples: ExtMP4Sample[],\n) {\n  const meta = {\n    duration: 0,\n    width: 0,\n    height: 0,\n    audioSampleRate: 0,\n    audioChanCount: 0,\n  };\n  if (decoderConf.video != null && videoSamples.length > 0) {\n    meta.width = decoderConf.video.codedWidth ?? 0;\n    meta.height = decoderConf.video.codedHeight ?? 0;\n  }\n  if (decoderConf.audio != null && audioSamples.length > 0) {\n    meta.audioSampleRate = DEFAULT_AUDIO_CONF.sampleRate;\n    meta.audioChanCount = DEFAULT_AUDIO_CONF.channelCount;\n  }\n\n  let vDuration = 0;\n  let aDuration = 0;\n  if (videoSamples.length > 0) {\n    for (let i = videoSamples.length - 1; i >= 0; i--) {\n      const s = videoSamples[i];\n      if (s.deleted) continue;\n      vDuration = s.cts + s.duration;\n      break;\n    }\n  }\n  if (audioSamples.length > 0) {\n    const lastSampele = audioSamples.at(-1)!;\n    aDuration = lastSampele.cts + lastSampele.duration;\n  }\n  meta.duration = Math.max(vDuration, aDuration);\n\n  return meta;\n}\n\nfunction genDecoder(\n  decoderConf: MP4DecoderConf,\n  localFileReader: LocalFileReader,\n  videoSamples: ExtMP4Sample[],\n  audioSamples: ExtMP4Sample[],\n  volume: number,\n) {\n  return {\n    audioFrameFinder:\n      volume === 0 || decoderConf.audio == null || audioSamples.length === 0\n        ? null\n        : new AudioFrameFinder(\n            localFileReader,\n            audioSamples,\n            decoderConf.audio,\n            {\n              volume,\n              targetSampleRate: DEFAULT_AUDIO_CONF.sampleRate,\n            },\n          ),\n    videoFrameFinder:\n      decoderConf.video == null || videoSamples.length === 0\n        ? null\n        : new VideoFrameFinder(\n            localFileReader,\n            videoSamples,\n            decoderConf.video,\n          ),\n  };\n}\n\nasync function mp4FileToSamples(otFile: OPFSToolFile, opts: MP4ClipOpts = {}) {\n  let mp4Info: MP4Info | null = null;\n  const decoderConf: MP4DecoderConf = { video: null, audio: null };\n  let videoSamples: ExtMP4Sample[] = [];\n  let audioSamples: ExtMP4Sample[] = [];\n  let headerBoxPos: Array<{ start: number; size: number }> = [];\n\n  let videoDeltaTS = -1;\n  let audioDeltaTS = -1;\n  const reader = await otFile.createReader();\n  await quickParseMP4File(\n    reader,\n    (data) => {\n      mp4Info = data.info;\n      const ftyp = data.mp4boxFile.ftyp!;\n      headerBoxPos.push({ start: ftyp.start, size: ftyp.size });\n      const moov = data.mp4boxFile.moov!;\n      headerBoxPos.push({ start: moov.start, size: moov.size });\n\n      let { videoDecoderConf: vc, audioDecoderConf: ac } = extractFileConfig(\n        data.mp4boxFile,\n        data.info,\n      );\n      decoderConf.video = vc ?? null;\n      decoderConf.audio = ac ?? null;\n      if (vc == null && ac == null) {\n        Log.error('MP4Clip no video and audio track');\n      }\n      Log.info(\n        'mp4BoxFile moov ready',\n        {\n          ...data.info,\n          tracks: null,\n          videoTracks: null,\n          audioTracks: null,\n        },\n        decoderConf,\n      );\n    },\n    (_, type, samples) => {\n      if (type === 'video') {\n        if (videoDeltaTS === -1) videoDeltaTS = samples[0].dts;\n        for (const s of samples) {\n          videoSamples.push(normalizeTimescale(s, videoDeltaTS, 'video'));\n        }\n      } else if (type === 'audio' && opts.audio) {\n        if (audioDeltaTS === -1) audioDeltaTS = samples[0].dts;\n        for (const s of samples) {\n          audioSamples.push(normalizeTimescale(s, audioDeltaTS, 'audio'));\n        }\n      }\n    },\n  );\n  await reader.close();\n\n  const lastSampele = videoSamples.at(-1) ?? audioSamples.at(-1);\n  if (mp4Info == null) {\n    throw Error('MP4Clip stream is done, but not emit ready');\n  } else if (lastSampele == null) {\n    throw Error('MP4Clip stream not contain any sample');\n  }\n  // 修复首帧黑帧\n  fixFirstBlackFrame(videoSamples);\n  Log.info('mp4 stream parsed');\n  return {\n    videoSamples,\n    audioSamples,\n    decoderConf,\n    headerBoxPos,\n  };\n\n  function normalizeTimescale(\n    s: MP4Sample,\n    delta = 0,\n    sampleType: 'video' | 'audio',\n  ) {\n    // todo: perf 丢弃多余字段，小尺寸对象性能更好\n    const idrOffset =\n      sampleType === 'video' && s.is_sync\n        ? idrNALUOffset(s.data, s.description.type)\n        : -1;\n    let offset = s.offset;\n    let size = s.size;\n    if (idrOffset >= 0) {\n      // 当 IDR 帧前面携带 SEI 数据可能导致解码失败\n      // 所以此处通过控制 offset、size 字段 跳过 SEI 数据\n      offset += idrOffset;\n      size -= idrOffset;\n    }\n    return {\n      ...s,\n      is_idr: idrOffset >= 0,\n      offset,\n      size,\n      cts: ((s.cts - delta) / s.timescale) * 1e6,\n      dts: ((s.dts - delta) / s.timescale) * 1e6,\n      duration: (s.duration / s.timescale) * 1e6,\n      timescale: 1e6,\n      // 音频数据量可控，直接保存在内存中\n      data: sampleType === 'video' ? null : s.data,\n    };\n  }\n}\n\nclass VideoFrameFinder {\n  #dec: VideoDecoder | null = null;\n  constructor(\n    public localFileReader: LocalFileReader,\n    public samples: ExtMP4Sample[],\n    public conf: VideoDecoderConfig,\n  ) {}\n\n  #ts = 0;\n  #curAborter = { abort: false, st: performance.now() };\n  find = async (time: number): Promise<VideoFrame | null> => {\n    if (\n      this.#dec == null ||\n      this.#dec.state === 'closed' ||\n      time <= this.#ts ||\n      time - this.#ts > 3e6\n    ) {\n      this.#reset(time);\n    }\n\n    this.#curAborter.abort = true;\n    this.#ts = time;\n\n    this.#curAborter = { abort: false, st: performance.now() };\n    const vf = await this.#parseFrame(time, this.#dec, this.#curAborter);\n    this.#sleepCnt = 0;\n    return vf;\n  };\n\n  // fix VideoFrame duration is null\n  #lastVfDur = 0;\n\n  #downgradeSoftDecode = false;\n  #videoDecCusorIdx = 0;\n  #videoFrames: VideoFrame[] = [];\n  #outputFrameCnt = 0;\n  #inputChunkCnt = 0;\n  #sleepCnt = 0;\n  #predecodeErr = false;\n  #parseFrame = async (\n    time: number,\n    dec: VideoDecoder | null,\n    aborter: { abort: boolean; st: number },\n  ): Promise<VideoFrame | null> => {\n    if (dec == null || dec.state === 'closed' || aborter.abort) return null;\n\n    if (this.#videoFrames.length > 0) {\n      const vf = this.#videoFrames[0];\n      if (time < vf.timestamp) return null;\n      // 弹出第一帧\n      this.#videoFrames.shift();\n      // 第一帧过期，找下一帧\n      if (time > vf.timestamp + (vf.duration ?? 0)) {\n        vf.close();\n        return await this.#parseFrame(time, dec, aborter);\n      }\n\n      if (!this.#predecodeErr && this.#videoFrames.length < 10) {\n        // 预解码 避免等待\n        this.#startDecode(dec).catch((err) => {\n          this.#predecodeErr = true;\n          this.#reset(time);\n          throw err;\n        });\n      }\n      // 符合期望\n      return vf;\n    }\n\n    // 缺少帧数据\n    if (\n      this.#decoding ||\n      (this.#outputFrameCnt < this.#inputChunkCnt && dec.decodeQueueSize > 0)\n    ) {\n      if (performance.now() - aborter.st > 6e3) {\n        throw Error(\n          `MP4Clip.tick video timeout, ${JSON.stringify(this.#getState())}`,\n        );\n      }\n      // 解码中，等待，然后重试\n      this.#sleepCnt += 1;\n      await sleep(15);\n    } else if (this.#videoDecCusorIdx >= this.samples.length) {\n      // decode completed\n      return null;\n    } else {\n      try {\n        await this.#startDecode(dec);\n      } catch (err) {\n        this.#reset(time);\n        throw err;\n      }\n    }\n    return await this.#parseFrame(time, dec, aborter);\n  };\n\n  #decoding = false;\n  #startDecode = async (dec: VideoDecoder) => {\n    if (this.#decoding || dec.decodeQueueSize > 600) return;\n\n    // 启动解码任务，然后重试\n    let endIdx = this.#videoDecCusorIdx + 1;\n    if (endIdx > this.samples.length) return;\n\n    this.#decoding = true;\n    // 该 GoP 时间区间有时间匹配，且未被删除的帧\n    let hasValidFrame = false;\n    for (; endIdx < this.samples.length; endIdx++) {\n      const s = this.samples[endIdx];\n      if (!hasValidFrame && !s.deleted) {\n        hasValidFrame = true;\n      }\n      // 找一个 GoP，所以是下一个 IDR 帧结束\n      if (s.is_idr) break;\n    }\n\n    if (hasValidFrame) {\n      const samples = this.samples.slice(this.#videoDecCusorIdx, endIdx);\n      if (samples[0]?.is_idr !== true) {\n        Log.warn('First sample not idr frame');\n      } else {\n        const readStarTime = performance.now();\n        const chunks = await videosamples2Chunks(samples, this.localFileReader);\n\n        const readCost = performance.now() - readStarTime;\n        if (readCost > 1000) {\n          const first = samples[0];\n          const last = samples.at(-1)!;\n          const rangSize = last.offset + last.size - first.offset;\n          Log.warn(\n            `Read video samples time cost: ${Math.round(readCost)}ms, file chunk size: ${rangSize}`,\n          );\n        }\n        // Wait for the previous asynchronous operation to complete, at which point the task may have already been terminated\n        if (dec.state === 'closed') return;\n\n        this.#lastVfDur = chunks[0]?.duration ?? 0;\n        decodeGoP(dec, chunks, {\n          onDecodingError: (err) => {\n            if (this.#downgradeSoftDecode) {\n              throw err;\n            } else if (this.#outputFrameCnt === 0) {\n              this.#downgradeSoftDecode = true;\n              Log.warn('Downgrade to software decode');\n              this.#reset();\n            }\n          },\n        });\n\n        this.#inputChunkCnt += chunks.length;\n      }\n    }\n    this.#videoDecCusorIdx = endIdx;\n    this.#decoding = false;\n  };\n\n  #reset = (time?: number) => {\n    this.#decoding = false;\n    this.#videoFrames.forEach((f) => f.close());\n    this.#videoFrames = [];\n    if (time == null || time === 0) {\n      this.#videoDecCusorIdx = 0;\n    } else {\n      let keyIdx = 0;\n      for (let i = 0; i < this.samples.length; i++) {\n        const s = this.samples[i];\n        if (s.is_idr) keyIdx = i;\n        if (s.cts < time) continue;\n        this.#videoDecCusorIdx = keyIdx;\n        break;\n      }\n    }\n    this.#inputChunkCnt = 0;\n    this.#outputFrameCnt = 0;\n    if (this.#dec?.state !== 'closed') this.#dec?.close();\n    const encoderConf = {\n      ...this.conf,\n      ...(this.#downgradeSoftDecode\n        ? { hardwareAcceleration: 'prefer-software' }\n        : {}),\n    } as VideoDecoderConfig;\n    this.#dec = new VideoDecoder({\n      output: (vf) => {\n        this.#outputFrameCnt += 1;\n        if (vf.timestamp === -1) {\n          vf.close();\n          return;\n        }\n        let rsVf = vf;\n        if (vf.duration == null) {\n          rsVf = new VideoFrame(vf, {\n            duration: this.#lastVfDur,\n          });\n          vf.close();\n        }\n        this.#videoFrames.push(rsVf);\n      },\n      error: (err) => {\n        if (err.message.includes('Codec reclaimed due to inactivity')) {\n          // todo:  因无活动被自动关闭的解码器，是否需要自动重启？\n          this.#dec = null;\n          Log.warn(err.message);\n          return;\n        }\n\n        const errMsg = `VideoFinder VideoDecoder err: ${err.message}, config: ${JSON.stringify(encoderConf)}, state: ${JSON.stringify(this.#getState())}`;\n        Log.error(errMsg);\n        throw Error(errMsg);\n      },\n    });\n    this.#dec.configure(encoderConf);\n  };\n\n  #getState = () => ({\n    time: this.#ts,\n    decState: this.#dec?.state,\n    decQSize: this.#dec?.decodeQueueSize,\n    decCusorIdx: this.#videoDecCusorIdx,\n    sampleLen: this.samples.length,\n    inputCnt: this.#inputChunkCnt,\n    outputCnt: this.#outputFrameCnt,\n    cacheFrameLen: this.#videoFrames.length,\n    softDeocde: this.#downgradeSoftDecode,\n    clipIdCnt: CLIP_ID,\n    sleepCnt: this.#sleepCnt,\n    memInfo: memoryUsageInfo(),\n  });\n\n  destroy = () => {\n    if (this.#dec?.state !== 'closed') this.#dec?.close();\n    this.#dec = null;\n    this.#curAborter.abort = true;\n    this.#videoFrames.forEach((f) => f.close());\n    this.#videoFrames = [];\n    this.localFileReader.close();\n  };\n}\n\nfunction findIndexOfSamples(time: number, samples: ExtMP4Sample[]) {\n  for (let i = 0; i < samples.length; i++) {\n    const s = samples[i];\n    if (time >= s.cts && time < s.cts + s.duration) {\n      return i;\n    }\n    if (s.cts > time) break;\n  }\n  return 0;\n}\n\nclass AudioFrameFinder {\n  #volume = 1;\n  #sampleRate;\n  constructor(\n    public localFileReader: LocalFileReader,\n    public samples: ExtMP4Sample[],\n    public conf: AudioDecoderConfig,\n    opts: { volume: number; targetSampleRate: number },\n  ) {\n    this.#volume = opts.volume;\n    this.#sampleRate = opts.targetSampleRate;\n  }\n\n  #dec: ReturnType<typeof createAudioChunksDecoder> | null = null;\n  #curAborter = { abort: false, st: performance.now() };\n  find = async (time: number): Promise<Float32Array[]> => {\n    const needResetTime = time <= this.#ts || time - this.#ts > 0.1e6;\n    if (this.#dec == null || this.#dec.state === 'closed' || needResetTime) {\n      this.#reset();\n    }\n\n    if (needResetTime) {\n      // 前后获取音频数据差异不能超过 100ms(经验值)，否则视为 seek 操作，重置解码器\n      // seek 操作，重置时间\n      this.#ts = time;\n      this.#decCusorIdx = findIndexOfSamples(time, this.samples);\n    }\n\n    this.#curAborter.abort = true;\n    const deltaTime = time - this.#ts;\n    this.#ts = time;\n\n    this.#curAborter = { abort: false, st: performance.now() };\n\n    const pcmData = await this.#parseFrame(\n      Math.ceil(deltaTime * (this.#sampleRate / 1e6)),\n      this.#dec,\n      this.#curAborter,\n    );\n    this.#sleepCnt = 0;\n    return pcmData;\n  };\n\n  #ts = 0;\n  #decCusorIdx = 0;\n  #pcmData: {\n    frameCnt: number;\n    data: [Float32Array, Float32Array][];\n  } = {\n    frameCnt: 0,\n    data: [],\n  };\n  #sleepCnt = 0;\n  #parseFrame = async (\n    emitFrameCnt: number,\n    dec: ReturnType<typeof createAudioChunksDecoder> | null = null,\n    aborter: { abort: boolean; st: number },\n  ): Promise<Float32Array[]> => {\n    if (\n      dec == null ||\n      aborter.abort ||\n      dec.state === 'closed' ||\n      emitFrameCnt === 0\n    ) {\n      return [];\n    }\n\n    // 数据满足需要\n    const ramainFrameCnt = this.#pcmData.frameCnt - emitFrameCnt;\n    if (ramainFrameCnt > 0) {\n      // 剩余音频数据小于 100ms，预先解码\n      if (ramainFrameCnt < DEFAULT_AUDIO_CONF.sampleRate / 10) {\n        this.#startDecode(dec);\n      }\n      return emitAudioFrames(this.#pcmData, emitFrameCnt);\n    }\n\n    if (dec.decoding) {\n      if (performance.now() - aborter.st > 3e3) {\n        aborter.abort = true;\n        throw Error(\n          `MP4Clip.tick audio timeout, ${JSON.stringify(this.#getState())}`,\n        );\n      }\n      // 解码中，等待\n      this.#sleepCnt += 1;\n      await sleep(15);\n    } else if (this.#decCusorIdx >= this.samples.length - 1) {\n      // 最后片段，返回剩余数据\n      return emitAudioFrames(this.#pcmData, this.#pcmData.frameCnt);\n    } else {\n      this.#startDecode(dec);\n    }\n    return this.#parseFrame(emitFrameCnt, dec, aborter);\n  };\n\n  #startDecode = (dec: ReturnType<typeof createAudioChunksDecoder>) => {\n    const onceDecodeCnt = 10;\n    if (dec.decodeQueueSize > onceDecodeCnt) return;\n    // 启动解码任务\n    const samples = [];\n    let i = this.#decCusorIdx;\n    while (i < this.samples.length) {\n      const s = this.samples[i];\n      i += 1;\n      if (s.deleted) continue;\n      samples.push(s);\n      if (samples.length >= onceDecodeCnt) break;\n    }\n    this.#decCusorIdx = i;\n\n    dec.decode(\n      samples.map(\n        (s) =>\n          new EncodedAudioChunk({\n            type: 'key',\n            timestamp: s.cts,\n            duration: s.duration,\n            data: s.data!,\n          }),\n      ),\n    );\n  };\n\n  #reset = () => {\n    this.#ts = 0;\n    this.#decCusorIdx = 0;\n    this.#pcmData = {\n      frameCnt: 0,\n      data: [],\n    };\n    this.#dec?.close();\n    this.#dec = createAudioChunksDecoder(\n      this.conf,\n      {\n        resampleRate: DEFAULT_AUDIO_CONF.sampleRate,\n        volume: this.#volume,\n      },\n      (pcmArr) => {\n        this.#pcmData.data.push(pcmArr as [Float32Array, Float32Array]);\n        this.#pcmData.frameCnt += pcmArr[0].length;\n      },\n    );\n  };\n\n  #getState = () => ({\n    time: this.#ts,\n    decState: this.#dec?.state,\n    decQSize: this.#dec?.decodeQueueSize,\n    decCusorIdx: this.#decCusorIdx,\n    sampleLen: this.samples.length,\n    pcmLen: this.#pcmData.frameCnt,\n    clipIdCnt: CLIP_ID,\n    sleepCnt: this.#sleepCnt,\n    memInfo: memoryUsageInfo(),\n  });\n\n  destroy = () => {\n    this.#dec = null;\n    this.#curAborter.abort = true;\n    this.#pcmData = {\n      frameCnt: 0,\n      data: [],\n    };\n    this.localFileReader.close();\n  };\n}\n\nfunction createAudioChunksDecoder(\n  decoderConf: AudioDecoderConfig,\n  opts: { resampleRate: number; volume: number },\n  outputCb: (pcm: Float32Array[]) => void,\n) {\n  let inputCnt = 0;\n  let outputCnt = 0;\n  const outputHandler = (pcmArr: Float32Array[]) => {\n    outputCnt += 1;\n    if (pcmArr.length === 0) return;\n    // 音量调节\n    if (opts.volume !== 1) {\n      for (const pcm of pcmArr)\n        for (let i = 0; i < pcm.length; i++) pcm[i] *= opts.volume;\n    }\n\n    // 补齐双声道\n    if (pcmArr.length === 1) pcmArr = [pcmArr[0], pcmArr[0]];\n\n    outputCb(pcmArr);\n  };\n  const resampleQ = createPromiseQueue<Float32Array[]>(outputHandler);\n\n  const needResample = opts.resampleRate !== decoderConf.sampleRate;\n  let adec = new AudioDecoder({\n    output: (ad) => {\n      const pcm = extractPCM4AudioData(ad);\n      if (needResample) {\n        resampleQ(() =>\n          audioResample(pcm, ad.sampleRate, {\n            rate: opts.resampleRate,\n            chanCount: ad.numberOfChannels,\n          }),\n        );\n      } else {\n        outputHandler(pcm);\n      }\n      ad.close();\n    },\n    error: (err) => {\n      if (err.message.includes('Codec reclaimed due to inactivity')) {\n        return;\n      }\n      handleDecodeError('MP4Clip AudioDecoder err', err as Error);\n    },\n  });\n  adec.configure(decoderConf);\n\n  function handleDecodeError(prefixStr: string, err: Error) {\n    const errMsg = `${prefixStr}: ${(err as Error).message}, state: ${JSON.stringify(\n      {\n        qSize: adec.decodeQueueSize,\n        state: adec.state,\n        inputCnt,\n        outputCnt,\n      },\n    )}`;\n    Log.error(errMsg);\n    throw Error(errMsg);\n  }\n\n  return {\n    decode(chunks: EncodedAudioChunk[]) {\n      inputCnt += chunks.length;\n      try {\n        for (const chunk of chunks) adec.decode(chunk);\n      } catch (err) {\n        handleDecodeError('decode audio chunk error', err as Error);\n      }\n    },\n    close() {\n      if (adec.state !== 'closed') adec.close();\n    },\n    get decoding() {\n      return inputCnt > outputCnt && adec.decodeQueueSize > 0;\n    },\n    get state() {\n      return adec.state;\n    },\n    get decodeQueueSize() {\n      return adec.decodeQueueSize;\n    },\n  };\n}\n\n// 并行执行任务，但按顺序emit结果\nfunction createPromiseQueue<T extends any>(onResult: (data: T) => void) {\n  const rsCache: T[] = [];\n  let waitingIdx = 0;\n\n  function updateRs(rs: T, emitIdx: number) {\n    rsCache[emitIdx] = rs;\n    emitRs();\n  }\n\n  function emitRs() {\n    const rs = rsCache[waitingIdx];\n    if (rs == null) return;\n    onResult(rs);\n\n    waitingIdx += 1;\n    emitRs();\n  }\n\n  let addIdx = 0;\n  return (task: () => Promise<T>) => {\n    const emitIdx = addIdx;\n    addIdx += 1;\n    task()\n      .then((rs) => updateRs(rs, emitIdx))\n      .catch((err) => updateRs(err, emitIdx));\n  };\n}\n\nfunction emitAudioFrames(\n  pcmData: { frameCnt: number; data: [Float32Array, Float32Array][] },\n  emitCnt: number,\n) {\n  // todo: perf 重复利用内存空间\n  const audio = [new Float32Array(emitCnt), new Float32Array(emitCnt)];\n  let offset = 0;\n  let i = 0;\n  for (; i < pcmData.data.length; ) {\n    const [chan0, chan1] = pcmData.data[i];\n    if (offset + chan0.length > emitCnt) {\n      const gapCnt = emitCnt - offset;\n      audio[0].set(chan0.subarray(0, gapCnt), offset);\n      audio[1].set(chan1.subarray(0, gapCnt), offset);\n      pcmData.data[i][0] = chan0.subarray(gapCnt, chan0.length);\n      pcmData.data[i][1] = chan1.subarray(gapCnt, chan1.length);\n      break;\n    } else {\n      audio[0].set(chan0, offset);\n      audio[1].set(chan1, offset);\n      offset += chan0.length;\n      i++;\n    }\n  }\n  pcmData.data = pcmData.data.slice(i);\n  pcmData.frameCnt -= emitCnt;\n  return audio;\n}\n\nasync function videosamples2Chunks(\n  samples: ExtMP4Sample[],\n  reader: Awaited<ReturnType<OPFSToolFile['createReader']>>,\n): Promise<EncodedVideoChunk[]> {\n  const first = samples[0];\n  const last = samples.at(-1);\n  if (last == null) return [];\n\n  const rangSize = last.offset + last.size - first.offset;\n  if (rangSize < 30e6) {\n    // 单次读取数据小于 30M，就一次性读取数据，降低 IO 频次\n    const data = new Uint8Array(\n      await reader.read(rangSize, { at: first.offset }),\n    );\n    return samples.map((s) => {\n      const offset = s.offset - first.offset;\n      return new EncodedVideoChunk({\n        type: s.is_sync ? 'key' : 'delta',\n        timestamp: s.cts,\n        duration: s.duration,\n        data: data.subarray(offset, offset + s.size),\n      });\n    });\n  }\n\n  return await Promise.all(\n    samples.map(async (s) => {\n      return new EncodedVideoChunk({\n        type: s.is_sync ? 'key' : 'delta',\n        timestamp: s.cts,\n        duration: s.duration,\n        data: await reader.read(s.size, {\n          at: s.offset,\n        }),\n      });\n    }),\n  );\n}\n\nfunction createVF2BlobConvtr(\n  width: number,\n  height: number,\n  opts?: ImageEncodeOptions,\n) {\n  const cvs = new OffscreenCanvas(width, height);\n  const ctx = cvs.getContext('2d')!;\n\n  return async (vf: VideoFrame) => {\n    ctx.drawImage(vf, 0, 0, width, height);\n    vf.close();\n    const blob = await cvs.convertToBlob(opts);\n    return blob;\n  };\n}\n\nfunction splitVideoSampleByTime(videoSamples: ExtMP4Sample[], time: number) {\n  if (videoSamples.length === 0) return [];\n  let gopStartIdx = 0;\n  let gopEndIdx = 0;\n  let hitIdx = -1;\n  for (let i = 0; i < videoSamples.length; i++) {\n    const s = videoSamples[i];\n    if (hitIdx === -1 && time < s.cts) hitIdx = i - 1;\n    if (s.is_idr) {\n      if (hitIdx === -1) {\n        gopStartIdx = i;\n      } else {\n        gopEndIdx = i;\n        break;\n      }\n    }\n  }\n\n  const hitSample = videoSamples[hitIdx];\n  if (hitSample == null) throw Error('Not found video sample by time');\n\n  const preSlice = videoSamples\n    .slice(0, gopEndIdx === 0 ? videoSamples.length : gopEndIdx)\n    .map((s) => ({ ...s }));\n  for (let i = gopStartIdx; i < preSlice.length; i++) {\n    const s = preSlice[i];\n    if (time < s.cts) {\n      s.deleted = true;\n      s.cts = -1;\n    }\n  }\n  fixFirstBlackFrame(preSlice);\n\n  const postSlice = videoSamples\n    .slice(hitSample.is_idr ? hitIdx : gopStartIdx)\n    .map((s) => ({ ...s, cts: s.cts - time }));\n\n  for (const s of postSlice) {\n    if (s.cts < 0) {\n      s.deleted = true;\n      s.cts = -1;\n    }\n  }\n  fixFirstBlackFrame(postSlice);\n\n  return [preSlice, postSlice];\n}\n\nfunction splitAudioSampleByTime(audioSamples: ExtMP4Sample[], time: number) {\n  if (audioSamples.length === 0) return [];\n  let hitIdx = -1;\n  for (let i = 0; i < audioSamples.length; i++) {\n    const s = audioSamples[i];\n    if (time > s.cts) continue;\n    hitIdx = i;\n    break;\n  }\n  if (hitIdx === -1) throw Error('Not found audio sample by time');\n  const preSlice = audioSamples.slice(0, hitIdx).map((s) => ({ ...s }));\n  const postSlice = audioSamples\n    .slice(hitIdx)\n    .map((s) => ({ ...s, cts: s.cts - time }));\n  return [preSlice, postSlice];\n}\n\n// 兼容解码错误\nfunction decodeGoP(\n  dec: VideoDecoder,\n  chunks: EncodedVideoChunk[],\n  opts: {\n    onDecodingError?: (err: Error) => void;\n  },\n) {\n  let i = 0;\n  if (dec.state !== 'configured') return;\n  for (; i < chunks.length; i++) dec.decode(chunks[i]);\n\n  // todo：flush 之后下一帧必须是 IDR 帧，是否可以根据情况再决定调用 flush？\n  // windows 某些设备 flush 可能不会被 resolved，所以不能 await flush\n  dec.flush().catch((err) => {\n    if (!(err instanceof Error)) throw err;\n    if (\n      err.message.includes('Decoding error') &&\n      opts.onDecodingError != null\n    ) {\n      opts.onDecodingError(err);\n      return;\n    }\n    // reset 中断解码器，预期会抛出 AbortedError\n    if (!err.message.includes('Aborted due to close')) {\n      throw err;\n    }\n  });\n}\n\nfunction idrNALUOffset(\n  u8Arr: Uint8Array,\n  type: MP4Sample['description']['type'],\n) {\n  if (type !== 'avc1' && type !== 'hvc1') return 0;\n\n  const dv = new DataView(u8Arr.buffer);\n  let i = 0;\n  for (; i < u8Arr.byteLength - 4; ) {\n    if (type === 'avc1' && (dv.getUint8(i + 4) & 0x1f) === 5) {\n      return i;\n    } else if (type === 'hvc1') {\n      const nalUnitType = (dv.getUint8(i + 4) >> 1) & 0x3f;\n      if (nalUnitType === 19 || nalUnitType === 20) return i;\n    }\n    // 跳至下一个 NALU 继续检查\n    i += dv.getUint32(i) + 4;\n  }\n  return -1;\n}\n\nasync function thumbnailByKeyFrame(\n  samples: ExtMP4Sample[],\n  localFile: OPFSToolFile,\n  decConf: VideoDecoderConfig,\n  abortSingl: AbortSignal,\n  time: { start: number; end: number },\n  onOutput: (vf: VideoFrame | null, done: boolean) => void,\n) {\n  const fileReader = await localFile.createReader();\n\n  const chunks = await videosamples2Chunks(\n    samples.filter(\n      (s) =>\n        !s.deleted && s.is_sync && s.cts >= time.start && s.cts <= time.end,\n    ),\n    fileReader,\n  );\n  if (chunks.length === 0 || abortSingl.aborted) return;\n\n  let outputCnt = 0;\n  decodeGoP(createVideoDec(), chunks, {\n    onDecodingError: (err) => {\n      Log.warn('thumbnailsByKeyFrame', err);\n      // 尝试降级一次\n      if (outputCnt === 0) {\n        decodeGoP(createVideoDec(true), chunks, {\n          onDecodingError: (err) => {\n            fileReader.close();\n            Log.error('thumbnailsByKeyFrame retry soft deocde', err);\n          },\n        });\n      } else {\n        onOutput(null, true);\n        fileReader.close();\n      }\n    },\n  });\n\n  function createVideoDec(downgrade = false) {\n    const encoderConf = {\n      ...decConf,\n      ...(downgrade ? { hardwareAcceleration: 'prefer-software' } : {}),\n    } as VideoDecoderConfig;\n    const dec = new VideoDecoder({\n      output: (vf) => {\n        outputCnt += 1;\n        const done = outputCnt === chunks.length;\n        onOutput(vf, done);\n        if (done) {\n          fileReader.close();\n          if (dec.state !== 'closed') dec.close();\n        }\n      },\n      error: (err) => {\n        const errMsg = `thumbnails decoder error: ${err.message}, config: ${JSON.stringify(encoderConf)}, state: ${JSON.stringify(\n          {\n            qSize: dec.decodeQueueSize,\n            state: dec.state,\n            outputCnt,\n            inputCnt: chunks.length,\n          },\n        )}`;\n        Log.error(errMsg);\n        throw Error(errMsg);\n      },\n    });\n    abortSingl.addEventListener('abort', () => {\n      fileReader.close();\n      if (dec.state !== 'closed') dec.close();\n    });\n    dec.configure(encoderConf);\n    return dec;\n  }\n}\n\n// 如果第一帧出现的时间偏移较大，会导致第一帧为黑帧，这里尝试自动消除第一帧前的黑帧\nfunction fixFirstBlackFrame(samples: ExtMP4Sample[]) {\n  let iframeCnt = 0;\n  let minCtsSample: ExtMP4Sample | null = null;\n  // cts 最小表示视频的第一帧\n  for (const s of samples) {\n    if (s.deleted) continue;\n    // 最多检测两个 I 帧之间的帧\n    if (s.is_sync) iframeCnt += 1;\n    if (iframeCnt >= 2) break;\n\n    if (minCtsSample == null || s.cts < minCtsSample.cts) {\n      minCtsSample = s;\n    }\n  }\n  // 200ms 是经验值，自动消除 200ms 内的黑帧，超过则不处理\n  if (minCtsSample != null && minCtsSample.cts < 200e3) {\n    minCtsSample.duration += minCtsSample.cts;\n    minCtsSample.cts = 0;\n  }\n}\n\nfunction memoryUsageInfo() {\n  try {\n    // @ts-ignore\n    const mem = performance.memory;\n    return {\n      jsHeapSizeLimit: mem.jsHeapSizeLimit,\n      totalJSHeapSize: mem.totalJSHeapSize,\n      usedJSHeapSize: mem.usedJSHeapSize,\n      percentUsed: (mem.usedJSHeapSize / mem.jsHeapSizeLimit).toFixed(3),\n      percentTotal: (mem.totalJSHeapSize / mem.jsHeapSizeLimit).toFixed(3),\n    };\n  } catch (err) {\n    return {};\n  }\n}\n","import { decodeImg } from '../av-utils';\nimport { Log } from '@webav/internal-utils';\nimport { IClip } from './iclip';\n\ntype AnimateImgType = 'avif' | 'webp' | 'png' | 'gif';\n\n/**\n * 图像素材，支持动图\n *\n * 普通文字可通过 {@link renderTxt2ImgBitmap} 转换成图片素材\n *\n * @example\n * new ImgClip((await fetch('<img url>')).body);\n *\n * @example\n * new ImgClip(\n *   await renderTxt2ImgBitmap(\n *     '水印',\n *    `font-size:40px; color: white; text-shadow: 2px 2px 6px red;`,\n *   )\n * )\n *\n * @see [视频合成](https://webav-tech.github.io/WebAV/demo/2_1-concat-video)\n */\nexport class ImgClip implements IClip {\n  ready: IClip['ready'];\n\n  #meta = {\n    // 微秒\n    duration: 0,\n    width: 0,\n    height: 0,\n  };\n\n  /**\n   * ⚠️ 静态图片的 duration 为 Infinity\n   *\n   * 使用 Sprite 包装时需要将它的 duration 设置为有限数\n   *\n   */\n  get meta() {\n    return { ...this.#meta };\n  }\n\n  #img: ImageBitmap | null = null;\n\n  #frames: VideoFrame[] = [];\n\n  /**\n   * 静态图片可使用流、ImageBitmap 初始化\n   *\n   * 动图需要使用 VideoFrame[] 或提供图片类型\n   */\n  constructor(\n    dataSource:\n      | ReadableStream\n      | ImageBitmap\n      | VideoFrame[]\n      | { type: `image/${AnimateImgType}`; stream: ReadableStream },\n  ) {\n    const initWithImgBitmap = (imgBitmap: ImageBitmap) => {\n      this.#img = imgBitmap;\n      this.#meta.width = imgBitmap.width;\n      this.#meta.height = imgBitmap.height;\n      this.#meta.duration = Infinity;\n      return { ...this.#meta };\n    };\n\n    if (dataSource instanceof ReadableStream) {\n      this.ready = new Response(dataSource)\n        .blob()\n        .then((data) => createImageBitmap(data))\n        .then(initWithImgBitmap);\n    } else if (dataSource instanceof ImageBitmap) {\n      this.ready = Promise.resolve(initWithImgBitmap(dataSource));\n    } else if (\n      Array.isArray(dataSource) &&\n      dataSource.every((it) => it instanceof VideoFrame)\n    ) {\n      this.#frames = dataSource;\n      const frame = this.#frames[0];\n      if (frame == null) throw Error('The frame count must be greater than 0');\n      this.#meta = {\n        width: frame.displayWidth,\n        height: frame.displayHeight,\n        duration: this.#frames.reduce(\n          (acc, cur) => acc + (cur.duration ?? 0),\n          0,\n        ),\n      };\n      this.ready = Promise.resolve({ ...this.#meta, duration: Infinity });\n    } else if ('type' in dataSource) {\n      this.ready = this.#initAnimateImg(\n        dataSource.stream,\n        dataSource.type,\n      ).then(() => ({\n        width: this.#meta.width,\n        height: this.#meta.height,\n        duration: Infinity,\n      }));\n    } else {\n      throw Error('Illegal arguments');\n    }\n  }\n\n  async #initAnimateImg(\n    stream: ReadableStream,\n    type: `image/${AnimateImgType}`,\n  ) {\n    this.#frames = await decodeImg(stream, type);\n    const firstVf = this.#frames[0];\n    if (firstVf == null) throw Error('No frame available in gif');\n\n    this.#meta = {\n      duration: this.#frames.reduce((acc, cur) => acc + (cur.duration ?? 0), 0),\n      width: firstVf.codedWidth,\n      height: firstVf.codedHeight,\n    };\n    Log.info('ImgClip ready:', this.#meta);\n  }\n\n  tickInterceptor: <T extends Awaited<ReturnType<ImgClip['tick']>>>(\n    time: number,\n    tickRet: T,\n  ) => Promise<T> = async (_, tickRet) => tickRet;\n\n  async tick(time: number): Promise<{\n    video: ImageBitmap | VideoFrame;\n    state: 'success';\n  }> {\n    if (this.#img != null) {\n      return await this.tickInterceptor(time, {\n        video: await createImageBitmap(this.#img),\n        state: 'success',\n      });\n    }\n    const tt = time % this.#meta.duration;\n    return await this.tickInterceptor(time, {\n      video: (\n        this.#frames.find(\n          (f) => tt >= f.timestamp && tt <= f.timestamp + (f.duration ?? 0),\n        ) ?? this.#frames[0]\n      ).clone(),\n      state: 'success',\n    });\n  }\n\n  async split(time: number) {\n    await this.ready;\n    if (this.#img != null) {\n      return [\n        new ImgClip(await createImageBitmap(this.#img)),\n        new ImgClip(await createImageBitmap(this.#img)),\n      ] as [this, this];\n    }\n    let hitIdx = -1;\n    for (let i = 0; i < this.#frames.length; i++) {\n      const vf = this.#frames[i];\n      if (time > vf.timestamp) continue;\n      hitIdx = i;\n      break;\n    }\n    if (hitIdx === -1) throw Error('Not found frame by time');\n    const preSlice = this.#frames\n      .slice(0, hitIdx)\n      .map((vf) => new VideoFrame(vf));\n    const postSlice = this.#frames.slice(hitIdx).map(\n      (vf) =>\n        new VideoFrame(vf, {\n          timestamp: vf.timestamp - time,\n        }),\n    );\n    return [new ImgClip(preSlice), new ImgClip(postSlice)] as [this, this];\n  }\n\n  async clone() {\n    await this.ready;\n    const data =\n      this.#img == null\n        ? this.#frames.map((vf) => vf.clone())\n        : await createImageBitmap(this.#img);\n    return new ImgClip(data) as this;\n  }\n\n  destroy(): void {\n    Log.info('ImgClip destroy');\n    this.#img?.close();\n    this.#frames.forEach((f) => f.close());\n  }\n}\n","import {\n  concatPCMFragments,\n  extractPCM4AudioBuffer,\n  ringSliceFloat32Array,\n} from '../av-utils';\nimport { Log } from '@webav/internal-utils';\nimport { DEFAULT_AUDIO_CONF, IClip } from './iclip';\n\ninterface IAudioClipOpts {\n  loop?: boolean;\n  volume?: number;\n}\n\n/**\n * 音频素材，为创建、编辑音视频功能提供音频数据\n *\n * @example\n * new AudioClip((await fetch('<mp3 url>')).body, {\n *   loop: true,\n * }),\n */\nexport class AudioClip implements IClip {\n  static ctx: AudioContext | null = null;\n\n  ready: IClip['ready'];\n\n  #meta = {\n    // 微秒\n    duration: 0,\n    width: 0,\n    height: 0,\n  };\n\n  /**\n   * 音频元信息\n   *\n   * ⚠️ 注意，这里是转换后（标准化）的元信息，非原始音频元信息\n   */\n  get meta() {\n    return {\n      ...this.#meta,\n      sampleRate: DEFAULT_AUDIO_CONF.sampleRate,\n      chanCount: 2,\n    };\n  }\n\n  #chan0Buf = new Float32Array();\n  #chan1Buf = new Float32Array();\n  /**\n   * 获取音频素材完整的 PCM 数据\n   */\n  getPCMData(): Float32Array[] {\n    return [this.#chan0Buf, this.#chan1Buf];\n  }\n\n  #opts;\n\n  /**\n   *\n   * @param dataSource 音频文件流\n   * @param opts 音频配置，控制音量、是否循环\n   */\n  constructor(\n    dataSource: ReadableStream<Uint8Array> | Float32Array[],\n    opts: IAudioClipOpts = {},\n  ) {\n    this.#opts = {\n      loop: false,\n      volume: 1,\n      ...opts,\n    };\n\n    this.ready = this.#init(dataSource).then(() => ({\n      // audio 没有宽高，无需绘制\n      width: 0,\n      height: 0,\n      duration: opts.loop ? Infinity : this.#meta.duration,\n    }));\n  }\n\n  async #init(\n    dataSource: ReadableStream<Uint8Array> | Float32Array[],\n  ): Promise<void> {\n    if (AudioClip.ctx == null) {\n      AudioClip.ctx = new AudioContext({\n        sampleRate: DEFAULT_AUDIO_CONF.sampleRate,\n      });\n    }\n\n    const tStart = performance.now();\n    const pcm =\n      dataSource instanceof ReadableStream\n        ? await parseStream2PCM(dataSource, AudioClip.ctx)\n        : dataSource;\n\n    Log.info('Audio clip decoded complete:', performance.now() - tStart);\n\n    const volume = this.#opts.volume;\n    if (volume !== 1) {\n      for (const chan of pcm)\n        for (let i = 0; i < chan.length; i += 1) chan[i] *= volume;\n    }\n\n    this.#meta.duration = (pcm[0].length / DEFAULT_AUDIO_CONF.sampleRate) * 1e6;\n\n    this.#chan0Buf = pcm[0];\n    // 单声道 转 立体声\n    this.#chan1Buf = pcm[1] ?? this.#chan0Buf;\n\n    Log.info(\n      'Audio clip convert to AudioData, time:',\n      performance.now() - tStart,\n    );\n  }\n\n  /**\n   * 拦截 {@link AudioClip.tick} 方法返回的数据，用于对音频数据二次处理\n   * @param time 调用 tick 的时间\n   * @param tickRet tick 返回的数据\n   *\n   * @see [移除视频绿幕背景](https://webav-tech.github.io/WebAV/demo/3_2-chromakey-video)\n   */\n  tickInterceptor: <T extends Awaited<ReturnType<AudioClip['tick']>>>(\n    time: number,\n    tickRet: T,\n  ) => Promise<T> = async (_, tickRet) => tickRet;\n\n  // 微秒\n  #ts = 0;\n  #frameOffset = 0;\n  /**\n   * 返回上次与当前时刻差对应的音频 PCM 数据；\n   *\n   * 若差值超过 3s 或当前时间小于上次时间，则重置状态\n   * @example\n   * tick(0) // => []\n   * tick(1e6) // => [leftChanPCM(1s), rightChanPCM(1s)]\n   *\n   */\n  async tick(time: number): Promise<{\n    audio: Float32Array[];\n    state: 'success' | 'done';\n  }> {\n    if (!this.#opts.loop && time >= this.#meta.duration) {\n      // 待观察：如果time跨度较大，返回done，理论上会丢失一些音频帧\n      return await this.tickInterceptor(time, { audio: [], state: 'done' });\n    }\n\n    const deltaTime = time - this.#ts;\n\n    // reset\n    if (time < this.#ts || deltaTime > 3e6) {\n      this.#ts = time;\n      this.#frameOffset = Math.ceil(\n        (this.#ts / 1e6) * DEFAULT_AUDIO_CONF.sampleRate,\n      );\n      return await this.tickInterceptor(time, {\n        audio: [new Float32Array(0), new Float32Array(0)],\n        state: 'success',\n      });\n    }\n\n    this.#ts = time;\n    const frameCnt = Math.ceil(\n      (deltaTime / 1e6) * DEFAULT_AUDIO_CONF.sampleRate,\n    );\n    const endIdx = this.#frameOffset + frameCnt;\n    const audio = this.#opts.loop\n      ? [\n          ringSliceFloat32Array(this.#chan0Buf, this.#frameOffset, endIdx),\n          ringSliceFloat32Array(this.#chan1Buf, this.#frameOffset, endIdx),\n        ]\n      : [\n          this.#chan0Buf.slice(this.#frameOffset, endIdx),\n          this.#chan1Buf.slice(this.#frameOffset, endIdx),\n        ];\n    this.#frameOffset = endIdx;\n\n    return await this.tickInterceptor(time, { audio, state: 'success' });\n  }\n\n  /**\n   * 按指定时间切割，返回前后两个音频素材\n   * @param time 时间，单位微秒\n   */\n  async split(time: number) {\n    await this.ready;\n    const frameCnt = Math.ceil((time / 1e6) * DEFAULT_AUDIO_CONF.sampleRate);\n    const preSlice = new AudioClip(\n      this.getPCMData().map((chan) => chan.slice(0, frameCnt)),\n      this.#opts,\n    );\n    const postSlice = new AudioClip(\n      this.getPCMData().map((chan) => chan.slice(frameCnt)),\n      this.#opts,\n    );\n    return [preSlice, postSlice] as [this, this];\n  }\n\n  async clone() {\n    await this.ready;\n    const clip = new AudioClip(this.getPCMData(), this.#opts) as this;\n    await clip.ready;\n    return clip;\n  }\n\n  /**\n   * 销毁实例，释放资源\n   */\n  destroy(): void {\n    this.#chan0Buf = new Float32Array(0);\n    this.#chan1Buf = new Float32Array(0);\n    Log.info('---- audioclip destroy ----');\n  }\n}\n\n/**\n * 拼接多个 AudioClip\n */\nexport async function concatAudioClip(\n  clips: AudioClip[],\n  opts?: IAudioClipOpts,\n) {\n  const bufs: Float32Array[][] = [];\n  for (const clip of clips) {\n    await clip.ready;\n    bufs.push(clip.getPCMData());\n  }\n  return new AudioClip(concatPCMFragments(bufs), opts);\n}\n\nasync function parseStream2PCM(\n  stream: ReadableStream<Uint8Array>,\n  ctx: AudioContext | OfflineAudioContext,\n): Promise<Float32Array[]> {\n  const buf = await new Response(stream).arrayBuffer();\n  return extractPCM4AudioBuffer(await ctx.decodeAudioData(buf));\n}\n","import { autoReadStream } from '@webav/internal-utils';\nimport { IClip } from './iclip';\n\n/**\n * 包装实时音视频流，仅用于 [AVCanvas](../../av-canvas/classes/AVCanvas.html)\n *\n * ⚠️ 不可用于 {@link Combinator} ，因为后台合成视频的速度是快于物理时间的，实时流无法提供非实时的数据\n *\n * @example\n * const spr = new VisibleSprite(\n *   new MediaStreamClip(\n *     await navigator.mediaDevices.getUserMedia({ video: true, audio: true, }),\n *   ),\n * );\n * await avCvs.addSprite(spr);\n */\nexport class MediaStreamClip implements IClip {\n  static ctx: AudioContext | null = null;\n\n  ready: IClip['ready'];\n\n  #meta = {\n    // 微秒\n    duration: 0,\n    width: 0,\n    height: 0,\n  };\n\n  get meta() {\n    return {\n      ...this.#meta,\n    };\n  }\n\n  #stopRenderCvs = () => {};\n\n  /**\n   * 实时流的音轨\n   */\n  readonly audioTrack: MediaStreamAudioTrack | null;\n\n  #cvs: OffscreenCanvas | null = null;\n\n  #ms: MediaStream;\n  constructor(ms: MediaStream) {\n    this.#ms = ms;\n    this.audioTrack = ms.getAudioTracks()[0] ?? null;\n    this.#meta.duration = Infinity;\n    const videoTrack = ms.getVideoTracks()[0];\n    if (videoTrack != null) {\n      videoTrack.contentHint = 'motion';\n      this.ready = new Promise((resolve) => {\n        this.#stopRenderCvs = renderVideoTrackToCvs(videoTrack, (cvs) => {\n          this.#meta.width = cvs.width;\n          this.#meta.height = cvs.height;\n          this.#cvs = cvs;\n          resolve(this.meta);\n        });\n      });\n    } else {\n      this.ready = Promise.resolve(this.meta);\n    }\n  }\n\n  async tick(): Promise<{\n    video: ImageBitmap | null;\n    audio: Float32Array[];\n    state: 'success';\n  }> {\n    return {\n      video: this.#cvs == null ? null : await createImageBitmap(this.#cvs),\n      audio: [],\n      state: 'success',\n    };\n  }\n\n  async split() {\n    return [await this.clone(), await this.clone()] as [this, this];\n  }\n\n  async clone() {\n    return new MediaStreamClip(this.#ms.clone()) as this;\n  }\n\n  destroy(): void {\n    this.#ms.getTracks().forEach((t) => t.stop());\n    this.#stopRenderCvs();\n  }\n}\n\nfunction renderVideoTrackToCvs(\n  track: MediaStreamVideoTrack,\n  onOffscreenCanvasReady: (cvs: OffscreenCanvas) => void,\n) {\n  let emitFF = false;\n  let cvsCtx: OffscreenCanvasRenderingContext2D;\n  return autoReadStream(\n    new MediaStreamTrackProcessor({\n      track,\n    }).readable,\n    {\n      onChunk: async (frame) => {\n        if (!emitFF) {\n          const { displayHeight, displayWidth } = frame;\n          const width = displayWidth ?? 0;\n          const height = displayHeight ?? 0;\n          const cvs = new OffscreenCanvas(width, height);\n          cvsCtx = cvs.getContext('2d')!;\n          onOffscreenCanvasReady(cvs);\n          emitFF = true;\n        }\n        cvsCtx.drawImage(frame, 0, 0);\n        frame.close();\n      },\n      onDone: async () => {},\n    },\n  );\n}\n","import { Log } from '@webav/internal-utils';\nimport { IClip } from './iclip';\n\ninterface IEmbedSubtitlesOpts {\n  color?: string;\n  textBgColor?: string | null;\n  type?: 'srt';\n  fontFamily?: string;\n  fontSize?: number;\n  letterSpacing?: string | null;\n  // 字幕偏离底部的距离\n  bottomOffset?: number;\n  strokeStyle?: string;\n  lineWidth?: number | null;\n  lineCap?: CanvasLineCap | null;\n  lineJoin?: CanvasLineJoin | null;\n  textShadow?: {\n    offsetX: number;\n    offsetY: number;\n    blur: number;\n    color: string;\n  };\n  videoWidth: number;\n  videoHeight: number;\n}\n\ndeclare global {\n  interface OffscreenCanvasRenderingContext2D {\n    letterSpacing: string;\n  }\n}\n\ninterface SubtitleStruct {\n  start: number;\n  end: number;\n  text: string;\n}\n\n/**\n * 嵌入式字幕，将字幕（目前仅支持 SRT 格式）嵌入视频画面中\n *\n * @example\n * const es = new EmbedSubtitlesClip(srtSubtitleStr, {\n *   videoWidth: 1280,\n *   videoHeight: 720,\n *   fontFamily: 'Noto Sans SC',\n *   color: 'white',\n * });\n */\nexport class EmbedSubtitlesClip implements IClip {\n  ready: IClip['ready'];\n\n  #subtitles: SubtitleStruct[] = [];\n\n  #meta = {\n    width: 0,\n    height: 0,\n    duration: 0,\n  };\n\n  get meta() {\n    return { ...this.#meta };\n  }\n\n  #opts: Required<IEmbedSubtitlesOpts> = {\n    color: '#FFF',\n    textBgColor: null,\n    type: 'srt',\n    fontSize: 30,\n    letterSpacing: null,\n    bottomOffset: 30,\n    fontFamily: 'Noto Sans SC',\n    strokeStyle: '#000',\n    lineWidth: null,\n    lineCap: null,\n    lineJoin: null,\n    textShadow: {\n      offsetX: 2,\n      offsetY: 2,\n      blur: 4,\n      color: '#000',\n    },\n    videoWidth: 1280,\n    videoHeight: 720,\n  };\n\n  #cvs: OffscreenCanvas;\n  #ctx: OffscreenCanvasRenderingContext2D;\n\n  #lastVF: VideoFrame | null = null;\n\n  #lineHeight = 0;\n  #linePadding = 0;\n\n  constructor(content: string | SubtitleStruct[], opts: IEmbedSubtitlesOpts) {\n    this.#subtitles = Array.isArray(content)\n      ? content\n      : parseSrt(content).map(({ start, end, text }) => ({\n          start: start * 1e6,\n          end: end * 1e6,\n          text,\n        }));\n    if (this.#subtitles.length === 0) throw Error('No subtitles content');\n\n    this.#opts = Object.assign(this.#opts, opts);\n    // 如果需要绘制背景，则需要给文字添加边距\n    this.#linePadding =\n      opts.textBgColor == null ? 0 : (opts.fontSize ?? 50) * 0.2;\n\n    const { fontSize, fontFamily, videoWidth, videoHeight, letterSpacing } =\n      this.#opts;\n    this.#lineHeight = fontSize + this.#linePadding * 2;\n    this.#cvs = new OffscreenCanvas(videoWidth, videoHeight);\n    this.#ctx = this.#cvs.getContext('2d')!;\n    this.#ctx.font = `${fontSize}px ${fontFamily}`;\n    this.#ctx.textAlign = 'center';\n    this.#ctx.textBaseline = 'top';\n    this.#ctx.letterSpacing = letterSpacing ?? '0px';\n\n    this.#meta = {\n      width: videoWidth,\n      height: videoHeight,\n      duration: this.#subtitles.at(-1)?.end ?? 0,\n    };\n    // 字幕的宽高 由视频画面内容决定\n    this.ready = Promise.resolve(this.meta);\n  }\n\n  #renderTxt(txt: string) {\n    Log.info('renderTxt', txt);\n    const lines = txt\n      .split('\\n')\n      .reverse()\n      .map((t) => t.trim());\n\n    const { width, height } = this.#cvs;\n\n    const {\n      color,\n      fontSize,\n      textBgColor,\n      textShadow,\n      strokeStyle,\n      lineWidth,\n      lineCap,\n      lineJoin,\n      bottomOffset,\n    } = this.#opts;\n    const ctx = this.#ctx;\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.globalAlpha = 0.6;\n    // 测试canvas背景\n    // ctx.fillStyle = 'red'\n    // ctx.fillRect(0, 0, this.#cvs.width, this.#cvs.height)\n\n    let bottomDistance = bottomOffset;\n    for (const lineStr of lines) {\n      const txtMeas = ctx.measureText(lineStr);\n      const centerX = width / 2;\n      if (textBgColor != null) {\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n        ctx.shadowBlur = 0;\n        // 字幕背景\n        ctx.fillStyle = textBgColor;\n        ctx.globalAlpha = 0.5;\n        ctx.fillRect(\n          centerX - txtMeas.actualBoundingBoxLeft - this.#linePadding,\n          height - bottomDistance - this.#lineHeight,\n          txtMeas.width + this.#linePadding * 2,\n          this.#lineHeight,\n        );\n      } else {\n      }\n\n      ctx.shadowColor = textShadow.color;\n      ctx.shadowOffsetX = textShadow.offsetX;\n      ctx.shadowOffsetY = textShadow.offsetY;\n      ctx.shadowBlur = textShadow.blur;\n\n      ctx.globalAlpha = 1;\n\n      if (strokeStyle != null) {\n        ctx.lineWidth = lineWidth ?? fontSize / 6;\n        if (lineCap != null) ctx.lineCap = lineCap;\n        if (lineJoin != null) ctx.lineJoin = lineJoin;\n        ctx.strokeStyle = strokeStyle;\n        ctx.strokeText(\n          lineStr,\n          centerX,\n          height - bottomDistance - this.#lineHeight + this.#linePadding,\n        );\n      }\n\n      ctx.fillStyle = color;\n      ctx.fillText(\n        lineStr,\n        centerX,\n        height - bottomDistance - this.#lineHeight + this.#linePadding,\n      );\n\n      // 多行，底部偏移距离叠加\n      bottomDistance += this.#lineHeight + fontSize * 0.2;\n    }\n  }\n\n  /**\n   * @see {@link IClip.tick}\n   */\n  async tick(time: number): Promise<{\n    video?: VideoFrame;\n    state: 'done' | 'success';\n  }> {\n    if (\n      this.#lastVF != null &&\n      time >= this.#lastVF.timestamp &&\n      time <= this.#lastVF.timestamp + (this.#lastVF.duration ?? 0)\n    ) {\n      return { video: this.#lastVF.clone(), state: 'success' };\n    }\n\n    let i = 0;\n    for (; i < this.#subtitles.length; i += 1) {\n      if (time <= this.#subtitles[i].end) break;\n    }\n\n    const it = this.#subtitles[i] ?? this.#subtitles.at(-1);\n    if (time > it.end) return { state: 'done' };\n    if (time < it.start) {\n      // 此时无字幕内容，清空画布\n      this.#ctx.clearRect(0, 0, this.#cvs.width, this.#cvs.height);\n      const vf = new VideoFrame(this.#cvs, {\n        timestamp: time,\n        // 直到下个字幕出现的时机\n        duration: it.start - time,\n      });\n      this.#lastVF?.close();\n      this.#lastVF = vf;\n\n      return { video: vf.clone(), state: 'success' };\n    }\n\n    this.#renderTxt(it.text);\n\n    const vf = new VideoFrame(this.#cvs, {\n      timestamp: time,\n      duration: it.end - time,\n    });\n    this.#lastVF?.close();\n    this.#lastVF = vf;\n\n    return { video: vf.clone(), state: 'success' };\n  }\n\n  /**\n   * @see {@link IClip.split}\n   */\n  async split(time: number) {\n    await this.ready;\n    let hitIdx = -1;\n    for (let i = 0; i < this.#subtitles.length; i++) {\n      const sub = this.#subtitles[i];\n      if (time > sub.start) continue;\n      hitIdx = i;\n      break;\n    }\n    if (hitIdx === -1) throw Error('Not found subtitle by time');\n    const preSlice = this.#subtitles.slice(0, hitIdx).map((s) => ({ ...s }));\n    let preLastIt = preSlice.at(-1);\n    let postFirstIt = null;\n    // 切割时间命中字幕区间，需要将当前字幕元素拆成前后两份\n    if (preLastIt != null && preLastIt.end > time) {\n      postFirstIt = {\n        start: 0,\n        end: preLastIt.end - time,\n        text: preLastIt.text,\n      };\n\n      preLastIt.end = time;\n    }\n    const postSlice = this.#subtitles\n      .slice(hitIdx)\n      .map((s) => ({ ...s, start: s.start - time, end: s.end - time }));\n    if (postFirstIt != null) postSlice.unshift(postFirstIt);\n    return [\n      new EmbedSubtitlesClip(preSlice, this.#opts),\n      new EmbedSubtitlesClip(postSlice, this.#opts),\n    ] as [this, this];\n  }\n\n  /**\n   * @see {@link IClip.clone}\n   */\n  async clone() {\n    return new EmbedSubtitlesClip(this.#subtitles.slice(0), this.#opts) as this;\n  }\n\n  /**\n   * 通过时间戳，修改字幕内容\n   * @param subtitle SubtitleStruct\n   * @returns\n   */\n  updateSubtitle(subtitle: SubtitleStruct) {\n    this.#subtitles.forEach((s) => {\n      if (s.start === subtitle.start && s.end === subtitle.end) {\n        s.text = subtitle.text;\n      }\n    });\n  }\n\n  /**\n   * 获取字幕距离底部的偏移距离\n   * @returns 当前的bottomOffset值（像素）\n   */\n  getBottomOffset(): number {\n    return this.#opts.bottomOffset;\n  }\n\n  /**\n   * 设置字幕距离底部的偏移距离\n   * @param value 新的bottomOffset值（像素）\n   */\n  setBottomOffset(value: number): void {\n    if (typeof value !== 'number' || value < 0) {\n      throw new Error('bottomOffset must be a non-negative number');\n    }\n    this.#opts.bottomOffset = value;\n    // 清除上一帧缓存，确保下次tick时使用新的bottomOffset\n    this.#lastVF?.close();\n    this.#lastVF = null;\n  }\n\n  /**\n   * @see {@link IClip.destroy}\n   */\n  destroy() {\n    this.#lastVF?.close();\n  }\n}\n\n// SRT字幕格式 https://www.cnblogs.com/tocy/p/subtitle-format-srt.html\nfunction srtTimeToSeconds(time: string) {\n  const match = time.match(/(\\d{2}):(\\d{2}):(\\d{2}),(\\d{3})/);\n  if (match == null) throw Error(`time format error: ${time}`);\n\n  const hours = Number(match[1]);\n  const minutes = Number(match[2]);\n  const seconds = Number(match[3]);\n  const milliseconds = Number(match[4]);\n\n  return hours * 60 * 60 + minutes * 60 + seconds + milliseconds / 1000;\n}\n\nfunction parseSrt(srt: string) {\n  return (\n    srt\n      .split(/\\r|\\n/)\n      .map((s) => s.trim())\n      .filter((str) => str.length > 0)\n      // 匹配时间戳标记行，匹配失败的为字幕内容\n      .map((s) => ({\n        lineStr: s,\n        match: s.match(\n          /(\\d{2}:\\d{2}:\\d{2},\\d{3}) --> (\\d{2}:\\d{2}:\\d{2},\\d{3})/,\n        ),\n      }))\n      // 过滤掉时间上一行的数字标记\n      .filter(\n        ({ lineStr }, idx, source) =>\n          !(/^\\d+$/.test(lineStr) && source[idx + 1]?.match != null),\n      )\n      // 按时间标记行聚合，拼接字幕内容到 text 字段\n      .reduce(\n        (acc, { lineStr, match }) => {\n          if (match == null) {\n            const last = acc.at(-1);\n            if (last == null) return acc;\n\n            last.text += last.text.length === 0 ? lineStr : `\\n${lineStr}`;\n          } else {\n            acc.push({\n              start: srtTimeToSeconds(match[1]),\n              end: srtTimeToSeconds(match[2]),\n              text: '',\n            });\n          }\n\n          return acc;\n        },\n        [] as Array<{\n          start: number;\n          end: number;\n          text: string;\n        }>,\n      )\n  );\n}\n","import mp4box, {\n  MP4ArrayBuffer,\n  MP4File,\n  MP4Info,\n  MP4Sample,\n} from '@webav/mp4box.js';\n\n/**\n * 将原始字节流转换成 MP4Sample 流\n */\nexport class SampleTransform {\n  readable: ReadableStream<\n    | {\n        chunkType: 'ready';\n        data: { info: MP4Info; file: MP4File };\n      }\n    | {\n        chunkType: 'samples';\n        data: { id: number; type: 'video' | 'audio'; samples: MP4Sample[] };\n      }\n  >;\n\n  writable: WritableStream<Uint8Array>;\n\n  #inputBufOffset = 0;\n\n  constructor() {\n    const file = mp4box.createFile();\n    let streamCancelled = false;\n    this.readable = new ReadableStream(\n      {\n        start: (ctrl) => {\n          file.onReady = (info) => {\n            const vTrackId = info.videoTracks[0]?.id;\n            if (vTrackId != null)\n              file.setExtractionOptions(vTrackId, 'video', { nbSamples: 100 });\n\n            const aTrackId = info.audioTracks[0]?.id;\n            if (aTrackId != null)\n              file.setExtractionOptions(aTrackId, 'audio', { nbSamples: 100 });\n\n            ctrl.enqueue({ chunkType: 'ready', data: { info, file } });\n            file.start();\n          };\n\n          const releasedCnt: Record<number, number> = {};\n          file.onSamples = (id, type, samples) => {\n            ctrl.enqueue({\n              chunkType: 'samples',\n              data: { id, type, samples: samples.map((s) => ({ ...s })) },\n            });\n            releasedCnt[id] = (releasedCnt[id] ?? 0) + samples.length;\n            file.releaseUsedSamples(id, releasedCnt[id]);\n          };\n\n          file.onFlush = () => {\n            ctrl.close();\n          };\n        },\n        cancel: () => {\n          file.stop();\n          streamCancelled = true;\n        },\n      },\n      {\n        // 每条消息 100 个 samples\n        highWaterMark: 50,\n      },\n    );\n\n    this.writable = new WritableStream({\n      write: async (ui8Arr) => {\n        if (streamCancelled) {\n          this.writable.abort();\n          return;\n        }\n\n        const inputBuf = ui8Arr.buffer as MP4ArrayBuffer;\n        inputBuf.fileStart = this.#inputBufOffset;\n        this.#inputBufOffset += inputBuf.byteLength;\n        file.appendBuffer(inputBuf);\n      },\n      close: () => {\n        file.flush();\n        file.stop();\n        file.onFlush?.();\n      },\n    });\n  }\n}\n","import mp4box, {\n  MP4File,\n  MP4Sample,\n  SampleOpts,\n  TrakBoxParser,\n} from '@webav/mp4box.js';\nimport { autoReadStream, file2stream, Log } from '@webav/internal-utils';\nimport {\n  extractPCM4AudioData,\n  extractPCM4AudioBuffer,\n  mixinPCM,\n  ringSliceFloat32Array,\n  concatPCMFragments,\n} from '../av-utils';\nimport { DEFAULT_AUDIO_CONF } from '../clips';\nimport { SampleTransform } from './sample-transform';\nimport { extractFileConfig } from './mp4box-utils';\nimport { tmpfile, write } from 'opfs-tools';\n\nfunction fixMP4BoxFileDuration(\n  inMP4File: MP4File,\n): () => Promise<ReadableStream<Uint8Array> | null> {\n  let sendedBoxIdx = 0;\n  const boxes = inMP4File.boxes;\n  const tracks: Array<{ track: TrakBoxParser; id: number }> = [];\n  let totalDuration = 0;\n\n  async function write2TmpFile() {\n    const buf = box2Buf(boxes, sendedBoxIdx);\n    sendedBoxIdx = boxes.length;\n    // 释放引用，避免内存泄露\n    // todo: use unsafeReleaseMP4BoxFile\n    tracks.forEach(({ track, id }) => {\n      const s = track.samples.at(-1);\n      if (s != null)\n        totalDuration = Math.max(totalDuration, s.cts + s.duration);\n\n      inMP4File.releaseUsedSamples(id, track.samples.length);\n      track.samples = [];\n    });\n    inMP4File.mdats = [];\n    inMP4File.moofs = [];\n    if (buf != null) await tmpFileWriter?.write(buf);\n  }\n\n  let moovPrevBoxes: typeof boxes = [];\n  function moovBoxReady() {\n    if (moovPrevBoxes.length > 0) return true;\n\n    const moovIdx = boxes.findIndex((box) => box.type === 'moov');\n    if (moovIdx === -1) return false;\n\n    moovPrevBoxes = boxes.slice(0, moovIdx + 1);\n    sendedBoxIdx = moovIdx + 1;\n\n    if (tracks.length === 0) {\n      for (let i = 1; true; i += 1) {\n        const track = inMP4File.getTrackById(i);\n        if (track == null) break;\n        tracks.push({ track, id: i });\n      }\n    }\n\n    return true;\n  }\n\n  let timerId = 0;\n  // 把 moov 之外的 box 先写入临时文件，待更新 duration 之后再拼接临时文件\n  const postFile = tmpfile();\n  let tmpFileWriter: Awaited<\n    ReturnType<ReturnType<typeof tmpfile>['createWriter']>\n  > | null = null;\n\n  const initPromise = (async () => {\n    tmpFileWriter = await postFile.createWriter();\n\n    timerId = self.setInterval(() => {\n      if (!moovBoxReady()) return;\n      write2TmpFile();\n    }, 100);\n  })();\n\n  let stoped = false;\n  return async () => {\n    if (stoped) throw Error('File exported');\n    stoped = true;\n\n    await initPromise;\n    clearInterval(timerId);\n\n    if (!moovBoxReady() || tmpFileWriter == null) return null;\n    inMP4File.flush();\n    await write2TmpFile();\n    await tmpFileWriter?.close();\n\n    const moov = moovPrevBoxes.find((box) => box.type === 'moov') as\n      | typeof inMP4File.moov\n      | undefined;\n    if (moov == null) return null;\n\n    moov.mvhd.duration = totalDuration;\n\n    const rsFile = tmpfile();\n    const buf = box2Buf(moovPrevBoxes, 0)!;\n    await write(rsFile, buf);\n    await write(rsFile, postFile, { overwrite: false });\n\n    return await rsFile.stream();\n  };\n\n  function box2Buf(source: typeof boxes, startIdx: number): Uint8Array | null {\n    if (startIdx >= source.length) return null;\n\n    const ds = new mp4box.DataStream();\n    ds.endianness = mp4box.DataStream.BIG_ENDIAN;\n\n    for (let i = startIdx; i < source.length; i++) {\n      if (source[i] === null) continue;\n      source[i].write(ds);\n      delete source[i];\n    }\n    return new Uint8Array(ds.buffer);\n  }\n}\n\n/**\n * EncodedAudioChunk | EncodedVideoChunk 转换为 MP4 addSample 需要的参数\n */\nfunction chunk2MP4SampleOpts(\n  chunk: EncodedAudioChunk | EncodedVideoChunk,\n): SampleOpts & {\n  data: ArrayBuffer;\n} {\n  const buf = new ArrayBuffer(chunk.byteLength);\n  chunk.copyTo(buf);\n  const dts = chunk.timestamp;\n  return {\n    duration: chunk.duration ?? 0,\n    dts,\n    cts: dts,\n    is_sync: chunk.type === 'key',\n    data: buf,\n  };\n}\n\n/**\n * 快速拼接多个mp4 文件流，要求所有 mp4 的属性一致，\n * 属性包括（不限于）：音视频编码格式、分辨率、采样率\n *\n * @param streams 一个包含 Uint8Array 的可读流数组。\n * @returns 返回一个 Promise，该 Promise 在解析时返回一个包含合并后的 MP4 数据的可读流。\n * @throws 如果无法从流生成文件，将抛出错误。\n *\n * @example\n * const streams = [stream1, stream2, stream3];\n * const resultStream = await fastConcatMP4(streams);\n */\nexport async function fastConcatMP4(\n  streams: ReadableStream<Uint8Array>[],\n): Promise<ReadableStream<Uint8Array>> {\n  const outfile = mp4box.createFile();\n\n  const dumpFile = fixMP4BoxFileDuration(outfile);\n  await concatStreamsToMP4BoxFile(streams, outfile);\n  const outStream = await dumpFile();\n  if (outStream == null) throw Error('Can not generate file from streams');\n  return outStream;\n}\n\nasync function concatStreamsToMP4BoxFile(\n  streams: ReadableStream<Uint8Array>[],\n  outfile: MP4File,\n) {\n  let vTrackId = 0;\n  let vDTS = 0;\n  let vCTS = 0;\n  let aTrackId = 0;\n  let aDTS = 0;\n  let aCTS = 0;\n  // ts bug, 不能正确识别类型\n  let lastVSamp: any = null;\n  let lastASamp: any = null;\n  for (const stream of streams) {\n    await new Promise<void>(async (resolve) => {\n      autoReadStream(stream.pipeThrough(new SampleTransform()), {\n        onDone: resolve,\n        onChunk: async ({ chunkType, data }) => {\n          if (chunkType === 'ready') {\n            const { videoTrackConf, audioTrackConf } = extractFileConfig(\n              data.file,\n              data.info,\n            );\n            if (vTrackId === 0 && videoTrackConf != null) {\n              vTrackId = outfile.addTrack(videoTrackConf);\n            }\n            if (aTrackId === 0 && audioTrackConf != null) {\n              aTrackId = outfile.addTrack(audioTrackConf);\n            }\n          } else if (chunkType === 'samples') {\n            const { type, samples } = data;\n            const trackId = type === 'video' ? vTrackId : aTrackId;\n            const offsetDTS = type === 'video' ? vDTS : aDTS;\n            const offsetCTS = type === 'video' ? vCTS : aCTS;\n\n            samples.forEach((s) => {\n              outfile.addSample(trackId, s.data, {\n                duration: s.duration,\n                dts: s.dts + offsetDTS,\n                cts: s.cts + offsetCTS,\n                is_sync: s.is_sync,\n              });\n            });\n\n            const lastSamp = samples.at(-1);\n            if (lastSamp == null) return;\n            if (type === 'video') {\n              lastVSamp = lastSamp;\n            } else if (type === 'audio') {\n              lastASamp = lastSamp;\n            }\n          }\n        },\n      });\n    });\n    if (lastVSamp != null) {\n      vDTS += lastVSamp.dts;\n      vCTS += lastVSamp.cts;\n    }\n    if (lastASamp != null) {\n      aDTS += lastASamp.dts;\n      aCTS += lastASamp.cts;\n    }\n  }\n}\n\n/**\n * 为 WebAV 生成的 fmp4 文件设置正确的时长值\n */\nexport async function fixFMP4Duration(\n  stream: ReadableStream<Uint8Array>,\n): Promise<ReadableStream<Uint8Array>> {\n  return await fastConcatMP4([stream]);\n}\n\n/**\n * 创建 MP4 音频样本解码器。\n * @param adConf - 音频解码器配置参数 {@link AudioDecoderConfig}。\n * @returns 返回一个对象，包含 `decode` 和 `close` 方法。\n * - `decode` 方法用于解码 MP4 音频样本，返回解码后的音频数据数组。\n * - `close` 方法用于关闭音频解码器。\n */\nfunction createMP4AudioSampleDecoder(\n  adConf: Parameters<AudioDecoder['configure']>[0],\n) {\n  let cacheAD: AudioData[] = [];\n  const adDecoder = new AudioDecoder({\n    output: (ad) => {\n      cacheAD.push(ad);\n    },\n    error: Log.error,\n  });\n  adDecoder.configure(adConf);\n\n  return {\n    decode: async (ss: MP4Sample[]) => {\n      ss.forEach((s) => {\n        adDecoder.decode(\n          new EncodedAudioChunk({\n            type: s.is_sync ? 'key' : 'delta',\n            timestamp: (1e6 * s.cts) / s.timescale,\n            duration: (1e6 * s.duration) / s.timescale,\n            data: s.data,\n          }),\n        );\n      });\n\n      await adDecoder.flush();\n\n      const rs = cacheAD;\n      cacheAD = [];\n\n      return rs;\n    },\n    close: () => {\n      adDecoder.close();\n    },\n  };\n}\n\n// 音频编码与解码API有很大区别，\n// 是因为编码中途调用 AudioEncoder.flush ，会导致声音听起来卡顿\nfunction createMP4AudioSampleEncoder(\n  aeConf: Parameters<AudioEncoder['configure']>[0],\n  onOutput: (s: ReturnType<typeof chunk2MP4SampleOpts>) => void,\n) {\n  const encoderConf = {\n    codec: aeConf.codec,\n    sampleRate: aeConf.sampleRate,\n    numberOfChannels: aeConf.numberOfChannels,\n  } as const;\n\n  const adEncoder = new AudioEncoder({\n    output: (chunk) => {\n      onOutput(chunk2MP4SampleOpts(chunk));\n    },\n    error: (err) => {\n      Log.error('AudioEncoder error:', err, ', config:', encoderConf);\n    },\n  });\n\n  adEncoder.configure(encoderConf);\n\n  // 保留一个音频数据，用于最后做声音淡出\n  let lastData: { data: Float32Array; ts: number } | null = null;\n\n  function createAD(data: Float32Array, ts: number) {\n    return new AudioData({\n      timestamp: ts,\n      numberOfChannels: aeConf.numberOfChannels,\n      numberOfFrames: data.length / aeConf.numberOfChannels,\n      sampleRate: aeConf.sampleRate,\n      format: 'f32-planar',\n      data,\n    });\n  }\n  return {\n    encode: async (data: Float32Array, ts: number) => {\n      if (lastData != null) {\n        adEncoder.encode(createAD(lastData.data, lastData.ts));\n      }\n      lastData = { data, ts };\n    },\n    stop: async () => {\n      if (lastData != null) {\n        // 副作用修改数据\n        audioFade(lastData.data, aeConf.numberOfChannels, aeConf.sampleRate);\n        adEncoder.encode(createAD(lastData.data, lastData.ts));\n        lastData = null;\n      }\n      await adEncoder.flush();\n      adEncoder.close();\n    },\n  };\n}\n\n/**\n * 音频线性淡出，避免 POP 声\n * 副作用调整音量值\n */\nfunction audioFade(pcmData: Float32Array, chanCnt: number, sampleRate: number) {\n  const dataLen = pcmData.length - 1;\n  // 避免超出边界，最长 500ms 的淡出时间\n  const fadeLen = Math.min(sampleRate / 2, dataLen);\n  for (let i = 0; i < fadeLen; i++) {\n    for (let j = 1; j <= chanCnt; j++) {\n      // 从尾部开始，调整每个声道音量值\n      pcmData[Math.floor(dataLen / j) - i] *= i / fadeLen;\n    }\n  }\n}\n\n/**\n * 视频配音；混合 MP4 与音频文件，仅重编码音频，视频轨道不变\n * @param mp4Stream - MP4 流\n * @param audio - 音频信息\n * @param audio.stream - 音频数据流\n * @param audio.volume - 音频音量\n * @param audio.loop - 音频时长小于视频时，是否循环使用音频流\n * @returns 输出混合后的音频流\n */\nexport function mixinMP4AndAudio(\n  mp4Stream: ReadableStream<Uint8Array>,\n  audio: {\n    stream: ReadableStream<Uint8Array>;\n    volume: number;\n    loop: boolean;\n  },\n) {\n  Log.info('mixinMP4AndAudio, opts:', {\n    volume: audio.volume,\n    loop: audio.loop,\n  });\n\n  const outfile = mp4box.createFile();\n  const { stream: outStream, stop: stopOut } = file2stream(outfile, 500);\n\n  let audioSampleDecoder: ReturnType<\n    typeof createMP4AudioSampleDecoder\n  > | null = null;\n\n  let audioSampleEncoder: ReturnType<\n    typeof createMP4AudioSampleEncoder\n  > | null = null;\n\n  let inputAudioPCM: Float32Array[] = [];\n\n  let vTrackId = 0;\n  let aTrackId = 0;\n  let audioOffset = 0;\n  let mp4HasAudio = true;\n  let sampleRate = DEFAULT_AUDIO_CONF.sampleRate as number;\n  autoReadStream(mp4Stream.pipeThrough(new SampleTransform()), {\n    onDone: async () => {\n      await audioSampleEncoder?.stop();\n      audioSampleDecoder?.close();\n      stopOut();\n    },\n    onChunk: async ({ chunkType, data }) => {\n      if (chunkType === 'ready') {\n        const { videoTrackConf, audioTrackConf, audioDecoderConf } =\n          extractFileConfig(data.file, data.info);\n        if (vTrackId === 0 && videoTrackConf != null) {\n          vTrackId = outfile.addTrack(videoTrackConf);\n        }\n\n        const safeAudioTrackConf = audioTrackConf ?? {\n          timescale: 1e6,\n          samplerate: sampleRate,\n          channel_count: DEFAULT_AUDIO_CONF.channelCount,\n          hdlr: 'soun',\n          name: 'SoundHandler',\n          type: 'mp4a',\n        };\n        if (aTrackId === 0) {\n          aTrackId = outfile.addTrack(safeAudioTrackConf);\n          sampleRate = audioTrackConf?.samplerate ?? sampleRate;\n          mp4HasAudio = audioTrackConf == null ? false : true;\n        }\n        const audioCtx = new AudioContext({ sampleRate });\n        inputAudioPCM = extractPCM4AudioBuffer(\n          await audioCtx.decodeAudioData(\n            await new Response(audio.stream).arrayBuffer(),\n          ),\n        );\n\n        if (audioDecoderConf != null) {\n          audioSampleDecoder = createMP4AudioSampleDecoder(audioDecoderConf);\n        }\n        audioSampleEncoder = createMP4AudioSampleEncoder(\n          audioDecoderConf ?? {\n            codec:\n              safeAudioTrackConf.type === 'mp4a'\n                ? DEFAULT_AUDIO_CONF.codec\n                : safeAudioTrackConf.type,\n            numberOfChannels: safeAudioTrackConf.channel_count,\n            sampleRate: safeAudioTrackConf.samplerate,\n          },\n          (s) => outfile.addSample(aTrackId, s.data, s),\n        );\n      } else if (chunkType === 'samples') {\n        const { id, type, samples } = data;\n        if (type === 'video') {\n          samples.forEach((s) => outfile.addSample(id, s.data, s));\n\n          if (!mp4HasAudio) await addInputAudio2Track(samples);\n          return;\n        }\n\n        if (type === 'audio') await mixinAudioSampleAndInputPCM(samples);\n      }\n    },\n  });\n\n  function getInputAudioSlice(len: number) {\n    const rs = inputAudioPCM.map((chanBuf) =>\n      audio.loop\n        ? ringSliceFloat32Array(chanBuf, audioOffset, audioOffset + len)\n        : chanBuf.slice(audioOffset, audioOffset + len),\n    );\n    audioOffset += len;\n\n    if (audio.volume !== 1) {\n      for (const buf of rs)\n        for (let i = 0; i < buf.length; i++) buf[i] *= audio.volume;\n    }\n\n    return rs;\n  }\n\n  async function addInputAudio2Track(vdieoSamples: MP4Sample[]) {\n    const firstSamp = vdieoSamples[0];\n    const lastSamp = vdieoSamples[vdieoSamples.length - 1];\n    const pcmLength = Math.floor(\n      ((lastSamp.cts + lastSamp.duration - firstSamp.cts) /\n        lastSamp.timescale) *\n        sampleRate,\n    );\n    const audioDataBuf = mixinPCM([getInputAudioSlice(pcmLength)]);\n    if (audioDataBuf.length === 0) return;\n    audioSampleEncoder?.encode(\n      audioDataBuf,\n      (firstSamp.cts / firstSamp.timescale) * 1e6,\n    );\n  }\n\n  async function mixinAudioSampleAndInputPCM(samples: MP4Sample[]) {\n    if (audioSampleDecoder == null) return;\n\n    // 1. 先解码mp4音频\n    // [[chan0, chan1], [chan0, chan1]...]\n    const pcmFragments = (await audioSampleDecoder.decode(samples)).map(\n      extractPCM4AudioData,\n    );\n    // [chan0, chan1]\n    const mp4AudioPCM = concatPCMFragments(pcmFragments);\n    const inputAudioPCM = getInputAudioSlice(mp4AudioPCM[0].length);\n    const firstSamp = samples[0];\n\n    // 3. 重编码音频\n    audioSampleEncoder?.encode(\n      // 2. 混合输入的音频\n      mixinPCM([mp4AudioPCM, inputAudioPCM]),\n      (firstSamp.cts / firstSamp.timescale) * 1e6,\n    );\n  }\n\n  return outStream;\n}\n","// 改编自 https://jameshfisher.com/2020/08/11/production-ready-green-screen-in-the-browser/\nconst vertexShader = `#version 300 es\n  layout (location = 0) in vec4 a_position;\n  layout (location = 1) in vec2 a_texCoord;\n  out vec2 v_texCoord;\n  void main () {\n    gl_Position = a_position;\n    v_texCoord = a_texCoord;\n  }\n`;\n\nconst fragmentShader = `#version 300 es\nprecision mediump float;\nout vec4 FragColor;\nin vec2 v_texCoord;\n\nuniform sampler2D frameTexture;\nuniform vec3 keyColor;\n\n// 色度的相似度计算\nuniform float similarity;\n// 透明度的平滑度计算\nuniform float smoothness;\n// 降低绿幕饱和度，提高抠图准确度\nuniform float spill;\n\nvec2 RGBtoUV(vec3 rgb) {\n  return vec2(\n    rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5    + 0.5,\n    rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081  + 0.5\n  );\n}\n\nvoid main() {\n  // 获取当前像素的rgba值\n  vec4 rgba = texture(frameTexture, v_texCoord);\n  // 计算当前像素与绿幕像素的色度差值\n  vec2 chromaVec = RGBtoUV(rgba.rgb) - RGBtoUV(keyColor);\n  // 计算当前像素与绿幕像素的色度距离（向量长度）, 越相像则色度距离越小\n  float chromaDist = sqrt(dot(chromaVec, chromaVec));\n  // 设置了一个相似度阈值，baseMask为负，则表明是绿幕，为正则表明不是绿幕\n  float baseMask = chromaDist - similarity;\n  // 如果baseMask为负数，fullMask等于0；baseMask为正数，越大，则透明度越低\n  float fullMask = pow(clamp(baseMask / smoothness, 0., 1.), 1.5);\n  rgba.a = fullMask; // 设置透明度\n  // 如果baseMask为负数，spillVal等于0；baseMask为整数，越小，饱和度越低\n  float spillVal = pow(clamp(baseMask / spill, 0., 1.), 1.5);\n  float desat = clamp(rgba.r * 0.2126 + rgba.g * 0.7152 + rgba.b * 0.0722, 0., 1.); // 计算当前像素的灰度值\n  rgba.rgb = mix(vec3(desat, desat, desat), rgba.rgb, spillVal);\n  FragColor = rgba;\n}\n`;\n\nconst POINT_POS = [-1, 1, -1, -1, 1, -1, 1, -1, 1, 1, -1, 1];\nconst TEX_COORD_POS = [0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1];\n\n//  初始化着色器程序，让 WebGL 知道如何绘制我们的数据\nfunction initShaderProgram(\n  gl: WebGLRenderingContext,\n  vsSource: string,\n  fsSource: string,\n) {\n  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource)!;\n  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource)!;\n\n  // 创建着色器程序\n  const shaderProgram = gl.createProgram()!;\n  gl.attachShader(shaderProgram, vertexShader);\n  gl.attachShader(shaderProgram, fragmentShader);\n  gl.linkProgram(shaderProgram);\n\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n    throw Error(\n      gl.getProgramInfoLog(shaderProgram) ??\n        'Unable to initialize the shader program',\n    );\n  }\n\n  return shaderProgram;\n}\n\n// 创建指定类型的着色器，上传 source 源码并编译\nfunction loadShader(gl: WebGLRenderingContext, type: number, source: string) {\n  const shader = gl.createShader(type)!;\n\n  // Send the source to the shader object\n  gl.shaderSource(shader, source);\n\n  // Compile the shader program\n  gl.compileShader(shader);\n\n  // See if it compiled successfully\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    const errMsg = gl.getShaderInfoLog(shader);\n    gl.deleteShader(shader);\n    throw Error(errMsg ?? 'An error occurred compiling the shaders');\n  }\n\n  return shader;\n}\n\nfunction updateTexture(\n  gl: WebGLRenderingContext,\n  img: TImgSource,\n  texture: WebGLTexture,\n) {\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\n  gl.drawArrays(gl.TRIANGLES, 0, 6);\n}\n\nfunction initTexture(gl: WebGLRenderingContext) {\n  const texture = gl.createTexture();\n  if (texture == null) throw Error('Create WebGL texture error');\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  // put a single pixel in the texture so we can use it immediately.\n  const level = 0;\n  const internalFormat = gl.RGBA;\n  const width = 1;\n  const height = 1;\n  const border = 0;\n  const srcFormat = gl.RGBA;\n  const srcType = gl.UNSIGNED_BYTE;\n  const pixel = new Uint8Array([0, 0, 255, 255]); // opaque blue\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    level,\n    internalFormat,\n    width,\n    height,\n    border,\n    srcFormat,\n    srcType,\n    pixel,\n  );\n\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n  return texture;\n}\n\ninterface IChromakeyOpts {\n  keyColor: [number, number, number];\n  similarity: number;\n  smoothness: number;\n  spill: number;\n}\n\nfunction initCvs(\n  opts: {\n    width: number;\n    height: number;\n  } & IChromakeyOpts,\n) {\n  const cvs =\n    'document' in globalThis\n      ? globalThis.document.createElement('canvas')\n      : new OffscreenCanvas(opts.width, opts.height);\n  cvs.width = opts.width;\n  cvs.height = opts.height;\n\n  const gl = cvs.getContext('webgl2', {\n    premultipliedAlpha: false,\n    alpha: true,\n  }) as WebGL2RenderingContext | null;\n\n  if (gl == null) throw Error('Cant create gl context');\n\n  const shaderProgram = initShaderProgram(gl, vertexShader, fragmentShader);\n  gl.useProgram(shaderProgram);\n\n  gl.uniform3fv(\n    gl.getUniformLocation(shaderProgram, 'keyColor'),\n    opts.keyColor.map((v) => v / 255),\n  );\n  gl.uniform1f(\n    gl.getUniformLocation(shaderProgram, 'similarity'),\n    opts.similarity,\n  );\n  gl.uniform1f(\n    gl.getUniformLocation(shaderProgram, 'smoothness'),\n    opts.smoothness,\n  );\n  gl.uniform1f(gl.getUniformLocation(shaderProgram, 'spill'), opts.spill);\n\n  const posBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(POINT_POS), gl.STATIC_DRAW);\n  const a_position = gl.getAttribLocation(shaderProgram, 'a_position');\n  gl.vertexAttribPointer(\n    a_position,\n    2,\n    gl.FLOAT,\n    false,\n    Float32Array.BYTES_PER_ELEMENT * 2,\n    0,\n  );\n  gl.enableVertexAttribArray(a_position);\n\n  const texCoordBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n  gl.bufferData(\n    gl.ARRAY_BUFFER,\n    new Float32Array(TEX_COORD_POS),\n    gl.STATIC_DRAW,\n  );\n  const a_texCoord = gl.getAttribLocation(shaderProgram, 'a_texCoord');\n  gl.vertexAttribPointer(\n    a_texCoord,\n    2,\n    gl.FLOAT,\n    false,\n    Float32Array.BYTES_PER_ELEMENT * 2,\n    0,\n  );\n  gl.enableVertexAttribArray(a_texCoord);\n\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);\n\n  return { cvs, gl };\n}\n\ntype TImgSource =\n  | HTMLVideoElement\n  | HTMLCanvasElement\n  | HTMLImageElement\n  | ImageBitmap\n  | OffscreenCanvas\n  | VideoFrame;\n\nfunction getSourceWH(imgSource: TImgSource) {\n  return imgSource instanceof VideoFrame\n    ? { width: imgSource.codedWidth, height: imgSource.codedHeight }\n    : { width: imgSource.width, height: imgSource.height };\n}\n\nfunction getKeyColor(imgSource: TImgSource) {\n  const cvs = new OffscreenCanvas(1, 1);\n  const ctx = cvs.getContext('2d')!;\n  ctx.drawImage(imgSource, 0, 0);\n  const {\n    data: [r, g, b],\n  } = ctx.getImageData(0, 0, 1, 1);\n  return [r, g, b] as [number, number, number];\n}\n\n/**\n * 绿幕抠图\n * keyColor 需要扣除的背景色，若不传则取第一个像素点\n * similarity 背景色相似度阈值，过小可能保留背景色，过大可能扣掉更多非背景像素点\n * smoothness 平滑度；过小可能出现锯齿，过大导致整体变透明\n * spill      饱和度；过小可能保留绿色混合，过大导致图片变灰度\n * @param opts: {\n *   keyColor?: [r, g, b]\n *   similarity: number\n *   smoothness: number\n *   spill: number\n * }\n */\nexport const createChromakey = (\n  opts: Omit<IChromakeyOpts, 'keyColor'> & {\n    keyColor?: [number, number, number];\n  },\n) => {\n  let cvs: HTMLCanvasElement | OffscreenCanvas | null = null;\n  let gl: WebGLRenderingContext | null = null;\n  let keyC = opts.keyColor;\n  let texture: WebGLTexture | null = null;\n\n  return async (imgSource: TImgSource) => {\n    if (cvs == null || gl == null || texture == null) {\n      if (keyC == null) keyC = getKeyColor(imgSource);\n      ({ cvs, gl } = initCvs({\n        ...getSourceWH(imgSource),\n        keyColor: keyC,\n        ...opts,\n      }));\n      texture = initTexture(gl);\n    }\n\n    updateTexture(gl, imgSource, texture);\n\n    if (\n      globalThis.VideoFrame != null &&\n      imgSource instanceof globalThis.VideoFrame\n    ) {\n      const rs = new VideoFrame(cvs, {\n        alpha: 'keep',\n        timestamp: imgSource.timestamp,\n        duration: imgSource.duration ?? undefined,\n      });\n      imgSource.close();\n      return rs;\n    }\n\n    return createImageBitmap(cvs, {\n      imageOrientation: imgSource instanceof ImageBitmap ? 'flipY' : 'none',\n    });\n  };\n};\n","import { EventTool } from '@webav/internal-utils';\n\ninterface IPoint {\n  x: number;\n  y: number;\n}\n\nexport interface IRectBaseProps {\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n  angle: number;\n}\n\n/**\n * 用于记录素材在视频或画布中的空间属性：位置、大小、旋转\n *\n * 并提供控制点位置，支持用户在画布中缩放、旋转素材\n *\n * 一般由内部 WebAV SDK 内部创建维护\n *\n * @see {@link Combinator}, {@link OffscreenSprite}\n * @see [AVCanvas](../../av-canvas/classes/AVCanvas.html), {@link VisibleSprite}\n *\n * @see [视频剪辑](https://webav-tech.github.io/WebAV/demo/6_4-video-editor)\n */\nexport class Rect implements IRectBaseProps {\n  #evtTool = new EventTool<{\n    propsChange: (props: Partial<IRectBaseProps>) => void;\n  }>();\n  /**\n   * 监听属性变更事件\n   * @example\n   * rect.on('propsChange', (changedProps) => {})\n   */\n  on = this.#evtTool.on;\n\n  #x = 0;\n  /**\n   * x 坐标\n   */\n  get x() {\n    return this.#x;\n  }\n  set x(v) {\n    this.#setBaseProps('x', v);\n  }\n  #y = 0;\n  get y() {\n    return this.#y;\n  }\n  /**\n   * y 坐标\n   */\n  set y(v) {\n    this.#setBaseProps('y', v);\n  }\n  #w = 0;\n  /**\n   * 宽\n   */\n  get w() {\n    return this.#w;\n  }\n  set w(v) {\n    this.#setBaseProps('w', v);\n  }\n  #h = 0;\n  /**\n   * 高\n   */\n  get h() {\n    return this.#h;\n  }\n  set h(v) {\n    this.#setBaseProps('h', v);\n  }\n  #angle = 0;\n  /**\n   * 旋转角度\n   * @see [MDN Canvas rotate](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/rotate)\n   */\n  get angle() {\n    return this.#angle;\n  }\n  set angle(v) {\n    this.#setBaseProps('angle', v);\n  }\n\n  #setBaseProps(prop: keyof IRectBaseProps, v: number) {\n    const changed = this[prop] !== v;\n    switch (prop) {\n      case 'x':\n        this.#x = v;\n        break;\n      case 'y':\n        this.#y = v;\n        break;\n      case 'w':\n        this.#w = v;\n        break;\n      case 'h':\n        this.#h = v;\n        break;\n      case 'angle':\n        this.#angle = v;\n        break;\n    }\n    if (changed) this.#evtTool.emit('propsChange', { [prop]: v });\n  }\n\n  /**\n   * 如果当前实例是 Rect 控制点之一，`master` 将指向该 Rect\n   *\n   * 控制点的坐标是相对于它的 `master` 定位\n   */\n  #master: Rect | null = null;\n\n  constructor(\n    x?: number,\n    y?: number,\n    w?: number,\n    h?: number,\n    master?: Rect | null,\n  ) {\n    this.x = x ?? 0;\n    this.y = y ?? 0;\n    this.w = w ?? 0;\n    this.h = h ?? 0;\n    this.#master = master ?? null;\n  }\n\n  /**\n   * 根据坐标、宽高计算出来的矩形中心点\n   */\n  get center(): IPoint {\n    const { x, y, w, h } = this;\n    return { x: x + w / 2, y: y + h / 2 };\n  }\n\n  /**\n   * 是否保持固定宽高比例，禁止变形缩放\n   *\n   * 值为 true 时，将缺少上下左右四个控制点\n   */\n  fixedAspectRatio = false;\n\n  /**\n   * 是否固定中心点进行缩放\n   * 值为 true 时，固定中心点不变进行缩放\n   * 值为 false 时，固定对角点不变进行缩放\n   */\n  fixedScaleCenter = false;\n\n  clone(): Rect {\n    const { x, y, w, h } = this;\n    const rect = new Rect(x, y, w, h, this.#master);\n    rect.angle = this.angle;\n    rect.fixedAspectRatio = this.fixedAspectRatio;\n    rect.fixedScaleCenter = this.fixedScaleCenter;\n    return rect;\n  }\n\n  /**\n   * 检测目标坐标是否命中当前实例\n   * @param tx 目标点 x 坐标\n   * @param ty 目标点 y 坐标\n   */\n  checkHit(tx: number, ty: number): boolean {\n    let { angle, center, x, y, w, h } = this;\n    // ctrls 的中心点、旋转角度都取自于 master （sprite）\n    const cnt = this.#master?.center ?? center;\n    const agl = this.#master?.angle ?? angle;\n    // ctrl 初始化时其坐标就是相对于 master 的，参见 get ctrls()\n    // 所以此处不用转换\n    if (this.#master == null) {\n      x = x - cnt.x;\n      y = y - cnt.y;\n    }\n    // 鼠标点击坐标映射成以中点为原点的坐标\n    const tOX = tx - cnt.x;\n    const tOY = ty - cnt.y;\n    // 如果有旋转，映射成相对 sprite 原点，旋转前的坐标\n    let mx = tOX;\n    let my = tOY;\n    if (agl !== 0) {\n      // 推导公式 https://github.com/hughfenghen/hughfenghen.github.io/issues/96\n      mx = tOX * Math.cos(agl) + tOY * Math.sin(agl);\n      my = tOY * Math.cos(agl) - tOX * Math.sin(agl);\n    }\n\n    if (mx < x || mx > x + w || my < y || my > y + h) return false;\n\n    return true;\n  }\n}\n","import { EventTool } from '@webav/internal-utils';\nimport { IRectBaseProps, Rect } from './rect';\n\ninterface IAnimationOpts {\n  duration: number;\n  delay?: number;\n  iterCount?: number;\n}\n\ntype TAnimateProps = IRectBaseProps & { opacity: number };\n\nexport type TAnimationKeyFrame = Array<[number, Partial<TAnimateProps>]>;\n\ntype TKeyFrameOpts = Partial<\n  Record<`${number}%` | 'from' | 'to', Partial<TAnimateProps>>\n>;\n\n/**\n * Sprite 基类\n *\n * @see {@link OffscreenSprite}\n * @see {@link VisibleSprite}\n */\nexport abstract class BaseSprite {\n  /**\n   * 控制素材在视频中的空间属性（坐标、旋转、缩放）\n   */\n  rect = new Rect();\n\n  /**\n   * 控制素材在的时间偏移、时长、播放速率，常用于剪辑场景时间轴（轨道）模块\n   * duration 不能大于引用 {@link IClip} 的时长，单位 微秒\n   *\n   * playbackRate 控制当前素材的播放速率，1 表示正常播放；\n   * **注意**\n   *    1. 设置 playbackRate 时需要主动修正 duration\n   *    2. 音频使用最简单的插值算法来改变速率，所以改变速率后音调会产生变化，自定义算法请使用 {@link MP4Clip.tickInterceptor} 配合实现\n   *\n   */\n  #time = {\n    offset: 0,\n    duration: 0,\n    playbackRate: 1,\n  };\n  get time(): { offset: number; duration: number; playbackRate: number } {\n    return this.#time;\n  }\n  set time(v: { offset: number; duration: number; playbackRate?: number }) {\n    Object.assign(this.#time, v);\n  }\n\n  #evtTool = new EventTool<{\n    propsChange: (\n      value: Partial<{ rect: Partial<Rect>; zIndex: number }>,\n    ) => void;\n  }>();\n  /**\n   * 监听属性变更事件\n   * @example\n   * sprite.on('propsChange', (changedProps) => {})\n   */\n  on = this.#evtTool.on;\n\n  #zIndex = 0;\n  get zIndex(): number {\n    return this.#zIndex;\n  }\n\n  /**\n   * 控制素材间的层级关系，zIndex 值较小的素材会被遮挡\n   */\n  set zIndex(v: number) {\n    const changed = this.#zIndex !== v;\n    this.#zIndex = v;\n    if (changed) this.#evtTool.emit('propsChange', { zIndex: v });\n  }\n\n  /**\n   * 不透明度\n   */\n  opacity = 1;\n\n  /**\n   * 水平或垂直方向翻转素材\n   */\n  flip: 'horizontal' | 'vertical' | null = null;\n\n  #animatKeyFrame: TAnimationKeyFrame | null = null;\n\n  #animatOpts: Required<IAnimationOpts> | null = null;\n\n  /**\n   * @see {@link IClip.ready}\n   */\n  ready = Promise.resolve();\n\n  constructor() {\n    this.rect.on('propsChange', (props) => {\n      this.#evtTool.emit('propsChange', { rect: props });\n    });\n  }\n\n  protected _render(\n    ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n  ): void {\n    const {\n      rect: { center, angle },\n    } = this;\n    ctx.setTransform(\n      // 水平 缩放、倾斜\n      this.flip === 'horizontal' ? -1 : 1,\n      0,\n      // 垂直 倾斜、缩放\n      0,\n      this.flip === 'vertical' ? -1 : 1,\n      // 坐标原点偏移 x y\n      center.x,\n      center.y,\n    );\n    // 任意方向翻转，旋转角度转为负值，才能与控制点同步\n    ctx.rotate((this.flip == null ? 1 : -1) * angle);\n\n    ctx.globalAlpha = this.opacity;\n  }\n\n  /**\n   * 给素材添加动画，使用方法参考 css animation\n   *\n   * @example\n   * sprite.setAnimation(\n   *   {\n   *     '0%': { x: 0, y: 0 },\n   *     '25%': { x: 1200, y: 680 },\n   *     '50%': { x: 1200, y: 0 },\n   *     '75%': { x: 0, y: 680 },\n   *     '100%': { x: 0, y: 0 },\n   *   },\n   *   { duration: 4e6, iterCount: 1 },\n   * );\n   *\n   * @see [视频水印动画](https://webav-tech.github.io/WebAV/demo/2_1-concat-video)\n   */\n  setAnimation(keyFrame: TKeyFrameOpts, opts: IAnimationOpts): void {\n    this.#animatKeyFrame = Object.entries(keyFrame).map(([k, val]) => {\n      const numK = { from: 0, to: 100 }[k] ?? Number(k.slice(0, -1));\n      if (isNaN(numK) || numK > 100 || numK < 0) {\n        throw Error('keyFrame must between 0~100');\n      }\n      return [numK / 100, val];\n    }) as TAnimationKeyFrame;\n    this.#animatOpts = Object.assign({}, this.#animatOpts, {\n      duration: opts.duration,\n      delay: opts.delay ?? 0,\n      iterCount: opts.iterCount ?? Infinity,\n    });\n  }\n\n  /**\n   * 如果当前 sprite 已被设置动画，将 sprite 的动画属性设定到指定时间的状态\n   */\n  animate(time: number): void {\n    if (\n      this.#animatKeyFrame == null ||\n      this.#animatOpts == null ||\n      time < this.#animatOpts.delay\n    )\n      return;\n    const updateProps = linearTimeFn(\n      time,\n      this.#animatKeyFrame,\n      this.#animatOpts,\n    );\n    for (const k in updateProps) {\n      switch (k) {\n        case 'opacity':\n          this.opacity = updateProps[k] as number;\n          break;\n        case 'x':\n        case 'y':\n        case 'w':\n        case 'h':\n        case 'angle':\n          this.rect[k] = updateProps[k] as number;\n          break;\n      }\n    }\n  }\n\n  /**\n   * 将当前 sprite 的属性赋值到目标\n   *\n   * 用于 clone，或 {@link VisibleSprite} 与 {@link OffscreenSprite} 实例间的类型转换\n   */\n  copyStateTo<T extends BaseSprite>(target: T) {\n    target.#animatKeyFrame = this.#animatKeyFrame;\n    target.#animatOpts = this.#animatOpts;\n    target.zIndex = this.zIndex;\n    target.opacity = this.opacity;\n    target.flip = this.flip;\n    target.rect = this.rect.clone();\n    target.time = { ...this.time };\n  }\n\n  protected destroy() {\n    this.#evtTool.destroy();\n  }\n}\n\nexport function linearTimeFn(\n  time: number,\n  kf: TAnimationKeyFrame,\n  opts: Required<IAnimationOpts>,\n): Partial<TAnimateProps> {\n  const offsetTime = time - opts.delay;\n  if (offsetTime / opts.duration >= opts.iterCount) return {};\n\n  const t = offsetTime % opts.duration;\n\n  const process = offsetTime === opts.duration ? 1 : t / opts.duration;\n  const idx = kf.findIndex((it) => it[0] >= process);\n  if (idx === -1) return {};\n\n  const startState = kf[idx - 1];\n  const nextState = kf[idx];\n  const nextFrame = nextState[1];\n  if (startState == null) return nextFrame;\n  const startFrame = startState[1];\n\n  const rs: Partial<TAnimateProps> = {};\n  // 介于两个Frame状态间的进度\n  const stateProcess =\n    (process - startState[0]) / (nextState[0] - startState[0]);\n  for (const prop in nextFrame) {\n    const p = prop as keyof TAnimateProps;\n    if (startFrame[p] == null) continue;\n    // @ts-expect-error\n    // eslint-disable-next-line\n    rs[p] = (nextFrame[p] - startFrame[p]) * stateProcess + startFrame[p];\n  }\n\n  return rs;\n}\n","import { BaseSprite } from './base-sprite';\nimport { IClip } from '../clips';\nimport { Log } from '@webav/internal-utils';\nimport { changePCMPlaybackRate } from '../av-utils';\n\n/**\n * 包装 {@link IClip} 给素材扩展坐标、层级、透明度等信息，用于 {@link Combinator} 在后台合成视频\n *\n * 跟 {@link VisibleSprite} 非常相似，应用场景不同\n *\n * @example\n * const spr = new OffscreenSprite(\n *   new MP4Clip((await fetch('<mp4 url>')).body),\n * );\n * spr.opacity = 0.5 // 半透明\n * spr.rect.x = 100 // x 坐标偏移 100 像素\n * spr.time.offset = 10e6 // 视频第 10s 开始绘制该视频素材\n *\n * @see [视频合成](https://webav-tech.github.io/WebAV/demo/2_1-concat-video)\n */\nexport class OffscreenSprite extends BaseSprite {\n  #clip: IClip;\n\n  // 保持最近一帧，若 clip 在当前帧无数据，则绘制最近一帧\n  #lastVf: VideoFrame | ImageBitmap | null = null;\n\n  #destroyed = false;\n\n  constructor(clip: IClip) {\n    super();\n    this.#clip = clip;\n    this.ready = clip.ready.then(({ width, height, duration }) => {\n      this.rect.w = this.rect.w === 0 ? width : this.rect.w;\n      this.rect.h = this.rect.h === 0 ? height : this.rect.h;\n      this.time.duration =\n        this.time.duration === 0 ? duration : this.time.duration;\n    });\n  }\n\n  /**\n   * 绘制素材指定时刻的图像到 canvas 上下文，并返回对应的音频数据\n   * @param time 指定时刻，微秒\n   */\n  async offscreenRender(\n    ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n    time: number,\n  ): Promise<{\n    audio: Float32Array[];\n    done: boolean;\n  }> {\n    const ts = time * this.time.playbackRate;\n    this.animate(ts);\n    super._render(ctx);\n    const { w, h } = this.rect;\n    const { video, audio, state } = await this.#clip.tick(ts);\n    let outAudio = audio ?? [];\n    if (audio != null && this.time.playbackRate !== 1) {\n      outAudio = audio.map((pcm) =>\n        changePCMPlaybackRate(pcm, this.time.playbackRate),\n      );\n    }\n\n    if (state === 'done') {\n      return {\n        audio: outAudio,\n        done: true,\n      };\n    }\n\n    const imgSource = video ?? this.#lastVf;\n    if (imgSource != null) {\n      ctx.drawImage(imgSource, -w / 2, -h / 2, w, h);\n    }\n\n    if (video != null) {\n      this.#lastVf?.close();\n      this.#lastVf = video;\n    }\n\n    return {\n      audio: outAudio,\n      done: false,\n    };\n  }\n\n  async clone() {\n    const spr = new OffscreenSprite(await this.#clip.clone());\n    await spr.ready;\n    this.copyStateTo(spr);\n    return spr;\n  }\n\n  destroy(): void {\n    if (this.#destroyed) return;\n    this.#destroyed = true;\n\n    Log.info('OffscreenSprite destroy');\n    super.destroy();\n    this.#lastVf?.close();\n    this.#lastVf = null;\n    this.#clip.destroy();\n  }\n}\n","import { BaseSprite } from './base-sprite';\nimport { IClip } from '../clips';\nimport { Log } from '@webav/internal-utils';\nimport { changePCMPlaybackRate } from '../av-utils';\n\n/**\n * 包装 {@link IClip} 给素材扩展坐标、层级、透明度等信息，用于 {@link [AVCanvas](../../av-canvas/classes/AVCanvas.html)} 响应用户交互\n *\n * 跟 {@link OffscreenSprite} 非常相似，应用场景不同\n *\n * @example\n * const spr = new VisibleSprite(\n *   new MP4Clip((await fetch('<mp4 url>')).body),\n * );\n * spr.opacity = 0.5 // 半透明\n * spr.rect.x = 100 // x 坐标偏移 100 像素\n * spr.time.offset = 10e6 // 视频第 10s 开始绘制素材\n *\n * @see [视频剪辑](https://webav-tech.github.io/WebAV/demo/6_4-video-editor)\n *\n */\nexport class VisibleSprite extends BaseSprite {\n  #clip: IClip;\n  getClip() {\n    return this.#clip;\n  }\n\n  /**\n   * 元素是否可见，用于不想删除，期望临时隐藏 Sprite 的场景\n   */\n  visible = true;\n\n  constructor(clip: IClip) {\n    super();\n    this.#clip = clip;\n    this.ready = clip.ready.then(({ width, height, duration }) => {\n      this.rect.w = this.rect.w === 0 ? width : this.rect.w;\n      this.rect.h = this.rect.h === 0 ? height : this.rect.h;\n      this.time.duration =\n        this.time.duration === 0 ? duration : this.time.duration;\n    });\n  }\n\n  // 保持最近一帧，若 clip 在当前帧无数据，则绘制最近一帧\n  #lastVf: VideoFrame | ImageBitmap | null = null;\n  #lastAudio: Float32Array[] = [];\n  #ticking = false;\n  #update(time: number) {\n    if (this.#ticking) return;\n    this.#ticking = true;\n    this.#clip\n      .tick(time * this.time.playbackRate)\n      .then(({ video, audio }) => {\n        if (video != null) {\n          this.#lastVf?.close();\n          this.#lastVf = video ?? null;\n        }\n        this.#lastAudio = audio ?? [];\n        if (audio != null && this.time.playbackRate !== 1) {\n          this.#lastAudio = audio.map((pcm) =>\n            changePCMPlaybackRate(pcm, this.time.playbackRate),\n          );\n        }\n      })\n      .finally(() => {\n        this.#ticking = false;\n      });\n  }\n\n  /**\n   * 提前准备指定 time 的帧\n   */\n  preFrame(time: number) {\n    if (this.#lastTime === time) return;\n    this.#update(time);\n    this.#lastTime = time;\n  }\n\n  #lastTime = -1;\n  /**\n   * 绘制素材指定时刻的图像到 canvas 上下文，并返回对应的音频数据\n   * @param time 指定时刻，微秒\n   */\n  render(\n    ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n    time: number,\n  ): { audio: Float32Array[] } {\n    this.animate(time);\n    super._render(ctx);\n    const { w, h } = this.rect;\n    if (this.#lastTime !== time) this.#update(time);\n    this.#lastTime = time;\n\n    const audio = this.#lastAudio;\n    this.#lastAudio = [];\n    const video = this.#lastVf;\n    if (video != null) ctx.drawImage(video, -w / 2, -h / 2, w, h);\n\n    return { audio };\n  }\n\n  copyStateTo<T extends BaseSprite>(target: T): void {\n    super.copyStateTo(target);\n    if (target instanceof VisibleSprite) {\n      target.visible = this.visible;\n    }\n  }\n\n  #destroyed = false;\n  destroy(): void {\n    if (this.#destroyed) return;\n    this.#destroyed = true;\n\n    Log.info('VisibleSprite destroy');\n    super.destroy();\n    this.#lastVf?.close();\n    this.#lastVf = null;\n    // this.#clip.destroy();\n  }\n}\n","import { Log, EventTool, file2stream, recodemux } from '@webav/internal-utils';\nimport { OffscreenSprite } from './sprite/offscreen-sprite';\nimport { sleep } from './av-utils';\nimport { DEFAULT_AUDIO_CONF } from './clips';\n\nexport interface ICombinatorOpts {\n  width?: number;\n  height?: number;\n  bitrate?: number;\n  fps?: number;\n  bgColor?: string;\n  videoCodec?: string;\n  /**\n   * false 合成的视频文件中排除音轨\n   */\n  audio?: false;\n  /**\n   * 向输出的视频中写入 meta tags 数据\n   */\n  metaDataTags?: Record<string, string>;\n  /**\n   * 不安全，随时可能废弃\n   */\n  __unsafe_hardwareAcceleration__?: HardwarePreference;\n}\n\nlet COM_ID = 0;\n\n/**\n * 避免 VideoEncoder 队列中的 VideoFrame 过多，打爆显存\n */\nasync function letEncoderCalmDown(getQSize: () => number) {\n  if (getQSize() > 50) {\n    await sleep(15);\n    await letEncoderCalmDown(getQSize);\n  }\n}\n\n/**\n * 视频合成器；能添加多个 {@link OffscreenSprite}，根据它们位置、层级、时间偏移等信息，合成输出为视频文件\n * @see [视频合成](https://webav-tech.github.io/WebAV/demo/2_1-concat-video)\n * @see [视频配音](https://webav-tech.github.io/WebAV/demo/2_2-video-add-audio)\n * @example\n * const spr1 = new OffscreenSprite(\n *   new MP4Clip((await fetch('<mp4 url>')).body),\n * );\n * const spr2 = new OffscreenSprite(\n *   new AudioClip((await fetch('<audio url>')).body),\n * );\n * const com = new Combinator({ width: 1280, height: 720, });\n\n * await com.addSprite(spr1);\n * await com.addSprite(spr2);\n\n * com.output(); // => ReadableStream\n *\n */\nexport class Combinator {\n  /**\n   * 检测当前环境的兼容性\n   * @param args.videoCodec 指定视频编码格式，默认 avc1.42E032\n   * @param args.width 指定视频宽度，默认 1920\n   * @param args.height 指定视频高度，默认 1080\n   * @param args.bitrate 指定视频比特率，默认 5e6\n   */\n  static async isSupported(\n    args: {\n      videoCodec?: string;\n      width?: number;\n      height?: number;\n      bitrate?: number;\n    } = {},\n  ): Promise<boolean> {\n    return (\n      (self.OffscreenCanvas != null &&\n        self.VideoEncoder != null &&\n        self.VideoDecoder != null &&\n        self.VideoFrame != null &&\n        self.AudioEncoder != null &&\n        self.AudioDecoder != null &&\n        self.AudioData != null &&\n        ((\n          await self.VideoEncoder.isConfigSupported({\n            codec: args.videoCodec ?? 'avc1.42E032',\n            width: args.width ?? 1920,\n            height: args.height ?? 1080,\n            bitrate: args.bitrate ?? 7e6,\n          })\n        ).supported ??\n          false) &&\n        (\n          await self.AudioEncoder.isConfigSupported({\n            codec: DEFAULT_AUDIO_CONF.codec,\n            sampleRate: DEFAULT_AUDIO_CONF.sampleRate,\n            numberOfChannels: DEFAULT_AUDIO_CONF.channelCount,\n          })\n        ).supported) ??\n      false\n    );\n  }\n\n  #log = Log.create(`id:${COM_ID++},`);\n\n  #destroyed = false;\n\n  #sprites: Array<OffscreenSprite & { main: boolean; expired: boolean }> = [];\n\n  #cvs;\n\n  #ctx;\n\n  // 中断输出\n  #stopOutput: (() => void) | null = null;\n\n  #opts: Required<ICombinatorOpts>;\n\n  #hasVideoTrack: boolean;\n\n  #evtTool = new EventTool<{\n    OutputProgress: (progress: number) => void;\n    error: (err: Error) => void;\n  }>();\n  on = this.#evtTool.on;\n\n  /**\n   * 根据配置创建合成器实例\n   * @param opts ICombinatorOpts\n   */\n  constructor(opts: ICombinatorOpts = {}) {\n    const { width = 0, height = 0 } = opts;\n    this.#cvs = new OffscreenCanvas(width, height);\n    // this.#cvs = document.querySelector('#canvas') as HTMLCanvasElement\n    const ctx = this.#cvs.getContext('2d', { alpha: false });\n    if (ctx == null) throw Error('Can not create 2d offscreen context');\n    this.#ctx = ctx;\n    this.#opts = Object.assign(\n      {\n        bgColor: '#000',\n        width: 0,\n        height: 0,\n        videoCodec: 'avc1.42E032',\n        audio: true,\n        bitrate: 5e6,\n        fps: 30,\n        metaDataTags: null,\n      },\n      opts,\n    );\n\n    this.#hasVideoTrack = width * height > 0;\n  }\n\n  /**\n   * 添加用于合成视频的 Sprite，视频时长默认取所有素材 duration 字段的最大值\n   * @param os Sprite\n   * @param opts.main 如果 main 为 true，视频时长为该素材的 duration 值\n   */\n  async addSprite(\n    os: OffscreenSprite,\n    opts: { main?: boolean } = {},\n  ): Promise<void> {\n    const logAttrs = {\n      rect: pick(['x', 'y', 'w', 'h'], os.rect),\n      time: { ...os.time },\n      zIndex: os.zIndex,\n    };\n    this.#log.info('Combinator add sprite', logAttrs);\n    const newOS = await os.clone();\n    this.#log.info('Combinator add sprite ready');\n    this.#sprites.push(\n      Object.assign(newOS, {\n        main: opts.main ?? false,\n        expired: false,\n      }),\n    );\n    this.#sprites.sort((a, b) => a.zIndex - b.zIndex);\n  }\n\n  #startRecodeMux(duration: number) {\n    const { fps, width, height, videoCodec, bitrate, audio, metaDataTags } =\n      this.#opts;\n    const recodeMuxer = recodemux({\n      video: this.#hasVideoTrack\n        ? {\n            width,\n            height,\n            expectFPS: fps,\n            codec: videoCodec,\n            bitrate,\n            __unsafe_hardwareAcceleration__:\n              this.#opts.__unsafe_hardwareAcceleration__,\n          }\n        : null,\n      audio:\n        audio === false\n          ? null\n          : {\n              codec: 'aac',\n              sampleRate: DEFAULT_AUDIO_CONF.sampleRate,\n              channelCount: DEFAULT_AUDIO_CONF.channelCount,\n            },\n      duration,\n      metaDataTags: metaDataTags,\n    });\n    return recodeMuxer;\n  }\n\n  /**\n   * 输出视频文件二进制流\n   */\n  output(): ReadableStream<Uint8Array> {\n    if (this.#sprites.length === 0) throw Error('No sprite added');\n\n    const mainSpr = this.#sprites.find((it) => it.main);\n    // 最大时间，优先取 main sprite，不存在则取最大值\n    const maxTime =\n      mainSpr != null\n        ? mainSpr.time.offset + mainSpr.time.duration\n        : Math.max(\n            ...this.#sprites.map((it) => it.time.offset + it.time.duration),\n          );\n    if (maxTime === Infinity) {\n      throw Error(\n        'Unable to determine the end time, please specify a main sprite, or limit the duration of ImgClip, AudioCli',\n      );\n    }\n    // 主视频（main）的 videoTrack duration 值为 0\n    if (maxTime === -1) {\n      this.#log.warn(\n        \"Unable to determine the end time, process value don't update\",\n      );\n    }\n\n    this.#log.info(`start combinate video, maxTime:${maxTime}`);\n    const remux = this.#startRecodeMux(maxTime);\n    let starTime = performance.now();\n    const stopReCodeMux = this.#run(remux, maxTime, {\n      onProgress: (prog) => {\n        this.#log.debug('OutputProgress:', prog);\n        this.#evtTool.emit('OutputProgress', prog);\n      },\n      onEnded: async () => {\n        await remux.flush();\n        this.#log.info(\n          '===== output ended =====, cost:',\n          performance.now() - starTime,\n        );\n        this.#evtTool.emit('OutputProgress', 1);\n        this.destroy();\n      },\n      onError: (err) => {\n        this.#evtTool.emit('error', err);\n        closeOutStream(err);\n        this.destroy();\n      },\n    });\n\n    this.#stopOutput = () => {\n      stopReCodeMux();\n      remux.close();\n      closeOutStream();\n    };\n    const { stream, stop: closeOutStream } = file2stream(\n      remux.mp4file,\n      500,\n      this.destroy,\n    );\n\n    return stream;\n  }\n\n  /**\n   * 销毁实例，释放资源\n   */\n  destroy() {\n    if (this.#destroyed) return;\n    this.#destroyed = true;\n\n    this.#stopOutput?.();\n    this.#evtTool.destroy();\n  }\n\n  #run(\n    remux: ReturnType<typeof recodemux>,\n    maxTime: number,\n    {\n      onProgress,\n      onEnded,\n      onError,\n    }: {\n      onProgress: (prog: number) => void;\n      onEnded: () => Promise<void>;\n      onError: (err: Error) => void;\n    },\n  ): () => void {\n    let progress = 0;\n    const aborter = { aborted: false };\n    let err: Error | null = null;\n\n    const _run = async () => {\n      const { fps, bgColor, audio: outputAudio } = this.#opts;\n      const timeSlice = Math.round(1e6 / fps);\n\n      const ctx = this.#ctx;\n      const sprRender = createSpritesRender({\n        ctx,\n        bgColor,\n        sprites: this.#sprites,\n        aborter,\n      });\n      const encodeData = createAVEncoder({\n        remux,\n        ctx,\n        cvs: this.#cvs,\n        outputAudio,\n        hasVideoTrack: this.#hasVideoTrack,\n        timeSlice,\n        fps,\n      });\n\n      let ts = 0;\n      while (true) {\n        if (err != null) return;\n        if (\n          aborter.aborted ||\n          (maxTime === -1 ? false : ts > maxTime) ||\n          this.#sprites.length === 0\n        ) {\n          exit();\n          await onEnded();\n          return;\n        }\n        progress = ts / maxTime;\n\n        const { audios, mainSprDone } = await sprRender(ts);\n        if (mainSprDone) {\n          exit();\n          await onEnded();\n          return;\n        }\n\n        if (aborter.aborted) return;\n\n        encodeData(ts, audios);\n\n        ts += timeSlice;\n\n        await letEncoderCalmDown(remux.getEncodeQueueSize);\n      }\n    };\n\n    _run().catch((e) => {\n      err = e;\n      this.#log.error(e);\n      exit();\n      onError(e);\n    });\n\n    const outProgTimer = setInterval(() => {\n      onProgress(progress);\n    }, 500);\n\n    const exit = () => {\n      if (aborter.aborted) return;\n      aborter.aborted = true;\n      clearInterval(outProgTimer);\n      this.#sprites.forEach((it) => it.destroy());\n    };\n\n    return exit;\n  }\n}\n\nfunction createSpritesRender(opts: {\n  ctx: OffscreenCanvasRenderingContext2D;\n  bgColor: string;\n  sprites: Array<OffscreenSprite & { main: boolean; expired: boolean }>;\n  aborter: { aborted: boolean };\n}) {\n  const { ctx, bgColor, sprites, aborter } = opts;\n  const { width, height } = ctx.canvas;\n  return async (ts: number) => {\n    ctx.fillStyle = bgColor;\n    ctx.fillRect(0, 0, width, height);\n\n    const audios: Float32Array[][] = [];\n    let mainSprDone = false;\n    for (const s of sprites) {\n      if (aborter.aborted) break;\n      if (ts < s.time.offset || s.expired) continue;\n\n      ctx.save();\n      const { audio, done } = await s.offscreenRender(ctx, ts - s.time.offset);\n      audios.push(audio);\n      ctx.restore();\n\n      // 超过设定时间主动掐断，或资源结束\n      if (\n        (s.time.duration > 0 && ts > s.time.offset + s.time.duration) ||\n        done\n      ) {\n        if (s.main) mainSprDone = true;\n\n        s.destroy();\n        s.expired = true;\n      }\n    }\n    return {\n      audios,\n      mainSprDone,\n    };\n  };\n}\n\nfunction createAVEncoder(opts: {\n  remux: ReturnType<typeof recodemux>;\n  ctx: OffscreenCanvasRenderingContext2D;\n  cvs: OffscreenCanvas;\n  outputAudio?: boolean;\n  hasVideoTrack: boolean;\n  timeSlice: number;\n  fps: number;\n}) {\n  const { ctx, cvs, outputAudio, remux, hasVideoTrack, timeSlice } = opts;\n  const { width, height } = cvs;\n  let frameCnt = 0;\n  // 3s 一个 GOP\n  const gopSize = Math.floor(3 * opts.fps);\n\n  const audioTrackBuf = createAudioTrackBuf(1024);\n\n  return (ts: number, audios: Float32Array[][]) => {\n    if (outputAudio !== false) {\n      for (const ad of audioTrackBuf(ts, audios)) remux.encodeAudio(ad);\n    }\n\n    if (hasVideoTrack) {\n      const vf = new VideoFrame(cvs, {\n        duration: timeSlice,\n        timestamp: ts,\n      });\n\n      remux.encodeVideo(vf, {\n        keyFrame: frameCnt % gopSize === 0,\n      });\n      ctx.resetTransform();\n      ctx.clearRect(0, 0, width, height);\n\n      frameCnt += 1;\n    }\n  };\n}\n\n/**\n * 缓冲输入的数据，转换成固定帧数的 AudioData\n * @param adFrames 一个 AudioData 实例的音频帧数\n */\nexport function createAudioTrackBuf(adFrames: number) {\n  const adDataSize = adFrames * DEFAULT_AUDIO_CONF.channelCount;\n  // pcm 数据缓存区\n  const chanBuf = new Float32Array(adDataSize * 3);\n  let putOffset = 0;\n\n  let audioTs = 0;\n  const adDuration = (adFrames / DEFAULT_AUDIO_CONF.sampleRate) * 1e6;\n\n  // 缺少音频数据时占位\n  const placeholderData = new Float32Array(adDataSize);\n\n  const getAudioData = (ts: number) => {\n    let readOffset = 0;\n    const adCnt = Math.floor(putOffset / adDataSize);\n    const rs: AudioData[] = [];\n    // 从缓存区按指定帧数获取数据构造 AudioData\n    for (let i = 0; i < adCnt; i++) {\n      rs.push(\n        new AudioData({\n          timestamp: audioTs,\n          numberOfChannels: DEFAULT_AUDIO_CONF.channelCount,\n          numberOfFrames: adFrames,\n          sampleRate: DEFAULT_AUDIO_CONF.sampleRate,\n          format: 'f32',\n          data: chanBuf.subarray(readOffset, readOffset + adDataSize),\n        }),\n      );\n      readOffset += adDataSize;\n      audioTs += adDuration;\n    }\n    chanBuf.set(chanBuf.subarray(readOffset, putOffset), 0);\n    putOffset -= readOffset;\n\n    // 已有音频数据不足，使用占位数据填充\n    while (ts - audioTs > adDuration) {\n      rs.push(\n        new AudioData({\n          timestamp: audioTs,\n          numberOfChannels: DEFAULT_AUDIO_CONF.channelCount,\n          numberOfFrames: adFrames,\n          sampleRate: DEFAULT_AUDIO_CONF.sampleRate,\n          format: 'f32',\n          data: placeholderData,\n        }),\n      );\n      audioTs += adDuration;\n    }\n    return rs;\n  };\n\n  return (ts: number, trackAudios: Float32Array[][]) => {\n    const maxLen = Math.max(...trackAudios.map((a) => a[0]?.length ?? 0));\n    for (let bufIdx = 0; bufIdx < maxLen; bufIdx++) {\n      let chan0 = 0;\n      let chan1 = 0;\n      for (let trackIdx = 0; trackIdx < trackAudios.length; trackIdx++) {\n        const _c0 = trackAudios[trackIdx][0]?.[bufIdx] ?? 0;\n        // 如果是单声道 PCM，第二声道复用第一声道数据\n        const _c1 = trackAudios[trackIdx][1]?.[bufIdx] ?? _c0;\n        chan0 += _c0;\n        chan1 += _c1;\n      }\n      // 合成多个素材的音频数据写入缓存区\n      chanBuf[putOffset] = chan0;\n      chanBuf[putOffset + 1] = chan1;\n      putOffset += 2;\n    }\n    // 消费缓存区数据，生成 AudioData\n    return getAudioData(ts);\n  };\n}\n\nfunction pick<K extends keyof T, T extends object>(keys: K[], obj: T) {\n  return keys.reduce(\n    (acc, key) => {\n      acc[key] = obj[key];\n      return acc;\n    },\n    {} as Record<K, T[K]>,\n  );\n}\n"],"names":["createEl","tagName","renderTxt2Img","txt","cssText","div","width","height","img","svgStr","renderTxt2ImgBitmap","imgEl","resolve","cvs","ctx","concatFloat32Array","bufs","rs","buf","a","b","offset","concatPCMFragments","fragments","chanListPCM","i","j","extractPCM4AudioData","ad","idx","chanBufSize","chanBuf","convertF32ToPlanar","convertS16ToF32Planar","pcmS16Data","numChannels","numSamples","planarData","channel","sample","pcmF32Data","extractPCM4AudioBuffer","ab","_","decodeImg","stream","type","init","imageDecoder","frameCnt","_a","mixinPCM","audios","maxLen","data","bufIdx","chan0","chan1","trackIdx","_c0","_c1","_b","audioResample","pcmData","curRate","target","chanCnt","emptyPCM","len","c","p","waveResampler","abSource","d","sleep","time","stop","workerTimer","ringSliceFloat32Array","start","end","cnt","changePCMPlaybackRate","playbackRate","newLength","newPcmData","originalIndex","intIndex","frac","DEFAULT_AUDIO_CONF","extractFileConfig","file","info","vTrack","videoDesc","parseVideoCodecDesc","descKey","aTrack","esdsBox","getESDSBoxFromMP4File","parseAudioInfo4ESDSBox","track","entry","box","mp4box","codec","mp4aBox","t","esds","decoderConf","byte1","byte2","sampleRateIdx","numberOfChannels","quickParseMP4File","reader","onReady","onSamples","mp4boxFile","vTrackId","aTrackId","parse","cursor","maxReadSize","nextPos","CLIP_ID","isOTFile","obj","_MP4Clip","source","opts","__privateAdd","_insId","_log","Log","__privateGet","__publicField","_destroyed","_meta","_localFile","_headerBoxPos","_volume","_videoSamples","_audioSamples","_videoFrameFinder","_audioFrameFinder","_decoderConf","_opts","tickRet","_thumbAborter","__privateSet","initByStream","s","write","tmpfile","otFile","mp4FileToSamples","videoSamples","audioSamples","headerBoxPos","videoFrameFinder","audioFrameFinder","genDecoder","genMeta","oFile","size","audio","video","_c","imgWidth","aborterSignal","abortMsg","convtr","createVF2BlobConvtr","reject","pngPromises","vc","resolver","it","pushPngPromise","vf","step","cur","VideoFrameFinder","thumbnailByKeyFrame","done","preVideoSlice","postVideoSlice","splitVideoSampleByTime","preAudioSlice","postAudioSlice","splitAudioSampleByTime","preClip","postClip","clip","clips","videoClip","audioClip","MP4Clip","meta","vDuration","aDuration","lastSampele","localFileReader","volume","AudioFrameFinder","mp4Info","videoDeltaTS","audioDeltaTS","ftyp","moov","ac","samples","normalizeTimescale","fixFirstBlackFrame","delta","sampleType","idrOffset","idrNALUOffset","conf","_dec","_ts","_curAborter","_reset","_parseFrame","_sleepCnt","_lastVfDur","_downgradeSoftDecode","_videoDecCusorIdx","_videoFrames","_outputFrameCnt","_inputChunkCnt","_predecodeErr","dec","aborter","_startDecode","err","_decoding","_getState","endIdx","hasValidFrame","readStarTime","chunks","videosamples2Chunks","readCost","first","last","rangSize","decodeGoP","f","keyIdx","encoderConf","rsVf","errMsg","memoryUsageInfo","findIndexOfSamples","_sampleRate","needResetTime","_decCusorIdx","deltaTime","_pcmData","emitFrameCnt","ramainFrameCnt","emitAudioFrames","createAudioChunksDecoder","pcmArr","outputCb","inputCnt","outputCnt","outputHandler","pcm","resampleQ","createPromiseQueue","needResample","adec","handleDecodeError","prefixStr","chunk","onResult","rsCache","waitingIdx","updateRs","emitIdx","emitRs","addIdx","task","emitCnt","gapCnt","gopStartIdx","gopEndIdx","hitIdx","hitSample","preSlice","postSlice","u8Arr","dv","nalUnitType","localFile","decConf","abortSingl","onOutput","fileReader","createVideoDec","downgrade","iframeCnt","minCtsSample","mem","_ImgClip","dataSource","_ImgClip_instances","_img","_frames","initWithImgBitmap","imgBitmap","frame","acc","__privateMethod","initAnimateImg_fn","tt","firstVf","ImgClip","_AudioClip","_AudioClip_instances","_chan0Buf","_chan1Buf","_frameOffset","init_fn","chan","tStart","parseStream2PCM","AudioClip","_MediaStreamClip","ms","_stopRenderCvs","_cvs","_ms","videoTrack","renderVideoTrackToCvs","MediaStreamClip","onOffscreenCanvasReady","emitFF","cvsCtx","autoReadStream","displayHeight","displayWidth","_EmbedSubtitlesClip","content","_EmbedSubtitlesClip_instances","_subtitles","_ctx","_lastVF","_lineHeight","_linePadding","parseSrt","text","fontSize","fontFamily","videoWidth","videoHeight","letterSpacing","renderTxt_fn","sub","preLastIt","postFirstIt","subtitle","value","lines","color","textBgColor","textShadow","strokeStyle","lineWidth","lineCap","lineJoin","bottomOffset","bottomDistance","lineStr","txtMeas","centerX","EmbedSubtitlesClip","srtTimeToSeconds","match","hours","minutes","seconds","milliseconds","srt","str","SampleTransform","_inputBufOffset","streamCancelled","ctrl","releasedCnt","id","ui8Arr","inputBuf","fixMP4BoxFileDuration","inMP4File","sendedBoxIdx","boxes","tracks","totalDuration","write2TmpFile","box2Buf","tmpFileWriter","moovPrevBoxes","moovBoxReady","moovIdx","timerId","postFile","initPromise","stoped","rsFile","startIdx","ds","chunk2MP4SampleOpts","dts","fastConcatMP4","streams","outfile","dumpFile","concatStreamsToMP4BoxFile","outStream","vDTS","vCTS","aDTS","aCTS","lastVSamp","lastASamp","chunkType","videoTrackConf","audioTrackConf","trackId","offsetDTS","offsetCTS","lastSamp","fixFMP4Duration","createMP4AudioSampleDecoder","adConf","cacheAD","adDecoder","ss","createMP4AudioSampleEncoder","aeConf","adEncoder","lastData","createAD","ts","audioFade","sampleRate","dataLen","fadeLen","mixinMP4AndAudio","mp4Stream","stopOut","file2stream","audioSampleDecoder","audioSampleEncoder","inputAudioPCM","audioOffset","mp4HasAudio","audioDecoderConf","safeAudioTrackConf","audioCtx","addInputAudio2Track","mixinAudioSampleAndInputPCM","getInputAudioSlice","vdieoSamples","firstSamp","pcmLength","audioDataBuf","pcmFragments","mp4AudioPCM","vertexShader","fragmentShader","POINT_POS","TEX_COORD_POS","initShaderProgram","gl","vsSource","fsSource","loadShader","shaderProgram","shader","updateTexture","texture","initTexture","level","internalFormat","border","srcFormat","srcType","pixel","initCvs","v","posBuffer","a_position","texCoordBuffer","a_texCoord","getSourceWH","imgSource","getKeyColor","r","g","createChromakey","keyC","_Rect","x","y","w","h","master","_Rect_instances","_evtTool","EventTool","_x","_y","_w","_h","_angle","_master","setBaseProps_fn","rect","tx","ty","angle","center","agl","tOX","tOY","mx","my","prop","changed","Rect","BaseSprite","_time","_zIndex","_animatKeyFrame","_animatOpts","props","keyFrame","k","val","numK","updateProps","linearTimeFn","kf","offsetTime","process","startState","nextState","nextFrame","startFrame","stateProcess","_OffscreenSprite","_clip","_lastVf","duration","state","outAudio","spr","OffscreenSprite","_VisibleSprite","_VisibleSprite_instances","_lastAudio","_ticking","_lastTime","update_fn","VisibleSprite","COM_ID","letEncoderCalmDown","getQSize","Combinator","_Combinator_instances","_sprites","_stopOutput","_hasVideoTrack","args","os","logAttrs","pick","newOS","mainSpr","maxTime","remux","startRecodeMux_fn","starTime","stopReCodeMux","run_fn","prog","closeOutStream","fps","videoCodec","bitrate","metaDataTags","recodemux","onProgress","onEnded","onError","progress","bgColor","outputAudio","timeSlice","sprRender","createSpritesRender","encodeData","createAVEncoder","exit","mainSprDone","e","outProgTimer","sprites","hasVideoTrack","gopSize","audioTrackBuf","createAudioTrackBuf","adFrames","adDataSize","putOffset","audioTs","adDuration","placeholderData","getAudioData","readOffset","adCnt","trackAudios","keys","key"],"mappings":";;;;;;;;;;;;AAOO,SAASA,GAASC,GAA8B;AAC9C,SAAA,SAAS,cAAcA,CAAO;AACvC;AAQgB,SAAAC,GAAcC,GAAaC,GAAmC;AACtE,QAAAC,IAAML,GAAS,KAAK;AACtB,EAAAK,EAAA,MAAM,UAAU,cAAcD,CAAO,0CACzCC,EAAI,cAAcF,GACT,SAAA,KAAK,YAAYE,CAAG;AAE7B,QAAM,EAAE,OAAAC,GAAO,QAAAC,EAAO,IAAIF,EAAI,sBAAsB;AAEpD,EAAAA,EAAI,OAAO,GACXA,EAAI,MAAM,aAAa;AAEjB,QAAAG,IAAM,IAAI;AAChB,EAAAA,EAAI,QAAQF,GACZE,EAAI,SAASD;AACb,QAAME,IAAS;AAAA,qDACoCH,CAAK,aAAaC,CAAM;AAAA;AAAA,oDAEzBF,EAAI,SAAS;AAAA;AAAA;AAAA,IAI5D,QAAQ,OAAO,EAAE,EACjB,QAAQ,MAAM,KAAK;AAElB,SAAAG,EAAA,MAAM,oCAAoCC,CAAM,IAC7CD;AACT;AAesB,eAAAE,GACpBP,GACAC,GACsB;AAChB,QAAAO,IAAQT,GAAcC,GAAKC,CAAO;AAClC,QAAA,IAAI,QAAQ,CAACQ,MAAY;AAC7B,IAAAD,EAAM,SAASC;AAAA,EAAA,CAChB;AACD,QAAMC,IAAM,IAAI,gBAAgBF,EAAM,OAAOA,EAAM,MAAM,GACnDG,IAAMD,EAAI,WAAW,IAAI;AAC/B,SAAAC,KAAA,QAAAA,EAAK,UAAUH,GAAO,GAAG,GAAGA,EAAM,OAAOA,EAAM,SACxC,MAAM,kBAAkBE,CAAG;AACpC;AC9DO,SAASE,GAAmBC,GAAoC;AACrE,QAAMC,IAAK,IAAI;AAAA,IACbD,EAAK,IAAI,CAACE,MAAQA,EAAI,MAAM,EAAE,OAAO,CAACC,GAAGC,MAAMD,IAAIC,CAAC;AAAA,EAAA;AAGtD,MAAIC,IAAS;AACb,aAAWH,KAAOF;AACb,IAAAC,EAAA,IAAIC,GAAKG,CAAM,GAClBA,KAAUH,EAAI;AAGT,SAAAD;AACT;AAMO,SAASK,GACdC,GACgB;AAGhB,QAAMC,IAAgC,CAAA;AACtC,WAASC,IAAI,GAAGA,IAAIF,EAAU,QAAQE,KAAK;AAChC,aAAAC,IAAI,GAAGA,IAAIH,EAAUE,CAAC,EAAE,QAAQC,KAAK;AAC5C,MAAIF,EAAYE,CAAC,KAAK,SAAkBF,EAAAE,CAAC,IAAI,KAC7CF,EAAYE,CAAC,EAAE,KAAKH,EAAUE,CAAC,EAAEC,CAAC,CAAC;AAIhC,SAAAF,EAAY,IAAIT,EAAkB;AAC3C;AAKO,SAASY,GAAqBC,GAA+B;AAC9D,MAAAA,EAAG,WAAW,cAAc;AAC9B,UAAMX,IAAK,CAAA;AACX,aAASY,IAAM,GAAGA,IAAMD,EAAG,kBAAkBC,KAAO,GAAG;AACrD,YAAMC,IAAcF,EAAG,eAAe,EAAE,YAAYC,GAAK,GACnDE,IAAU,IAAI,YAAYD,CAAW;AAC3C,MAAAF,EAAG,OAAOG,GAAS,EAAE,YAAYF,EAAK,CAAA,GACtCZ,EAAG,KAAK,IAAI,aAAac,CAAO,CAAC;AAAA,IACnC;AACO,WAAAd;AAAA,EAAA,WACEW,EAAG,WAAW,OAAO;AACxB,UAAAV,IAAM,IAAI,YAAYU,EAAG,eAAe,EAAE,YAAY,EAAG,CAAA,CAAC;AAChE,WAAAA,EAAG,OAAOV,GAAK,EAAE,YAAY,EAAG,CAAA,GACzBc,GAAmB,IAAI,aAAad,CAAG,GAAGU,EAAG,gBAAgB;AAAA,EAAA,WAC3DA,EAAG,WAAW,OAAO;AACxB,UAAAV,IAAM,IAAI,YAAYU,EAAG,eAAe,EAAE,YAAY,EAAG,CAAA,CAAC;AAChE,WAAAA,EAAG,OAAOV,GAAK,EAAE,YAAY,EAAG,CAAA,GACzBe,GAAsB,IAAI,WAAWf,CAAG,GAAGU,EAAG,gBAAgB;AAAA,EACvE;AACA,QAAM,MAAM,+BAA+B;AAC7C;AAQA,SAASK,GAAsBC,GAAwBC,GAAqB;AACpE,QAAAC,IAAaF,EAAW,SAASC,GACjCE,IAAa,MAAM;AAAA,IACvB,EAAE,QAAQF,EAAY;AAAA,IACtB,MAAM,IAAI,aAAaC,CAAU;AAAA,EAAA;AAGnC,WAASX,IAAI,GAAGA,IAAIW,GAAYX;AAC9B,aAASa,IAAU,GAAGA,IAAUH,GAAaG,KAAW;AACtD,YAAMC,IAASL,EAAWT,IAAIU,IAAcG,CAAO;AACnD,MAAAD,EAAWC,CAAO,EAAEb,CAAC,IAAIc,IAAS;AAAA,IACpC;AAGK,SAAAF;AACT;AAEA,SAASL,GAAmBQ,GAA0BL,GAAqB;AACnE,QAAAC,IAAaI,EAAW,SAASL,GACjCE,IAAa,MAAM;AAAA,IACvB,EAAE,QAAQF,EAAY;AAAA,IACtB,MAAM,IAAI,aAAaC,CAAU;AAAA,EAAA;AAGnC,WAASX,IAAI,GAAGA,IAAIW,GAAYX;AAC9B,aAASa,IAAU,GAAGA,IAAUH,GAAaG;AAC3C,MAAAD,EAAWC,CAAO,EAAEb,CAAC,IAAIe,EAAWf,IAAIU,IAAcG,CAAO;AAI1D,SAAAD;AACT;AAKO,SAASI,GAAuBC,GAAiC;AAC/D,SAAA,MAAMA,EAAG,gBAAgB,EAC7B,KAAK,CAAC,EACN,IAAI,CAACC,GAAGd,MACAa,EAAG,eAAeb,CAAG,CAC7B;AACL;AAyCsB,eAAAe,GACpBC,GACAC,GACuB;;AACvB,QAAMC,IAAO;AAAA,IACX,MAAAD;AAAA,IACA,MAAMD;AAAA,EAAA,GAEFG,IAAe,IAAI,aAAaD,CAAI;AAEpC,QAAA,QAAQ,IAAI,CAACC,EAAa,WAAWA,EAAa,OAAO,KAAK,CAAC;AAErE,MAAIC,MAAWC,IAAAF,EAAa,OAAO,kBAApB,gBAAAE,EAAmC,eAAc;AAEhE,QAAMjC,IAAmB,CAAA;AACzB,WAASQ,IAAI,GAAGA,IAAIwB,GAAUxB,KAAK;AAC9B,IAAAR,EAAA,MAAM,MAAM+B,EAAa,OAAO,EAAE,YAAYvB,EAAA,CAAG,GAAG,KAAK;AAEvD,SAAAR;AACT;AAkBO,SAASkC,GAASC,GAAwC;;AAC/D,QAAMC,IAAS,KAAK,IAAI,GAAGD,EAAO,IAAI,CAAC,MAAA;;AAAM,aAAAF,IAAA,EAAE,CAAC,MAAH,gBAAAA,EAAM,WAAU;AAAA,GAAC,CAAC,GACzDI,IAAO,IAAI,aAAaD,IAAS,CAAC;AAExC,WAASE,IAAS,GAAGA,IAASF,GAAQE,KAAU;AAC9C,QAAIC,IAAQ,GACRC,IAAQ;AACZ,aAASC,IAAW,GAAGA,IAAWN,EAAO,QAAQM,KAAY;AAC3D,YAAMC,MAAMT,IAAAE,EAAOM,CAAQ,EAAE,CAAC,MAAlB,gBAAAR,EAAsBK,OAAW,GAEvCK,MAAMC,IAAAT,EAAOM,CAAQ,EAAE,CAAC,MAAlB,gBAAAG,EAAsBN,OAAWI;AACpC,MAAAH,KAAAG,GACAF,KAAAG;AAAA,IACX;AACA,IAAAN,EAAKC,CAAM,IAAIC,GACVF,EAAAC,IAASF,CAAM,IAAII;AAAA,EAC1B;AAEO,SAAAH;AACT;AAoBsB,eAAAQ,GACpBC,GACAC,GACAC,GAIyB;AACzB,QAAMC,IAAUH,EAAQ,QAClBI,IAAW,MAAMF,EAAO,SAAS,EACpC,KAAK,CAAC,EACN,IAAI,MAAM,IAAI,aAAa,CAAC,CAAC;AAC5B,MAAAC,MAAY,EAAU,QAAAC;AAEpB,QAAAC,IAAM,KAAK,IAAI,GAAGL,EAAQ,IAAI,CAACM,MAAMA,EAAE,MAAM,CAAC;AAChD,MAAAD,MAAQ,EAAU,QAAAD;AAGlB,MAAA,WAAW,uBAAuB;AACpC,WAAOJ,EAAQ;AAAA,MACb,CAACO,MACC,IAAI;AAAA,QACFC,GAAc,SAASD,GAAGN,GAASC,EAAO,MAAM;AAAA,UAC9C,QAAQ;AAAA,UACR,KAAK;AAAA,QAAA,CACN;AAAA,MACH;AAAA,IAAA;AAIA,QAAAnD,IAAM,IAAI,WAAW;AAAA,IACzBmD,EAAO;AAAA,IACNG,IAAMH,EAAO,OAAQD;AAAA,IACtBC,EAAO;AAAA,EAAA,GAEHO,IAAW1D,EAAI,sBACf4B,IAAK5B,EAAI,aAAaoD,GAASE,GAAKJ,CAAO;AACzC,SAAAD,EAAA,QAAQ,CAACU,GAAG5C,MAAQa,EAAG,cAAc+B,GAAG5C,CAAG,CAAC,GAEpD2C,EAAS,SAAS9B,GACT8B,EAAA,QAAQ1D,EAAI,WAAW,GAChC0D,EAAS,MAAM,GAER/B,GAAuB,MAAM3B,EAAI,eAAgB,CAAA;AAC1D;AAQO,SAAS4D,GAAMC,GAA6B;AAC1C,SAAA,IAAI,QAAQ,CAAC/D,MAAY;AACxB,UAAAgE,IAAOC,GAAY,MAAM;AACxB,MAAAD,KACGhE;OACP+D,CAAI;AAAA,EAAA,CACR;AACH;AAgBgB,SAAAG,GACdxB,GACAyB,GACAC,GACc;AACd,QAAMC,IAAMD,IAAMD,GACZ9D,IAAK,IAAI,aAAagE,CAAG;AAC/B,MAAIxD,IAAI;AACR,SAAOA,IAAIwD;AACT,IAAAhE,EAAGQ,CAAC,IAAI6B,GAAMyB,IAAQtD,KAAK6B,EAAK,MAAM,GACjC7B,KAAA;AAEA,SAAAR;AACT;AAqBgB,SAAAiE,GACdnB,GACAoB,GACA;AAEA,QAAMC,IAAY,KAAK,MAAMrB,EAAQ,SAASoB,CAAY,GACpDE,IAAa,IAAI,aAAaD,CAAS;AAG7C,WAAS3D,IAAI,GAAGA,IAAI2D,GAAW3D,KAAK;AAElC,UAAM6D,IAAgB7D,IAAI0D,GACpBI,IAAW,KAAK,MAAMD,CAAa,GACnCE,IAAOF,IAAgBC;AAGzB,IAAAA,IAAW,IAAIxB,EAAQ,SACdsB,EAAA5D,CAAC,IACVsC,EAAQwB,CAAQ,KAAK,IAAIC,KAAQzB,EAAQwB,IAAW,CAAC,IAAIC,IAEhDH,EAAA5D,CAAC,IAAIsC,EAAQwB,CAAQ;AAAA,EAEpC;AAEO,SAAAF;AACT;AChTO,MAAMI,IAAqB;AAAA,EAChC,YAAY;AAAA,EACZ,cAAc;AAAA,EACd,OAAO;AACT;ACpDgB,SAAAC,GAAkBC,GAAeC,GAAe;AACxD,QAAAC,IAASD,EAAK,YAAY,CAAC,GAC3B3E,IAKF,CAAA;AACJ,MAAI4E,KAAU,MAAM;AAClB,UAAMC,IAAYC,GAAoBJ,EAAK,aAAaE,EAAO,EAAE,CAAC,EAAE,QAC9D,EAAE,SAAAG,GAAS,MAAAlD,MAAS+C,EAAO,MAAM,WAAW,MAAM,IACpD,EAAE,SAAS,0BAA0B,MAAM,OAAO,IAClDA,EAAO,MAAM,WAAW,MAAM,IAC5B,EAAE,SAAS,2BAA2B,MAAM,OAAA,IAC5C,EAAE,SAAS,IAAI,MAAM,GAAG;AAC9B,IAAIG,MAAY,OACd/E,EAAG,iBAAiB;AAAA,MAClB,WAAW4E,EAAO;AAAA,MAClB,UAAUA,EAAO;AAAA,MACjB,OAAOA,EAAO,MAAM;AAAA,MACpB,QAAQA,EAAO,MAAM;AAAA,MACrB,QAAQD,EAAK;AAAA,MACb,MAAA9C;AAAA,MACA,CAACkD,CAAO,GAAGF;AAAA,IAAA,IAIf7E,EAAG,mBAAmB;AAAA,MACpB,OAAO4E,EAAO;AAAA,MACd,aAAaA,EAAO,MAAM;AAAA,MAC1B,YAAYA,EAAO,MAAM;AAAA,MACzB,aAAaC;AAAA,IAAA;AAAA,EAEjB;AAEM,QAAAG,IAASL,EAAK,YAAY,CAAC;AACjC,MAAIK,KAAU,MAAM;AACZ,UAAAC,IAAUC,GAAsBR,CAAI;AAC1C,IAAA1E,EAAG,iBAAiB;AAAA,MAClB,WAAWgF,EAAO;AAAA,MAClB,YAAYA,EAAO,MAAM;AAAA,MACzB,eAAeA,EAAO,MAAM;AAAA,MAC5B,MAAM;AAAA,MACN,MAAMA,EAAO,MAAM,WAAW,MAAM,IAAI,SAASA,EAAO;AAAA,MACxD,aAAaE,GAAsBR,CAAI;AAAA,IAAA,GAEzC1E,EAAG,mBAAmB;AAAA,MACpB,OAAOgF,EAAO,MAAM,WAAW,MAAM,IACjCR,EAAmB,QACnBQ,EAAO;AAAA,MACX,kBAAkBA,EAAO,MAAM;AAAA,MAC/B,YAAYA,EAAO,MAAM;AAAA,MACzB,GAAIC,KAAW,OAAO,KAAKE,GAAuBF,CAAO;AAAA,IAAA;AAAA,EAE7D;AACO,SAAAjF;AACT;AAGA,SAAS8E,GAAoBM,GAAkC;AAC7D,aAAWC,KAASD,EAAM,KAAK,KAAK,KAAK,KAAK,SAAS;AAErD,UAAME,IAAMD,EAAM,QAAQA,EAAM,QAAQA,EAAM,QAAQA,EAAM;AAC5D,QAAIC,KAAO,MAAM;AACT,YAAA1D,IAAS,IAAI2D,GAAO;AAAA,QACxB;AAAA,QACA;AAAA,QACAA,GAAO,WAAW;AAAA,MAAA;AAEpB,aAAAD,EAAI,MAAM1D,CAAM,GACT,IAAI,WAAWA,EAAO,OAAO,MAAM,CAAC,CAAC;AAAA,IAC9C;AAAA,EACF;AACA,QAAM,MAAM,mCAAmC;AACjD;AAEA,SAASsD,GAAsBR,GAAec,IAAQ,QAAQ;;AACtD,QAAAC,KAAUf,IAAAA,EAAK,SAALA,gBAAAA,EAAW,MACxB,IAAI,CAACgB,MAAMA,EAAE,KAAK,KAAK,KAAK,KAAK,SACjC,OACA,KAAK,CAAC,EAAE,MAAA7D,EAAW,MAAAA,MAAS2D;AAE/B,SAAOC,KAAA,gBAAAA,EAAS;AAClB;AAGA,SAASN,GAAuBQ,GAAqB;;AACnD,QAAMC,KAAc3D,IAAA0D,EAAK,IAAI,MAAM,CAAC,MAAhB,gBAAA1D,EAAmB,MAAM;AACzC,MAAA2D,KAAe,KAAM,QAAO;AAEhC,QAAM,CAACC,GAAOC,CAAK,IAAIF,EAAY,MAE7BG,MAAkBF,IAAQ,MAAS,MAAMC,KAAS,IAElDE,KAAoBF,IAAQ,QAAS;AAKpC,SAAA;AAAA,IACL,YALqB;AAAA,MACrB;AAAA,MAAO;AAAA,MAAO;AAAA,MAAO;AAAA,MAAO;AAAA,MAAO;AAAA,MAAO;AAAA,MAAO;AAAA,MAAO;AAAA,MAAO;AAAA,MAAO;AAAA,MACtE;AAAA,MAAM;AAAA,IAAA,EAGqBC,CAAa;AAAA,IACxC,kBAAAC;AAAA,EAAA;AAEJ;AAKsB,eAAAC,GACpBC,GACAC,GACAC,GAKA;AACM,QAAAC,IAAad,GAAO,WAAW,EAAK;AAC/B,EAAAc,EAAA,UAAU,CAAC1B,MAAS;;AACrB,IAAAwB,EAAA,EAAE,YAAAE,GAAY,MAAA1B,EAAA,CAAM;AAC5B,UAAM2B,KAAWrE,IAAA0C,EAAK,YAAY,CAAC,MAAlB,gBAAA1C,EAAqB;AACtC,IAAIqE,KAAY,QACdD,EAAW,qBAAqBC,GAAU,SAAS,EAAE,WAAW,KAAK;AAEvE,UAAMC,KAAW3D,IAAA+B,EAAK,YAAY,CAAC,MAAlB,gBAAA/B,EAAqB;AACtC,IAAI2D,KAAY,QACdF,EAAW,qBAAqBE,GAAU,SAAS,EAAE,WAAW,KAAK,GAEvEF,EAAW,MAAM;AAAA,EAAA,GAEnBA,EAAW,YAAYD,GAEvB,MAAMI,EAAM;AAEZ,iBAAeA,IAAQ;AACrB,QAAIC,IAAS;AACP,UAAAC,IAAc,KAAK,OAAO;AAChC,eAAa;AACX,YAAMrE,IAAQ,MAAM6D,EAAO,KAAKQ,GAAa;AAAA,QAC3C,IAAID;AAAA,MAAA,CACL;AACG,UAAApE,EAAK,eAAe,EAAG;AAC3B,MAAAA,EAAK,YAAYoE;AACX,YAAAE,IAAUN,EAAW,aAAahE,CAAI;AAC5C,UAAIsE,KAAW,KAAM;AACZ,MAAAF,IAAAE;AAAA,IACX;AAEA,IAAAN,EAAW,KAAK;AAAA,EAClB;AACF;AC1JA,IAAIO,KAAU;AAGd,SAASC,GAASC,GAA+B;AAC/C,SAAOA,EAAI,SAAS,UAAUA,EAAI,wBAAwB;AAC5D;;AAgDO,MAAMC,KAAN,MAAMA,GAAyB;AAAA,EA6DpC,YACEC,GACAC,IAAoB,IACpB;AA/DF,IAAAC,EAAA,MAAAC,IAASP;AAET,IAAAM,EAAA,MAAAE,IAAOC,EAAI,OAAO,cAAcC,EAAA,MAAKH,GAAM,GAAG;AAE9C,IAAAI,EAAA;AAEA,IAAAL,EAAA,MAAAM,IAAa;AAEb,IAAAN,EAAA,MAAAO,GAAQ;AAAA;AAAA,MAEN,UAAU;AAAA,MACV,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,iBAAiB;AAAA,MACjB,gBAAgB;AAAA,IAAA;AAOlB,IAAAP,EAAA,MAAAQ;AAEA,IAAAR,EAAA,MAAAS,GAAwD,CAAA;AAkBxD,IAAAT,EAAA,MAAAU,IAAU;AAEV,IAAAV,EAAA,MAAAW,GAAgC,CAAA;AAEhC,IAAAX,EAAA,MAAAY,IAAgC,CAAA;AAEhC,IAAAZ,EAAA,MAAAa,IAA6C;AAC7C,IAAAb,EAAA,MAAAc,IAA6C;AAE7C,IAAAd,EAAA,MAAAe,GAGI;AAAA,MACF,OAAO;AAAA,MACP,OAAO;AAAA,IAAA;AAGT,IAAAf,EAAA,MAAAgB,GAAqB,EAAE,OAAO;AAgF9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAX,EAAA,yBAGkB,OAAO7F,GAAGyG,MAAYA;AAqCxC,IAAAjB,EAAA,MAAAkB,IAAgB,IAAI;AAlHlB,QACE,EAAEpB,aAAkB,mBACpB,CAACH,GAASG,CAAM,KAChB,CAAC,MAAM,QAAQA,EAAO,YAAY;AAElC,YAAM,MAAM,kBAAkB;AAGhC,IAAAqB,EAAA,MAAKH,GAAQ,EAAE,OAAO,IAAM,GAAGjB,EAAK,IAC/BoB,EAAA,MAAAT,IACH,OAAOX,EAAK,SAAU,YAAY,YAAYA,EAAK,QAC/CA,EAAK,MAAM,SACX;AAEA,UAAAqB,IAAe,OAAOC,OACpB,MAAAC,GAAMlB,EAAA,MAAKI,IAAYa,CAAC,GACvBjB,EAAA,MAAKI;AAGT,IAAAW,EAAA,MAAAX,GAAab,GAASG,CAAM,IAC7BA,IACA,eAAeA,IACbA,EAAO,YACPyB,GAAQ,IAEd,KAAK,SACHzB,aAAkB,iBACdsB,EAAatB,CAAM,EAAE;AAAA,MAAK,CAAC0B,MACzBC,GAAiBD,GAAQpB,EAAA,MAAKY,EAAK;AAAA,IAErC,IAAArB,GAASG,CAAM,IACb2B,GAAiB3B,GAAQM,EAAA,MAAKY,EAAK,IACnC,QAAQ,QAAQlB,CAAM,GAC5B;AAAA,MACA,OAAO,EAAE,cAAA4B,GAAc,cAAAC,GAAc,aAAAjD,GAAa,cAAAkD,QAAmB;AACnE,QAAAT,EAAA,MAAKR,GAAgBe,IACrBP,EAAA,MAAKP,IAAgBe,IACrBR,EAAA,MAAKJ,GAAerC,IACpByC,EAAA,MAAKV,GAAgBmB;AAEf,cAAA,EAAE,kBAAAC,GAAkB,kBAAAC,EAAA,IAAqBC;AAAA,UAC7C;AAAA,YACE,OACErD,EAAY,SAAS,OACjB,OACA;AAAA,cACE,GAAGA,EAAY;AAAA,cACf,sBACE0B,EAAA,MAAKY,GAAM;AAAA,YACf;AAAA,YACN,OAAOtC,EAAY;AAAA,UACrB;AAAA,UACA,MAAM0B,EAAA,MAAKI,GAAW,aAAa;AAAA,UACnCkB;AAAA,UACAC;AAAA,UACAvB,EAAA,MAAKY,GAAM,UAAU,KAAQZ,EAAA,MAAKM,MAAU;AAAA,QAAA;AAE9C,eAAAS,EAAA,MAAKN,IAAoBgB,IACzBV,EAAA,MAAKL,IAAoBgB,IAEzBX,EAAA,MAAKZ,GAAQyB,GAAQtD,GAAagD,GAAcC,CAAY,IAC5DvB,EAAA,MAAKF,IAAK,KAAK,iBAAiBE,EAAA,MAAKG,EAAK,GACnC,EAAE,GAAGH,EAAA,MAAKG;MACnB;AAAA,IAAA;AAAA,EAEJ;AAAA,EAhHA,IAAI,OAAO;AACF,WAAA,EAAE,GAAGH,EAAA,MAAKG;EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,uBAAuB;AAC3B,UAAM,KAAK;AACX,UAAM0B,IAAQ,MAAM7B,EAAA,MAAKI,GAAW,cAAc;AAClD,QAAIyB,KAAS,KAAY,OAAA,MAAM,sCAAsC;AAErE,WAAO,MAAM,IAAI;AAAA,MACf7B,EAAA,MAAKK,GAAc;AAAA,QAAI,CAAC,EAAE,OAAA7D,GAAO,MAAAsF,QAC/BD,EAAM,MAAMrF,GAAOA,IAAQsF,CAAI;AAAA,MACjC;AAAA,MACA,YAAY;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EA4GA,MAAM,KAAK1F,GAIR;;AACG,QAAAA,KAAQ4D,EAAA,MAAKG,GAAM;AACd,aAAA,MAAM,KAAK,gBAAgB/D,GAAM;AAAA,QACtC,OAAQ,QAAMzB,IAAAqF,EAAA,MAAKU,QAAL,gBAAA/F,EAAwB,KAAKyB,OAAU,CAAC;AAAA,QACtD,OAAO;AAAA,MAAA,CACR;AAGH,UAAM,CAAC2F,GAAOC,CAAK,IAAI,MAAM,QAAQ,IAAI;AAAA,QACvC1G,IAAA0E,EAAA,MAAKU,QAAL,gBAAApF,EAAwB,KAAKc,OAAS,CAAC;AAAA,OACvC6F,IAAAjC,EAAA,MAAKS,QAAL,gBAAAwB,EAAwB,KAAK7F;AAAA,IAAI,CAClC;AAED,WAAI4F,KAAS,OACJ,MAAM,KAAK,gBAAgB5F,GAAM;AAAA,MACtC,OAAA2F;AAAA,MACA,OAAO;AAAA,IAAA,CACR,IAGI,MAAM,KAAK,gBAAgB3F,GAAM;AAAA,MACtC,OAAA4F;AAAA,MACA,OAAAD;AAAA,MACA,OAAO;AAAA,IAAA,CACR;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,WACJG,IAAW,KACXvC,GAC2C;AAC3C,IAAAK,EAAA,MAAKc,IAAc,SACdC,EAAA,MAAAD,IAAgB,IAAI;AACnB,UAAAqB,IAAgBnC,EAAA,MAAKc,IAAc;AAEzC,UAAM,KAAK;AACX,UAAMsB,IAAW;AACjB,QAAID,EAAc,QAAe,OAAA,MAAMC,CAAQ;AAE/C,UAAM,EAAE,OAAArK,GAAO,QAAAC,MAAWgI,EAAA,MAAKG,IACzBkC,IAASC;AAAA,MACbJ;AAAA,MACA,KAAK,MAAMlK,KAAUkK,IAAWnK,EAAM;AAAA,MACtC,EAAE,SAAS,KAAK,MAAM,YAAY;AAAA,IAAA;AAGpC,WAAO,IAAI;AAAA,MACT,OAAOM,GAASkK,MAAW;AACzB,YAAIC,IAAyD,CAAA;AACvD,cAAAC,IAAKzC,EAAA,MAAKW,GAAa;AAC7B,YAAI8B,KAAM,QAAQzC,EAAA,MAAKO,GAAc,WAAW,GAAG;AACxC,UAAAmC;AACT;AAAA,QACF;AACc,QAAAP,EAAA,iBAAiB,SAAS,MAAM;AACrC,UAAAI,EAAA,MAAMH,CAAQ,CAAC;AAAA,QAAA,CACvB;AAED,uBAAeM,IAAW;AACxB,UAAIP,EAAc,WAClB9J;AAAA,YACE,MAAM,QAAQ;AAAA,cACZmK,EAAY,IAAI,OAAOG,OAAQ;AAAA,gBAC7B,IAAIA,EAAG;AAAA,gBACP,KAAK,MAAMA,EAAG;AAAA,cAAA,EACd;AAAA,YACJ;AAAA,UAAA;AAAA,QAEJ;AAEA,iBAASC,EAAeC,GAAgB;AACtC,UAAAL,EAAY,KAAK;AAAA,YACf,IAAIK,EAAG;AAAA,YACP,KAAKR,EAAOQ,CAAE;AAAA,UAAA,CACf;AAAA,QACH;AAEM,cAAA,EAAE,OAAArG,IAAQ,GAAG,KAAAC,IAAMuD,EAAA,MAAKG,GAAM,UAAU,MAAA2C,EAAA,IAASnD,KAAQ;AAC/D,YAAImD,GAAM;AACR,cAAIC,IAAMvG;AAEV,gBAAMiF,IAAmB,IAAIuB;AAAA,YAC3B,MAAMhD,EAAA,MAAKI,GAAW,aAAa;AAAA,YACnCJ,EAAA,MAAKO;AAAA,YACL;AAAA,cACE,GAAGkC;AAAA,cACH,sBAAsBzC,EAAA,MAAKY,GAAM;AAAA,YACnC;AAAA,UAAA;AAEF,iBAAOmC,KAAOtG,KAAO,CAAC0F,EAAc,WAAS;AAC3C,kBAAMU,IAAK,MAAMpB,EAAiB,KAAKsB,CAAG;AACtC,YAAAF,OAAmBA,CAAE,GAClBE,KAAAD;AAAA,UACT;AACA,UAAArB,EAAiB,QAAQ,GAChBiB;QAAA;AAEH,gBAAAO;AAAA,YACJjD,EAAA,MAAKO;AAAA,YACLP,EAAA,MAAKI;AAAA,YACLqC;AAAA,YACAN;AAAA,YACA,EAAE,OAAA3F,GAAO,KAAAC,EAAI;AAAA,YACb,CAACoG,GAAIK,MAAS;AACR,cAAAL,KAAM,QAAMD,EAAeC,CAAE,GAC7BK,KAAeR;YACrB;AAAA,UAAA;AAAA,MAGN;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEA,MAAM,MAAMtG,GAAc;AAGxB,QAFA,MAAM,KAAK,OAEPA,KAAQ,KAAKA,KAAQ4D,EAAA,MAAKG,GAAM;AAClC,YAAM,MAAM,sBAAsB;AAE9B,UAAA,CAACgD,GAAeC,CAAc,IAAIC;AAAA,MACtCrD,EAAA,MAAKO;AAAA,MACLnE;AAAA,IAAA,GAEI,CAACkH,GAAeC,CAAc,IAAIC;AAAA,MACtCxD,EAAA,MAAKQ;AAAA,MACLpE;AAAA,IAAA,GAEIqH,IAAU,IAAIhE;AAAA,MAClB;AAAA,QACE,WAAWO,EAAA,MAAKI;AAAA,QAChB,cAAc+C,KAAiB,CAAC;AAAA,QAChC,cAAcG,KAAiB,CAAC;AAAA,QAChC,aAAatD,EAAA,MAAKW;AAAA,QAClB,cAAcX,EAAA,MAAKK;AAAA,MACrB;AAAA,MACAL,EAAA,MAAKY;AAAA,IAAA,GAED8C,IAAW,IAAIjE;AAAA,MACnB;AAAA,QACE,WAAWO,EAAA,MAAKI;AAAA,QAChB,cAAcgD,KAAkB,CAAC;AAAA,QACjC,cAAcG,KAAkB,CAAC;AAAA,QACjC,aAAavD,EAAA,MAAKW;AAAA,QAClB,cAAcX,EAAA,MAAKK;AAAA,MACrB;AAAA,MACAL,EAAA,MAAKY;AAAA,IAAA;AAEP,iBAAM,QAAQ,IAAI,CAAC6C,EAAQ,OAAOC,EAAS,KAAK,CAAC,GAE1C,CAACD,GAASC,CAAQ;AAAA,EAC3B;AAAA,EAEA,MAAM,QAAQ;AACZ,UAAM,KAAK;AACX,UAAMC,IAAO,IAAIlE;AAAA,MACf;AAAA,QACE,WAAWO,EAAA,MAAKI;AAAA,QAChB,cAAc,CAAC,GAAGJ,EAAA,MAAKO,EAAa;AAAA,QACpC,cAAc,CAAC,GAAGP,EAAA,MAAKQ,GAAa;AAAA,QACpC,aAAaR,EAAA,MAAKW;AAAA,QAClB,cAAcX,EAAA,MAAKK;AAAA,MACrB;AAAA,MACAL,EAAA,MAAKY;AAAA,IAAA;AAEP,iBAAM+C,EAAK,OACXA,EAAK,kBAAkB,KAAK,iBACrBA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,aAAa;AACjB,UAAM,KAAK;AACX,UAAMC,IAAmB,CAAA;AACrB,QAAA5D,EAAA,MAAKO,GAAc,SAAS,GAAG;AACjC,YAAMsD,IAAY,IAAIpE;AAAA,QACpB;AAAA,UACE,WAAWO,EAAA,MAAKI;AAAA,UAChB,cAAc,CAAC,GAAGJ,EAAA,MAAKO,EAAa;AAAA,UACpC,cAAc,CAAC;AAAA,UACf,aAAa;AAAA,YACX,OAAOP,EAAA,MAAKW,GAAa;AAAA,YACzB,OAAO;AAAA,UACT;AAAA,UACA,cAAcX,EAAA,MAAKK;AAAA,QACrB;AAAA,QACAL,EAAA,MAAKY;AAAA,MAAA;AAEP,YAAMiD,EAAU,OAChBA,EAAU,kBAAkB,KAAK,iBACjCD,EAAM,KAAKC,CAAS;AAAA,IACtB;AACI,QAAA7D,EAAA,MAAKQ,IAAc,SAAS,GAAG;AACjC,YAAMsD,IAAY,IAAIrE;AAAA,QACpB;AAAA,UACE,WAAWO,EAAA,MAAKI;AAAA,UAChB,cAAc,CAAC;AAAA,UACf,cAAc,CAAC,GAAGJ,EAAA,MAAKQ,GAAa;AAAA,UACpC,aAAa;AAAA,YACX,OAAOR,EAAA,MAAKW,GAAa;AAAA,YACzB,OAAO;AAAA,UACT;AAAA,UACA,cAAcX,EAAA,MAAKK;AAAA,QACrB;AAAA,QACAL,EAAA,MAAKY;AAAA,MAAA;AAEP,YAAMkD,EAAU,OAChBA,EAAU,kBAAkB,KAAK,iBACjCF,EAAM,KAAKE,CAAS;AAAA,IACtB;AAEO,WAAAF;AAAA,EACT;AAAA,EAEA,UAAgB;;AACd,IAAI5D,EAAA,MAAKE,QACJF,EAAA,MAAAF,IAAK,KAAK,iBAAiB,GAChCiB,EAAA,MAAKb,IAAa,MAElBvF,IAAAqF,EAAA,MAAKS,QAAL,QAAA9F,EAAwB,YACxBW,IAAA0E,EAAA,MAAKU,QAAL,QAAApF,EAAwB;AAAA,EAC1B;AACF;AA/XEuE,KAAA,eAEAC,KAAA,eAIAI,KAAA,eAEAC,IAAA,eAaAC,IAAA,eAEAC,IAAA,eAkBAC,KAAA,eAEAC,IAAA,eAEAC,KAAA,eAEAC,KAAA,eACAC,KAAA,eAEAC,IAAA,eAQAC,IAAA,eAwHAE,KAAA;AAnLK,IAAMiD,KAANtE;AAkYP,SAASmC,GACPtD,GACAgD,GACAC,GACA;AACA,QAAMyC,IAAO;AAAA,IACX,UAAU;AAAA,IACV,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,iBAAiB;AAAA,IACjB,gBAAgB;AAAA,EAAA;AAElB,EAAI1F,EAAY,SAAS,QAAQgD,EAAa,SAAS,MAChD0C,EAAA,QAAQ1F,EAAY,MAAM,cAAc,GACxC0F,EAAA,SAAS1F,EAAY,MAAM,eAAe,IAE7CA,EAAY,SAAS,QAAQiD,EAAa,SAAS,MACrDyC,EAAK,kBAAkB9G,EAAmB,YAC1C8G,EAAK,iBAAiB9G,EAAmB;AAG3C,MAAI+G,IAAY,GACZC,IAAY;AACZ,MAAA5C,EAAa,SAAS;AACxB,aAASpI,IAAIoI,EAAa,SAAS,GAAGpI,KAAK,GAAGA,KAAK;AAC3C,YAAA+H,IAAIK,EAAapI,CAAC;AACxB,UAAI,CAAA+H,EAAE,SACM;AAAA,QAAAgD,IAAAhD,EAAE,MAAMA,EAAE;AACtB;AAAA;AAAA,IACF;AAEE,MAAAM,EAAa,SAAS,GAAG;AACrB,UAAA4C,IAAc5C,EAAa,GAAG,EAAE;AAC1B,IAAA2C,IAAAC,EAAY,MAAMA,EAAY;AAAA,EAC5C;AACA,SAAAH,EAAK,WAAW,KAAK,IAAIC,GAAWC,CAAS,GAEtCF;AACT;AAEA,SAASrC,GACPrD,GACA8F,GACA9C,GACAC,GACA8C,GACA;AACO,SAAA;AAAA,IACL,kBACEA,MAAW,KAAK/F,EAAY,SAAS,QAAQiD,EAAa,WAAW,IACjE,OACA,IAAI+C;AAAA,MACFF;AAAA,MACA7C;AAAA,MACAjD,EAAY;AAAA,MACZ;AAAA,QACE,QAAA+F;AAAA,QACA,kBAAkBnH,EAAmB;AAAA,MACvC;AAAA,IACF;AAAA,IACN,kBACEoB,EAAY,SAAS,QAAQgD,EAAa,WAAW,IACjD,OACA,IAAI0B;AAAA,MACFoB;AAAA,MACA9C;AAAA,MACAhD,EAAY;AAAA,IACd;AAAA,EAAA;AAEV;AAEA,eAAe+C,GAAiBD,GAAsBzB,IAAoB,IAAI;AAC5E,MAAI4E,IAA0B;AAC9B,QAAMjG,IAA8B,EAAE,OAAO,MAAM,OAAO,KAAK;AAC/D,MAAIgD,IAA+B,CAAA,GAC/BC,IAA+B,CAAA,GAC/BC,IAAuD,CAAA,GAEvDgD,IAAe,IACfC,IAAe;AACb,QAAA7F,IAAS,MAAMwC,EAAO;AACtB,QAAAzC;AAAA,IACJC;AAAA,IACA,CAAC7D,MAAS;AACR,MAAAwJ,IAAUxJ,EAAK;AACT,YAAA2J,IAAO3J,EAAK,WAAW;AAChB,MAAAyG,EAAA,KAAK,EAAE,OAAOkD,EAAK,OAAO,MAAMA,EAAK,MAAM;AAClD,YAAAC,IAAO5J,EAAK,WAAW;AAChB,MAAAyG,EAAA,KAAK,EAAE,OAAOmD,EAAK,OAAO,MAAMA,EAAK,MAAM;AAExD,UAAI,EAAE,kBAAkBlC,GAAI,kBAAkBmC,EAAO,IAAAzH;AAAA,QACnDpC,EAAK;AAAA,QACLA,EAAK;AAAA,MAAA;AAEP,MAAAuD,EAAY,QAAQmE,KAAM,MAC1BnE,EAAY,QAAQsG,KAAM,MACtBnC,KAAM,QAAQmC,KAAM,QACtB7E,EAAI,MAAM,kCAAkC,GAE1CA,EAAA;AAAA,QACF;AAAA,QACA;AAAA,UACE,GAAGhF,EAAK;AAAA,UACR,QAAQ;AAAA,UACR,aAAa;AAAA,UACb,aAAa;AAAA,QACf;AAAA,QACAuD;AAAA,MAAA;AAAA,IAEJ;AAAA,IACA,CAAClE,GAAGG,GAAMsK,MAAY;AACpB,UAAItK,MAAS,SAAS;AACpB,QAAIiK,MAAiB,OAAmBA,IAAAK,EAAQ,CAAC,EAAE;AACnD,mBAAW5D,KAAK4D;AACd,UAAAvD,EAAa,KAAKwD,EAAmB7D,GAAGuD,GAAc,OAAO,CAAC;AAAA,MAEvD,WAAAjK,MAAS,WAAWoF,EAAK,OAAO;AACzC,QAAI8E,MAAiB,OAAmBA,IAAAI,EAAQ,CAAC,EAAE;AACnD,mBAAW5D,KAAK4D;AACd,UAAAtD,EAAa,KAAKuD,EAAmB7D,GAAGwD,GAAc,OAAO,CAAC;AAAA,MAElE;AAAA,IACF;AAAA,EAAA,GAEF,MAAM7F,EAAO;AAEb,QAAMuF,IAAc7C,EAAa,GAAG,EAAE,KAAKC,EAAa,GAAG,EAAE;AAC7D,MAAIgD,KAAW;AACb,UAAM,MAAM,4CAA4C;AAC1D,MAAWJ,KAAe;AACxB,UAAM,MAAM,uCAAuC;AAGrD,SAAAY,GAAmBzD,CAAY,GAC/BvB,EAAI,KAAK,mBAAmB,GACrB;AAAA,IACL,cAAAuB;AAAA,IACA,cAAAC;AAAA,IACA,aAAAjD;AAAA,IACA,cAAAkD;AAAA,EAAA;AAGF,WAASsD,EACP7D,GACA+D,IAAQ,GACRC,GACA;AAEM,UAAAC,IACJD,MAAe,WAAWhE,EAAE,UACxBkE,GAAclE,EAAE,MAAMA,EAAE,YAAY,IAAI,IACxC;AACN,QAAInI,IAASmI,EAAE,QACXa,IAAOb,EAAE;AACb,WAAIiE,KAAa,MAGLpM,KAAAoM,GACFpD,KAAAoD,IAEH;AAAA,MACL,GAAGjE;AAAA,MACH,QAAQiE,KAAa;AAAA,MACrB,QAAApM;AAAA,MACA,MAAAgJ;AAAA,MACA,MAAOb,EAAE,MAAM+D,KAAS/D,EAAE,YAAa;AAAA,MACvC,MAAOA,EAAE,MAAM+D,KAAS/D,EAAE,YAAa;AAAA,MACvC,UAAWA,EAAE,WAAWA,EAAE,YAAa;AAAA,MACvC,WAAW;AAAA;AAAA,MAEX,MAAMgE,MAAe,UAAU,OAAOhE,EAAE;AAAA,IAAA;AAAA,EAE5C;AACF;;AAEA,MAAM+B,GAAiB;AAAA,EAErB,YACSoB,GACAS,GACAO,GACP;AALF,IAAAxF,EAAA,MAAAyF,GAA4B;AAO5B,IAAAzF,EAAA,MAAA0F,IAAM;AACN,IAAA1F,EAAA,MAAA2F,IAAc,EAAE,OAAO,IAAO,IAAI,YAAY;AAC9C,IAAAtF,EAAA,cAAO,OAAO7D,MAA6C;AACzD,OACE4D,EAAA,MAAKqF,MAAQ,QACbrF,EAAA,MAAKqF,GAAK,UAAU,YACpBjJ,KAAQ4D,EAAA,MAAKsF,OACblJ,IAAO4D,EAAA,MAAKsF,MAAM,QAElBtF,EAAA,MAAKwF,IAAL,WAAYpJ,IAGd4D,EAAA,MAAKuF,IAAY,QAAQ,IACzBxE,EAAA,MAAKuE,IAAMlJ,IAEX2E,EAAA,MAAKwE,IAAc,EAAE,OAAO,IAAO,IAAI,YAAY;AAC7C,YAAA1C,IAAK,MAAM7C,EAAA,MAAKyF,IAAL,WAAiBrJ,GAAM4D,EAAA,MAAKqF,IAAMrF,EAAA,MAAKuF;AACxD,aAAAxE,EAAA,MAAK2E,IAAY,IACV7C;AAAA,IAAA;AAIT;AAAA,IAAAjD,EAAA,MAAA+F,IAAa;AAEb,IAAA/F,EAAA,MAAAgG,IAAuB;AACvB,IAAAhG,EAAA,MAAAiG,GAAoB;AACpB,IAAAjG,EAAA,MAAAkG,GAA6B,CAAA;AAC7B,IAAAlG,EAAA,MAAAmG,IAAkB;AAClB,IAAAnG,EAAA,MAAAoG,IAAiB;AACjB,IAAApG,EAAA,MAAA8F,IAAY;AACZ,IAAA9F,EAAA,MAAAqG,IAAgB;AAChB,IAAArG,EAAA,MAAA6F,IAAc,OACZrJ,GACA8J,GACAC,MAC+B;AAC/B,UAAID,KAAO,QAAQA,EAAI,UAAU,YAAYC,EAAQ,MAAc,QAAA;AAE/D,UAAAnG,EAAA,MAAK8F,GAAa,SAAS,GAAG;AAC1B,cAAAjD,IAAK7C,EAAA,MAAK8F,GAAa,CAAC;AAC1B,eAAA1J,IAAOyG,EAAG,YAAkB,QAEhC7C,EAAA,MAAK8F,GAAa,SAEd1J,IAAOyG,EAAG,aAAaA,EAAG,YAAY,MACxCA,EAAG,MAAM,GACF,MAAM7C,EAAA,MAAKyF,IAAL,WAAiBrJ,GAAM8J,GAAKC,OAGvC,CAACnG,EAAA,MAAKiG,OAAiBjG,EAAA,MAAK8F,GAAa,SAAS,MAEpD9F,EAAA,MAAKoG,IAAL,WAAkBF,GAAK,MAAM,CAACG,MAAQ;AACpC,gBAAAtF,EAAA,MAAKkF,IAAgB,KACrBjG,EAAA,MAAKwF,IAAL,WAAYpJ,IACNiK;AAAA,QAAA,CACP,GAGIxD;AAAA,MACT;AAIE,UAAA7C,EAAA,MAAKsG,OACJtG,EAAA,MAAK+F,MAAkB/F,EAAA,MAAKgG,OAAkBE,EAAI,kBAAkB,GACrE;AACA,YAAI,YAAY,IAAA,IAAQC,EAAQ,KAAK;AAC7B,gBAAA;AAAA,YACJ,+BAA+B,KAAK,UAAUnG,EAAA,MAAKuG,IAAL,UAAgB,CAAC;AAAA,UAAA;AAInE,QAAAxF,EAAA,MAAK2E,IAAL1F,EAAA,MAAK0F,MAAa,IAClB,MAAMvJ,GAAM,EAAE;AAAA,MACL,OAAA;AAAA,YAAA6D,EAAA,MAAK6F,MAAqB,KAAK,QAAQ;AAEzC,iBAAA;AAEH,YAAA;AACI,gBAAA7F,EAAA,MAAKoG,IAAL,WAAkBF;AAAA,iBACjBG,GAAK;AACZ,gBAAArG,EAAA,MAAKwF,IAAL,WAAYpJ,IACNiK;AAAA,QACR;AAAA;AAEF,aAAO,MAAMrG,EAAA,MAAKyF,IAAL,WAAiBrJ,GAAM8J,GAAKC;AAAA,IAAO;AAGlD,IAAAvG,EAAA,MAAA0G,IAAY;AACZ,IAAA1G,EAAA,MAAAwG,IAAe,OAAOF,MAAsB;;AAC1C,UAAIlG,EAAA,MAAKsG,OAAaJ,EAAI,kBAAkB,IAAK;AAG7C,UAAAM,IAASxG,EAAA,MAAK6F,KAAoB;AAClC,UAAAW,IAAS,KAAK,QAAQ,OAAQ;AAElC,MAAAzF,EAAA,MAAKuF,IAAY;AAEjB,UAAIG,IAAgB;AACpB,aAAOD,IAAS,KAAK,QAAQ,QAAQA,KAAU;AACvC,cAAAvF,IAAI,KAAK,QAAQuF,CAAM;AAK7B,YAJI,CAACC,KAAiB,CAACxF,EAAE,YACPwF,IAAA,KAGdxF,EAAE,OAAQ;AAAA,MAChB;AAEA,UAAIwF,GAAe;AACjB,cAAM5B,IAAU,KAAK,QAAQ,MAAM7E,EAAA,MAAK6F,IAAmBW,CAAM;AACjE,cAAI7L,IAAAkK,EAAQ,CAAC,MAAT,gBAAAlK,EAAY,YAAW;AACzB,UAAAoF,EAAI,KAAK,4BAA4B;AAAA,aAChC;AACC,gBAAA2G,IAAe,YAAY,OAC3BC,IAAS,MAAMC,GAAoB/B,GAAS,KAAK,eAAe,GAEhEgC,IAAW,YAAY,IAAA,IAAQH;AACrC,cAAIG,IAAW,KAAM;AACb,kBAAAC,IAAQjC,EAAQ,CAAC,GACjBkC,IAAOlC,EAAQ,GAAG,EAAE,GACpBmC,IAAWD,EAAK,SAASA,EAAK,OAAOD,EAAM;AAC7C,YAAA/G,EAAA;AAAA,cACF,iCAAiC,KAAK,MAAM8G,CAAQ,CAAC,wBAAwBG,CAAQ;AAAA,YAAA;AAAA,UAEzF;AAEI,cAAAd,EAAI,UAAU,SAAU;AAE5B,UAAAnF,EAAA,MAAK4E,MAAarK,IAAAqL,EAAO,CAAC,MAAR,gBAAArL,EAAW,aAAY,IACzC2L,GAAUf,GAAKS,GAAQ;AAAA,YACrB,iBAAiB,CAACN,MAAQ;AACxB,kBAAIrG,EAAA,MAAK4F;AACD,sBAAAS;AACR,cAAWrG,EAAA,MAAK+F,QAAoB,MAClChF,EAAA,MAAK6E,IAAuB,KAC5B7F,EAAI,KAAK,8BAA8B,GACvCC,EAAA,MAAKwF,IAAL;AAAA,YAEJ;AAAA,UAAA,CACD,GAEDzE,EAAA,MAAKiF,IAALhG,EAAA,MAAKgG,MAAkBW,EAAO;AAAA,QAChC;AAAA,MACF;AACA,MAAA5F,EAAA,MAAK8E,GAAoBW,IACzBzF,EAAA,MAAKuF,IAAY;AAAA,IAAA;AAGnB,IAAA1G,EAAA,MAAA4F,IAAS,CAACpJ,MAAkB;;AAItB,UAHJ2E,EAAA,MAAKuF,IAAY,KACjBtG,EAAA,MAAK8F,GAAa,QAAQ,CAACoB,MAAMA,EAAE,OAAO,GAC1CnG,EAAA,MAAK+E,GAAe,KAChB1J,KAAQ,QAAQA,MAAS;AAC3B,QAAA2E,EAAA,MAAK8E,GAAoB;AAAA,WACpB;AACL,YAAIsB,IAAS;AACb,iBAASjO,IAAI,GAAGA,IAAI,KAAK,QAAQ,QAAQA,KAAK;AACtC,gBAAA+H,IAAI,KAAK,QAAQ/H,CAAC;AAEpB,cADA+H,EAAE,WAAiBkG,IAAAjO,IACnB,EAAA+H,EAAE,MAAM7E,IACZ;AAAA,YAAA2E,EAAA,MAAK8E,GAAoBsB;AACzB;AAAA;AAAA,QACF;AAAA,MACF;AACA,MAAApG,EAAA,MAAKiF,IAAiB,IACtBjF,EAAA,MAAKgF,IAAkB,MACnBpL,IAAAqF,EAAA,MAAKqF,OAAL,gBAAA1K,EAAW,WAAU,cAAUW,IAAA0E,EAAA,MAAKqF,OAAL,QAAA/J,EAAW;AAC9C,YAAM8L,IAAc;AAAA,QAClB,GAAG,KAAK;AAAA,QACR,GAAIpH,EAAA,MAAK4F,MACL,EAAE,sBAAsB,sBACxB,CAAC;AAAA,MAAA;AAEF,MAAA7E,EAAA,MAAAsE,GAAO,IAAI,aAAa;AAAA,QAC3B,QAAQ,CAACxC,MAAO;AAEV,cADJ9B,EAAA,MAAKgF,IAAL/F,EAAA,MAAK+F,MAAmB,IACpBlD,EAAG,cAAc,IAAI;AACvB,YAAAA,EAAG,MAAM;AACT;AAAA,UACF;AACA,cAAIwE,IAAOxE;AACP,UAAAA,EAAG,YAAY,SACVwE,IAAA,IAAI,WAAWxE,GAAI;AAAA,YACxB,UAAU7C,EAAA,MAAK2F;AAAA,UAAA,CAChB,GACD9C,EAAG,MAAM,IAEN7C,EAAA,MAAA8F,GAAa,KAAKuB,CAAI;AAAA,QAC7B;AAAA,QACA,OAAO,CAAChB,MAAQ;AACd,cAAIA,EAAI,QAAQ,SAAS,mCAAmC,GAAG;AAE7D,YAAAtF,EAAA,MAAKsE,GAAO,OACRtF,EAAA,KAAKsG,EAAI,OAAO;AACpB;AAAA,UACF;AAEA,gBAAMiB,IAAS,iCAAiCjB,EAAI,OAAO,aAAa,KAAK,UAAUe,CAAW,CAAC,YAAY,KAAK,UAAUpH,EAAA,MAAKuG,IAAL,UAAgB,CAAC;AAC/I,gBAAAxG,EAAI,MAAMuH,CAAM,GACV,MAAMA,CAAM;AAAA,QACpB;AAAA,MAAA,CACD,IACItH,EAAA,MAAAqF,GAAK,UAAU+B,CAAW;AAAA,IAAA;AAGjC,IAAAxH,EAAA,MAAA2G,IAAY,MAAO;;AAAA;AAAA,QACjB,MAAMvG,EAAA,MAAKsF;AAAA,QACX,WAAU3K,IAAAqF,EAAA,MAAKqF,OAAL,gBAAA1K,EAAW;AAAA,QACrB,WAAUW,IAAA0E,EAAA,MAAKqF,OAAL,gBAAA/J,EAAW;AAAA,QACrB,aAAa0E,EAAA,MAAK6F;AAAA,QAClB,WAAW,KAAK,QAAQ;AAAA,QACxB,UAAU7F,EAAA,MAAKgG;AAAA,QACf,WAAWhG,EAAA,MAAK+F;AAAA,QAChB,eAAe/F,EAAA,MAAK8F,GAAa;AAAA,QACjC,YAAY9F,EAAA,MAAK4F;AAAA,QACjB,WAAWtG;AAAA,QACX,UAAUU,EAAA,MAAK0F;AAAA,QACf,SAAS6B,GAAgB;AAAA,MAAA;AAAA;AAG3B,IAAAtH,EAAA,iBAAU,MAAM;;AACd,QAAItF,IAAAqF,EAAA,MAAKqF,OAAL,gBAAA1K,EAAW,WAAU,cAAUW,IAAA0E,EAAA,MAAKqF,OAAL,QAAA/J,EAAW,UAC9CyF,EAAA,MAAKsE,GAAO,OACZrF,EAAA,MAAKuF,IAAY,QAAQ,IACzBvF,EAAA,MAAK8F,GAAa,QAAQ,CAACoB,MAAMA,EAAE,OAAO,GAC1CnG,EAAA,MAAK+E,GAAe,KACpB,KAAK,gBAAgB;IAAM;AAvOpB,SAAA,kBAAA1B,GACA,KAAA,UAAAS,GACA,KAAA,OAAAO;AAAA,EACN;AAsOL;AA3OEC,IAAA,eAOAC,KAAA,eACAC,KAAA,eAqBAI,KAAA,eAEAC,KAAA,eACAC,IAAA,eACAC,IAAA,eACAC,KAAA,eACAC,KAAA,eACAN,KAAA,eACAO,KAAA,eACAR,KAAA,eAyDAa,KAAA,eACAF,KAAA,eA2DAZ,KAAA,eAyDAe,KAAA;AAyBF,SAASiB,GAAmBpL,GAAcyI,GAAyB;AACjE,WAAS3L,IAAI,GAAGA,IAAI2L,EAAQ,QAAQ3L,KAAK;AACjC,UAAA+H,IAAI4D,EAAQ3L,CAAC;AACnB,QAAIkD,KAAQ6E,EAAE,OAAO7E,IAAO6E,EAAE,MAAMA,EAAE;AAC7B,aAAA/H;AAEL,QAAA+H,EAAE,MAAM7E,EAAM;AAAA,EACpB;AACO,SAAA;AACT;;AAEA,MAAMkI,GAAiB;AAAA,EAGrB,YACSF,GACAS,GACAO,GACPzF,GACA;AAPF,IAAAC,EAAA,MAAAU,IAAU;AACV,IAAAV,EAAA,MAAA6H;AAWA,IAAA7H,EAAA,MAAAyF,GAA2D;AAC3D,IAAAzF,EAAA,MAAA2F,IAAc,EAAE,OAAO,IAAO,IAAI,YAAY;AAC9C,IAAAtF,EAAA,cAAO,OAAO7D,MAA0C;AACtD,YAAMsL,IAAgBtL,KAAQ4D,EAAA,MAAKsF,MAAOlJ,IAAO4D,EAAA,MAAKsF,KAAM;AAC5D,OAAItF,EAAA,MAAKqF,MAAQ,QAAQrF,EAAA,MAAKqF,GAAK,UAAU,YAAYqC,MACvD1H,EAAA,MAAKwF,IAAL,YAGEkC,MAGF3G,EAAA,MAAKuE,GAAMlJ,IACX2E,EAAA,MAAK4G,IAAeH,GAAmBpL,GAAM,KAAK,OAAO,KAG3D4D,EAAA,MAAKuF,IAAY,QAAQ;AACnB,YAAAqC,IAAYxL,IAAO4D,EAAA,MAAKsF;AAC9B,MAAAvE,EAAA,MAAKuE,GAAMlJ,IAEX2E,EAAA,MAAKwE,IAAc,EAAE,OAAO,IAAO,IAAI,YAAY;AAE7C,YAAA/J,IAAU,MAAMwE,EAAA,MAAKyF,IAAL,WACpB,KAAK,KAAKmC,KAAa5H,EAAA,MAAKyH,MAAc,IAAI,GAC9CzH,EAAA,MAAKqF,IACLrF,EAAA,MAAKuF;AAEP,aAAAxE,EAAA,MAAK2E,IAAY,IACVlK;AAAA,IAAA;AAGT,IAAAoE,EAAA,MAAA0F,GAAM;AACN,IAAA1F,EAAA,MAAA+H,IAAe;AACf,IAAA/H,EAAA,MAAAiI,GAGI;AAAA,MACF,UAAU;AAAA,MACV,MAAM,CAAC;AAAA,IAAA;AAET,IAAAjI,EAAA,MAAA8F,IAAY;AACZ,IAAA9F,EAAA,MAAA6F,IAAc,OACZqC,GACA5B,IAA0D,MAC1DC,MAC4B;AAE1B,UAAAD,KAAO,QACPC,EAAQ,SACRD,EAAI,UAAU,YACd4B,MAAiB;AAEjB,eAAO;AAIH,YAAAC,IAAiB/H,EAAA,MAAK6H,GAAS,WAAWC;AAChD,UAAIC,IAAiB;AAEf,eAAAA,IAAiB7K,EAAmB,aAAa,MACnD8C,EAAA,MAAKoG,IAAL,WAAkBF,IAEb8B,GAAgBhI,EAAA,MAAK6H,IAAUC,CAAY;AAGpD,UAAI5B,EAAI,UAAU;AAChB,YAAI,YAAY,IAAA,IAAQC,EAAQ,KAAK;AACnC,gBAAAA,EAAQ,QAAQ,IACV;AAAA,YACJ,+BAA+B,KAAK,UAAUnG,EAAA,MAAKuG,IAAL,UAAgB,CAAC;AAAA,UAAA;AAInE,QAAAxF,EAAA,MAAK2E,IAAL1F,EAAA,MAAK0F,MAAa,IAClB,MAAMvJ,GAAM,EAAE;AAAA,MAAA;YACL6D,EAAA,MAAK2H,OAAgB,KAAK,QAAQ,SAAS;AAEpD,iBAAOK,GAAgBhI,EAAA,MAAK6H,IAAU7H,EAAA,MAAK6H,GAAS,QAAQ;AAE5D,QAAA7H,EAAA,MAAKoG,IAAL,WAAkBF;AAAA;AAEpB,aAAOlG,EAAA,MAAKyF,IAAL,WAAiBqC,GAAc5B,GAAKC;AAAA,IAAO;AAGpD,IAAAvG,EAAA,MAAAwG,IAAe,CAACF,MAAqD;AAE/D,UAAAA,EAAI,kBAAkB,GAAe;AAEzC,YAAMrB,IAAU,CAAA;AAChB,UAAI3L,IAAI8G,EAAA,MAAK2H;AACN,aAAAzO,IAAI,KAAK,QAAQ,UAAQ;AACxB,cAAA+H,IAAI,KAAK,QAAQ/H,CAAC;AAExB,YADKA,KAAA,GACD,CAAA+H,EAAE,YACN4D,EAAQ,KAAK5D,CAAC,GACV4D,EAAQ,UAAU;AAAe;AAAA,MACvC;AACA,MAAA9D,EAAA,MAAK4G,IAAezO,IAEhBgN,EAAA;AAAA,QACFrB,EAAQ;AAAA,UACN,CAAC5D,MACC,IAAI,kBAAkB;AAAA,YACpB,MAAM;AAAA,YACN,WAAWA,EAAE;AAAA,YACb,UAAUA,EAAE;AAAA,YACZ,MAAMA,EAAE;AAAA,UAAA,CACT;AAAA,QACL;AAAA,MAAA;AAAA,IACF;AAGF,IAAArB,EAAA,MAAA4F,IAAS,MAAM;;AACb,MAAAzE,EAAA,MAAKuE,GAAM,IACXvE,EAAA,MAAK4G,IAAe,IACpB5G,EAAA,MAAK8G,GAAW;AAAA,QACd,UAAU;AAAA,QACV,MAAM,CAAC;AAAA,MAAA,KAETlN,IAAAqF,EAAA,MAAKqF,OAAL,QAAA1K,EAAW,SACXoG,EAAA,MAAKsE,GAAO4C;AAAA,QACV,KAAK;AAAA,QACL;AAAA,UACE,cAAc/K,EAAmB;AAAA,UACjC,QAAQ8C,EAAA,MAAKM;AAAA,QACf;AAAA,QACA,CAAC4H,MAAW;AACL,UAAAlI,EAAA,MAAA6H,GAAS,KAAK,KAAKK,CAAsC,GAC9DlI,EAAA,MAAK6H,GAAS,YAAYK,EAAO,CAAC,EAAE;AAAA,QACtC;AAAA,MAAA;AAAA,IACF;AAGF,IAAAtI,EAAA,MAAA2G,IAAY,MAAO;;AAAA;AAAA,QACjB,MAAMvG,EAAA,MAAKsF;AAAA,QACX,WAAU3K,IAAAqF,EAAA,MAAKqF,OAAL,gBAAA1K,EAAW;AAAA,QACrB,WAAUW,IAAA0E,EAAA,MAAKqF,OAAL,gBAAA/J,EAAW;AAAA,QACrB,aAAa0E,EAAA,MAAK2H;AAAA,QAClB,WAAW,KAAK,QAAQ;AAAA,QACxB,QAAQ3H,EAAA,MAAK6H,GAAS;AAAA,QACtB,WAAWvI;AAAA,QACX,UAAUU,EAAA,MAAK0F;AAAA,QACf,SAAS6B,GAAgB;AAAA,MAAA;AAAA;AAG3B,IAAAtH,EAAA,iBAAU,MAAM;AACd,MAAAc,EAAA,MAAKsE,GAAO,OACZrF,EAAA,MAAKuF,IAAY,QAAQ,IACzBxE,EAAA,MAAK8G,GAAW;AAAA,QACd,UAAU;AAAA,QACV,MAAM,CAAC;AAAA,MAAA,IAET,KAAK,gBAAgB;IAAM;AAhKpB,SAAA,kBAAAzD,GACA,KAAA,UAAAS,GACA,KAAA,OAAAO,GAGPrE,EAAA,MAAKT,IAAUX,EAAK,SACpBoB,EAAA,MAAK0G,IAAc9H,EAAK;AAAA,EAC1B;AA2JF;AArKEW,KAAA,eACAmH,KAAA,eAWApC,IAAA,eACAE,KAAA,eA6BAD,IAAA,eACAqC,KAAA,eACAE,IAAA,eAOAnC,KAAA,eACAD,KAAA,eA2CAW,KAAA,eA4BAZ,KAAA,eAqBAe,KAAA;AAuBF,SAAS0B,GACP3J,GACAqB,GACAwI,GACA;AACA,MAAIC,IAAW,GACXC,IAAY;AACV,QAAAC,IAAgB,CAACJ,MAA2B;AAE5C,QADSG,KAAA,GACTH,EAAO,WAAW,GAElB;AAAA,UAAAvI,EAAK,WAAW;AAClB,mBAAW4I,KAAOL;AACP,mBAAAhP,IAAI,GAAGA,IAAIqP,EAAI,QAAQrP,IAAK,CAAAqP,EAAIrP,CAAC,KAAKyG,EAAK;AAIpD,MAAAuI,EAAO,WAAW,MAAYA,IAAA,CAACA,EAAO,CAAC,GAAGA,EAAO,CAAC,CAAC,IAEvDC,EAASD,CAAM;AAAA;AAAA,EAAA,GAEXM,IAAYC,GAAmCH,CAAa,GAE5DI,IAAe/I,EAAK,iBAAiBrB,EAAY;AACnD,MAAAqK,IAAO,IAAI,aAAa;AAAA,IAC1B,QAAQ,CAACtP,MAAO;AACR,YAAAkP,IAAMnP,GAAqBC,CAAE;AACnC,MAAIqP,IACFF;AAAA,QAAU,MACRjN,GAAcgN,GAAKlP,EAAG,YAAY;AAAA,UAChC,MAAMsG,EAAK;AAAA,UACX,WAAWtG,EAAG;AAAA,QAAA,CACf;AAAA,MAAA,IAGHiP,EAAcC,CAAG,GAEnBlP,EAAG,MAAM;AAAA,IACX;AAAA,IACA,OAAO,CAACgN,MAAQ;AACd,MAAIA,EAAI,QAAQ,SAAS,mCAAmC,KAG5DuC,EAAkB,4BAA4BvC,CAAY;AAAA,IAC5D;AAAA,EAAA,CACD;AACD,EAAAsC,EAAK,UAAUrK,CAAW;AAEjB,WAAAsK,EAAkBC,GAAmBxC,GAAY;AACxD,UAAMiB,IAAS,GAAGuB,CAAS,KAAMxC,EAAc,OAAO,YAAY,KAAK;AAAA,MACrE;AAAA,QACE,OAAOsC,EAAK;AAAA,QACZ,OAAOA,EAAK;AAAA,QACZ,UAAAP;AAAA,QACA,WAAAC;AAAA,MACF;AAAA,IACD,CAAA;AACD,UAAAtI,EAAI,MAAMuH,CAAM,GACV,MAAMA,CAAM;AAAA,EACpB;AAEO,SAAA;AAAA,IACL,OAAOX,GAA6B;AAClC,MAAAyB,KAAYzB,EAAO;AACf,UAAA;AACF,mBAAWmC,KAASnC,EAAa,CAAAgC,EAAA,OAAOG,CAAK;AAAA,eACtCzC,GAAK;AACZ,QAAAuC,EAAkB,4BAA4BvC,CAAY;AAAA,MAC5D;AAAA,IACF;AAAA,IACA,QAAQ;AACN,MAAIsC,EAAK,UAAU,YAAUA,EAAK,MAAM;AAAA,IAC1C;AAAA,IACA,IAAI,WAAW;AACN,aAAAP,IAAWC,KAAaM,EAAK,kBAAkB;AAAA,IACxD;AAAA,IACA,IAAI,QAAQ;AACV,aAAOA,EAAK;AAAA,IACd;AAAA,IACA,IAAI,kBAAkB;AACpB,aAAOA,EAAK;AAAA,IACd;AAAA,EAAA;AAEJ;AAGA,SAASF,GAAkCM,GAA6B;AACtE,QAAMC,IAAe,CAAA;AACrB,MAAIC,IAAa;AAER,WAAAC,EAASxQ,GAAOyQ,GAAiB;AACxC,IAAAH,EAAQG,CAAO,IAAIzQ,GACZ0Q;EACT;AAEA,WAASA,IAAS;AACV,UAAA1Q,IAAKsQ,EAAQC,CAAU;AAC7B,IAAIvQ,KAAM,SACVqQ,EAASrQ,CAAE,GAEGuQ,KAAA,GACPG;EACT;AAEA,MAAIC,IAAS;AACb,SAAO,CAACC,MAA2B;AACjC,UAAMH,IAAUE;AACN,IAAAA,KAAA,GACVC,EAAA,EACG,KAAK,CAAC5Q,MAAOwQ,EAASxQ,GAAIyQ,CAAO,CAAC,EAClC,MAAM,CAAC9C,MAAQ6C,EAAS7C,GAAK8C,CAAO,CAAC;AAAA,EAAA;AAE5C;AAEA,SAASnB,GACPxM,GACA+N,GACA;AAEM,QAAAxH,IAAQ,CAAC,IAAI,aAAawH,CAAO,GAAG,IAAI,aAAaA,CAAO,CAAC;AACnE,MAAIzQ,IAAS,GACTI,IAAI;AACD,SAAAA,IAAIsC,EAAQ,KAAK,UAAU;AAChC,UAAM,CAACP,GAAOC,CAAK,IAAIM,EAAQ,KAAKtC,CAAC;AACjC,QAAAJ,IAASmC,EAAM,SAASsO,GAAS;AACnC,YAAMC,IAASD,IAAUzQ;AACnB,MAAAiJ,EAAA,CAAC,EAAE,IAAI9G,EAAM,SAAS,GAAGuO,CAAM,GAAG1Q,CAAM,GACxCiJ,EAAA,CAAC,EAAE,IAAI7G,EAAM,SAAS,GAAGsO,CAAM,GAAG1Q,CAAM,GACtC0C,EAAA,KAAKtC,CAAC,EAAE,CAAC,IAAI+B,EAAM,SAASuO,GAAQvO,EAAM,MAAM,GAChDO,EAAA,KAAKtC,CAAC,EAAE,CAAC,IAAIgC,EAAM,SAASsO,GAAQtO,EAAM,MAAM;AACxD;AAAA,IAAA;AAEA,MAAA6G,EAAM,CAAC,EAAE,IAAI9G,GAAOnC,CAAM,GAC1BiJ,EAAM,CAAC,EAAE,IAAI7G,GAAOpC,CAAM,GAC1BA,KAAUmC,EAAM,QAChB/B;AAAA,EAEJ;AACA,SAAAsC,EAAQ,OAAOA,EAAQ,KAAK,MAAMtC,CAAC,GACnCsC,EAAQ,YAAY+N,GACbxH;AACT;AAEA,eAAe6E,GACb/B,GACAjG,GAC8B;AACxB,QAAAkI,IAAQjC,EAAQ,CAAC,GACjBkC,IAAOlC,EAAQ,GAAG,EAAE;AACtB,MAAAkC,KAAQ,KAAM,QAAO;AAEzB,QAAMC,IAAWD,EAAK,SAASA,EAAK,OAAOD,EAAM;AACjD,MAAIE,IAAW,KAAM;AAEnB,UAAMjM,IAAO,IAAI;AAAA,MACf,MAAM6D,EAAO,KAAKoI,GAAU,EAAE,IAAIF,EAAM,QAAQ;AAAA,IAAA;AAE3C,WAAAjC,EAAQ,IAAI,CAAC5D,MAAM;AAClB,YAAAnI,IAASmI,EAAE,SAAS6F,EAAM;AAChC,aAAO,IAAI,kBAAkB;AAAA,QAC3B,MAAM7F,EAAE,UAAU,QAAQ;AAAA,QAC1B,WAAWA,EAAE;AAAA,QACb,UAAUA,EAAE;AAAA,QACZ,MAAMlG,EAAK,SAASjC,GAAQA,IAASmI,EAAE,IAAI;AAAA,MAAA,CAC5C;AAAA,IAAA,CACF;AAAA,EACH;AAEA,SAAO,MAAM,QAAQ;AAAA,IACnB4D,EAAQ,IAAI,OAAO5D,MACV,IAAI,kBAAkB;AAAA,MAC3B,MAAMA,EAAE,UAAU,QAAQ;AAAA,MAC1B,WAAWA,EAAE;AAAA,MACb,UAAUA,EAAE;AAAA,MACZ,MAAM,MAAMrC,EAAO,KAAKqC,EAAE,MAAM;AAAA,QAC9B,IAAIA,EAAE;AAAA,MAAA,CACP;AAAA,IAAA,CACF,CACF;AAAA,EAAA;AAEL;AAEA,SAASqB,GACPvK,GACAC,GACA2H,GACA;AACA,QAAMrH,IAAM,IAAI,gBAAgBP,GAAOC,CAAM,GACvCO,IAAMD,EAAI,WAAW,IAAI;AAE/B,SAAO,OAAOuK,OACZtK,EAAI,UAAUsK,GAAI,GAAG,GAAG9K,GAAOC,CAAM,GACrC6K,EAAG,MAAM,GACI,MAAMvK,EAAI,cAAcqH,CAAI;AAG7C;AAEA,SAAS0D,GAAuB/B,GAA8BlF,GAAc;AAC1E,MAAIkF,EAAa,WAAW,EAAG,QAAO,CAAA;AACtC,MAAImI,IAAc,GACdC,IAAY,GACZC,IAAS;AACb,WAASzQ,IAAI,GAAGA,IAAIoI,EAAa,QAAQpI,KAAK;AACtC,UAAA+H,IAAIK,EAAapI,CAAC;AAExB,QADIyQ,MAAW,MAAMvN,IAAO6E,EAAE,YAAc/H,IAAI,IAC5C+H,EAAE;AACJ,UAAI0I,MAAW;AACC,QAAAF,IAAAvQ;AAAA,WACT;AACO,QAAAwQ,IAAAxQ;AACZ;AAAA,MACF;AAAA,EAEJ;AAEM,QAAA0Q,IAAYtI,EAAaqI,CAAM;AACrC,MAAIC,KAAa,KAAY,OAAA,MAAM,gCAAgC;AAEnE,QAAMC,IAAWvI,EACd,MAAM,GAAGoI,MAAc,IAAIpI,EAAa,SAASoI,CAAS,EAC1D,IAAI,CAACzI,OAAO,EAAE,GAAGA,EAAI,EAAA;AACxB,WAAS/H,IAAIuQ,GAAavQ,IAAI2Q,EAAS,QAAQ3Q,KAAK;AAC5C,UAAA+H,IAAI4I,EAAS3Q,CAAC;AAChB,IAAAkD,IAAO6E,EAAE,QACXA,EAAE,UAAU,IACZA,EAAE,MAAM;AAAA,EAEZ;AACA,EAAA8D,GAAmB8E,CAAQ;AAE3B,QAAMC,IAAYxI,EACf,MAAMsI,EAAU,SAASD,IAASF,CAAW,EAC7C,IAAI,CAACxI,OAAO,EAAE,GAAGA,GAAG,KAAKA,EAAE,MAAM7E,EAAO,EAAA;AAE3C,aAAW6E,KAAK6I;AACV,IAAA7I,EAAE,MAAM,MACVA,EAAE,UAAU,IACZA,EAAE,MAAM;AAGZ,SAAA8D,GAAmB+E,CAAS,GAErB,CAACD,GAAUC,CAAS;AAC7B;AAEA,SAAStG,GAAuBjC,GAA8BnF,GAAc;AAC1E,MAAImF,EAAa,WAAW,EAAG,QAAO,CAAA;AACtC,MAAIoI,IAAS;AACb,WAASzQ,IAAI,GAAGA,IAAIqI,EAAa,QAAQrI,KAAK;AACtC,UAAA+H,IAAIM,EAAarI,CAAC;AACpB,QAAA,EAAAkD,IAAO6E,EAAE,MACJ;AAAA,MAAA0I,IAAAzQ;AACT;AAAA;AAAA,EACF;AACA,MAAIyQ,MAAW,GAAU,OAAA,MAAM,gCAAgC;AAC/D,QAAME,IAAWtI,EAAa,MAAM,GAAGoI,CAAM,EAAE,IAAI,CAAC1I,OAAO,EAAE,GAAGA,EAAA,EAAI,GAC9D6I,IAAYvI,EACf,MAAMoI,CAAM,EACZ,IAAI,CAAC1I,OAAO,EAAE,GAAGA,GAAG,KAAKA,EAAE,MAAM7E,EAAO,EAAA;AACpC,SAAA,CAACyN,GAAUC,CAAS;AAC7B;AAGA,SAAS7C,GACPf,GACAS,GACAhH,GAGA;AACA,MAAI,IAAI;AACJ,MAAAuG,EAAI,UAAU,cACX;AAAA,WAAA,IAAIS,EAAO,QAAQ,OAAS,OAAOA,EAAO,CAAC,CAAC;AAInD,IAAAT,EAAI,MAAM,EAAE,MAAM,CAACG,MAAQ;AACrB,UAAA,EAAEA,aAAe,OAAc,OAAAA;AACnC,UACEA,EAAI,QAAQ,SAAS,gBAAgB,KACrC1G,EAAK,mBAAmB,MACxB;AACA,QAAAA,EAAK,gBAAgB0G,CAAG;AACxB;AAAA,MACF;AAEA,UAAI,CAACA,EAAI,QAAQ,SAAS,sBAAsB;AACxC,cAAAA;AAAA,IACR,CACD;AAAA;AACH;AAEA,SAASlB,GACP4E,GACAxP,GACA;AACA,MAAIA,MAAS,UAAUA,MAAS,OAAe,QAAA;AAE/C,QAAMyP,IAAK,IAAI,SAASD,EAAM,MAAM;AACpC,MAAI,IAAI;AACD,SAAA,IAAIA,EAAM,aAAa,KAAK;AAC7B,QAAAxP,MAAS,WAAWyP,EAAG,SAAS,IAAI,CAAC,IAAI,QAAU;AAC9C,aAAA;AACT,QAAWzP,MAAS,QAAQ;AAC1B,YAAM0P,IAAeD,EAAG,SAAS,IAAI,CAAC,KAAK,IAAK;AAChD,UAAIC,MAAgB,MAAMA,MAAgB,GAAW,QAAA;AAAA,IACvD;AAEK,SAAAD,EAAG,UAAU,CAAC,IAAI;AAAA,EACzB;AACO,SAAA;AACT;AAEA,eAAe/G,GACb4B,GACAqF,GACAC,GACAC,GACAhO,GACAiO,GACA;AACM,QAAAC,IAAa,MAAMJ,EAAU,gBAE7BvD,IAAS,MAAMC;AAAA,IACnB/B,EAAQ;AAAA,MACN,CAAC5D,MACC,CAACA,EAAE,WAAWA,EAAE,WAAWA,EAAE,OAAO7E,EAAK,SAAS6E,EAAE,OAAO7E,EAAK;AAAA,IACpE;AAAA,IACAkO;AAAA,EAAA;AAEF,MAAI3D,EAAO,WAAW,KAAKyD,EAAW,QAAS;AAE/C,MAAI/B,IAAY;AACN,EAAApB,GAAAsD,KAAkB5D,GAAQ;AAAA,IAClC,iBAAiB,CAACN,MAAQ;AACpB,MAAAtG,EAAA,KAAK,wBAAwBsG,CAAG,GAEhCgC,MAAc,IACNpB,GAAAsD,EAAe,EAAI,GAAG5D,GAAQ;AAAA,QACtC,iBAAiB,CAACN,MAAQ;AACxB,UAAAiE,EAAW,MAAM,GACbvK,EAAA,MAAM,0CAA0CsG,CAAG;AAAA,QACzD;AAAA,MAAA,CACD,KAEDgE,EAAS,MAAM,EAAI,GACnBC,EAAW,MAAM;AAAA,IAErB;AAAA,EAAA,CACD;AAEQ,WAAAC,EAAeC,IAAY,IAAO;AACzC,UAAMpD,IAAc;AAAA,MAClB,GAAG+C;AAAA,MACH,GAAIK,IAAY,EAAE,sBAAsB,sBAAsB,CAAC;AAAA,IAAA,GAE3DtE,IAAM,IAAI,aAAa;AAAA,MAC3B,QAAQ,CAACrD,MAAO;AACD,QAAAwF,KAAA;AACP,cAAAnF,IAAOmF,MAAc1B,EAAO;AAClC,QAAA0D,EAASxH,GAAIK,CAAI,GACbA,MACFoH,EAAW,MAAM,GACbpE,EAAI,UAAU,YAAUA,EAAI,MAAM;AAAA,MAE1C;AAAA,MACA,OAAO,CAACG,MAAQ;AACR,cAAAiB,IAAS,6BAA6BjB,EAAI,OAAO,aAAa,KAAK,UAAUe,CAAW,CAAC,YAAY,KAAK;AAAA,UAC9G;AAAA,YACE,OAAOlB,EAAI;AAAA,YACX,OAAOA,EAAI;AAAA,YACX,WAAAmC;AAAA,YACA,UAAU1B,EAAO;AAAA,UACnB;AAAA,QACD,CAAA;AACD,cAAA5G,EAAI,MAAMuH,CAAM,GACV,MAAMA,CAAM;AAAA,MACpB;AAAA,IAAA,CACD;AACU,WAAA8C,EAAA,iBAAiB,SAAS,MAAM;AACzC,MAAAE,EAAW,MAAM,GACbpE,EAAI,UAAU,YAAUA,EAAI,MAAM;AAAA,IAAA,CACvC,GACDA,EAAI,UAAUkB,CAAW,GAClBlB;AAAA,EACT;AACF;AAGA,SAASnB,GAAmBF,GAAyB;AACnD,MAAI4F,IAAY,GACZC,IAAoC;AAExC,aAAWzJ,KAAK4D;AACd,QAAI,CAAA5D,EAAE,SAGN;AAAA,UADIA,EAAE,YAAsBwJ,KAAA,IACxBA,KAAa,EAAG;AAEpB,OAAIC,KAAgB,QAAQzJ,EAAE,MAAMyJ,EAAa,SAChCA,IAAAzJ;AAAA;AAInB,EAAIyJ,KAAgB,QAAQA,EAAa,MAAM,QAC7CA,EAAa,YAAYA,EAAa,KACtCA,EAAa,MAAM;AAEvB;AAEA,SAASnD,KAAkB;AACrB,MAAA;AAEF,UAAMoD,IAAM,YAAY;AACjB,WAAA;AAAA,MACL,iBAAiBA,EAAI;AAAA,MACrB,iBAAiBA,EAAI;AAAA,MACrB,gBAAgBA,EAAI;AAAA,MACpB,cAAcA,EAAI,iBAAiBA,EAAI,iBAAiB,QAAQ,CAAC;AAAA,MACjE,eAAeA,EAAI,kBAAkBA,EAAI,iBAAiB,QAAQ,CAAC;AAAA,IAAA;AAAA,UAEzD;AACZ,WAAO;EACT;AACF;;ACl6CO,MAAMC,KAAN,MAAMA,GAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA6BpC,YACEC,GAKA;AAnCG,IAAAjL,EAAA,MAAAkL;AACL,IAAA7K,EAAA;AAEA,IAAAL,EAAA,MAAAO,GAAQ;AAAA;AAAA,MAEN,UAAU;AAAA,MACV,OAAO;AAAA,MACP,QAAQ;AAAA,IAAA;AAaV,IAAAP,EAAA,MAAAmL,GAA2B;AAE3B,IAAAnL,EAAA,MAAAoL,GAAwB,CAAA;AA2ExB,IAAA/K,EAAA,yBAGkB,OAAO7F,GAAGyG,MAAYA;AAhEhC,UAAAoK,IAAoB,CAACC,OACzBnK,EAAA,MAAKgK,GAAOG,IACPlL,EAAA,MAAAG,GAAM,QAAQ+K,EAAU,OACxBlL,EAAA,MAAAG,GAAM,SAAS+K,EAAU,QAC9BlL,EAAA,MAAKG,GAAM,WAAW,OACf,EAAE,GAAGH,EAAA,MAAKG;AAGnB,QAAI0K,aAAsB;AACxB,WAAK,QAAQ,IAAI,SAASA,CAAU,EACjC,KAAK,EACL,KAAK,CAAC9P,MAAS,kBAAkBA,CAAI,CAAC,EACtC,KAAKkQ,CAAiB;AAAA,aAChBJ,aAAsB;AAC/B,WAAK,QAAQ,QAAQ,QAAQI,EAAkBJ,CAAU,CAAC;AAAA,aAE1D,MAAM,QAAQA,CAAU,KACxBA,EAAW,MAAM,CAAClI,MAAOA,aAAc,UAAU,GACjD;AACA,MAAA5B,EAAA,MAAKiK,GAAUH;AACT,YAAAM,IAAQnL,EAAA,MAAKgL,GAAQ,CAAC;AAC5B,UAAIG,KAAS,KAAY,OAAA,MAAM,wCAAwC;AACvE,MAAApK,EAAA,MAAKZ,GAAQ;AAAA,QACX,OAAOgL,EAAM;AAAA,QACb,QAAQA,EAAM;AAAA,QACd,UAAUnL,EAAA,MAAKgL,GAAQ;AAAA,UACrB,CAACI,GAAKrI,MAAQqI,KAAOrI,EAAI,YAAY;AAAA,UACrC;AAAA,QACF;AAAA,MAAA,IAEG,KAAA,QAAQ,QAAQ,QAAQ,EAAE,GAAG/C,EAAA,MAAKG,IAAO,UAAU,MAAA,CAAU;AAAA,IAAA,WACzD,UAAU0K;AACnB,WAAK,QAAQQ,EAAA,MAAKP,IAAAQ,IAAL,WACXT,EAAW,QACXA,EAAW,MACX,KAAK,OAAO;AAAA,QACZ,OAAO7K,EAAA,MAAKG,GAAM;AAAA,QAClB,QAAQH,EAAA,MAAKG,GAAM;AAAA,QACnB,UAAU;AAAA,MACV,EAAA;AAAA;AAEF,YAAM,MAAM,mBAAmB;AAAA,EAEnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA/DA,IAAI,OAAO;AACF,WAAA,EAAE,GAAGH,EAAA,MAAKG;EACnB;AAAA,EAoFA,MAAM,KAAK/D,GAGR;AACG,QAAA4D,EAAA,MAAK+K,MAAQ;AACR,aAAA,MAAM,KAAK,gBAAgB3O,GAAM;AAAA,QACtC,OAAO,MAAM,kBAAkB4D,EAAA,MAAK+K,EAAI;AAAA,QACxC,OAAO;AAAA,MAAA,CACR;AAEG,UAAAQ,IAAKnP,IAAO4D,EAAA,MAAKG,GAAM;AACtB,WAAA,MAAM,KAAK,gBAAgB/D,GAAM;AAAA,MACtC,QACE4D,EAAA,MAAKgL,GAAQ;AAAA,QACX,CAAC9D,MAAMqE,KAAMrE,EAAE,aAAaqE,KAAMrE,EAAE,aAAaA,EAAE,YAAY;AAAA,MAC5D,KAAAlH,EAAA,MAAKgL,GAAQ,CAAC,GACnB,MAAM;AAAA,MACR,OAAO;AAAA,IAAA,CACR;AAAA,EACH;AAAA,EAEA,MAAM,MAAM5O,GAAc;AAEpB,QADJ,MAAM,KAAK,OACP4D,EAAA,MAAK+K,MAAQ;AACR,aAAA;AAAA,QACL,IAAIH,GAAQ,MAAM,kBAAkB5K,EAAA,MAAK+K,EAAI,CAAC;AAAA,QAC9C,IAAIH,GAAQ,MAAM,kBAAkB5K,EAAA,MAAK+K,EAAI,CAAC;AAAA,MAAA;AAGlD,QAAIpB,IAAS;AACb,aAASzQ,IAAI,GAAGA,IAAI8G,EAAA,MAAKgL,GAAQ,QAAQ9R,KAAK;AACtC,YAAA2J,IAAK7C,EAAA,MAAKgL,GAAQ9R,CAAC;AACrB,UAAA,EAAAkD,IAAOyG,EAAG,YACL;AAAA,QAAA8G,IAAAzQ;AACT;AAAA;AAAA,IACF;AACA,QAAIyQ,MAAW,GAAU,OAAA,MAAM,yBAAyB;AACxD,UAAME,IAAW7J,EAAA,MAAKgL,GACnB,MAAM,GAAGrB,CAAM,EACf,IAAI,CAAC9G,MAAO,IAAI,WAAWA,CAAE,CAAC,GAC3BiH,IAAY9J,EAAA,MAAKgL,GAAQ,MAAMrB,CAAM,EAAE;AAAA,MAC3C,CAAC9G,MACC,IAAI,WAAWA,GAAI;AAAA,QACjB,WAAWA,EAAG,YAAYzG;AAAA,MAAA,CAC3B;AAAA,IAAA;AAEE,WAAA,CAAC,IAAIwO,GAAQf,CAAQ,GAAG,IAAIe,GAAQd,CAAS,CAAC;AAAA,EACvD;AAAA,EAEA,MAAM,QAAQ;AACZ,UAAM,KAAK;AACX,UAAM/O,IACJiF,EAAA,MAAK+K,MAAQ,OACT/K,EAAA,MAAKgL,GAAQ,IAAI,CAACnI,MAAOA,EAAG,OAAO,IACnC,MAAM,kBAAkB7C,EAAA,MAAK+K,EAAI;AAChC,WAAA,IAAIH,GAAQ7P,CAAI;AAAA,EACzB;AAAA,EAEA,UAAgB;;AACd,IAAAgF,EAAI,KAAK,iBAAiB,IAC1BpF,IAAAqF,EAAA,MAAK+K,OAAL,QAAApQ,EAAW,SACXqF,EAAA,MAAKgL,GAAQ,QAAQ,CAAC9D,MAAMA,EAAE,OAAO;AAAA,EACvC;AACF;AAlKE/G,IAAA,eAiBA4K,IAAA,eAEAC,IAAA,eAtBKF,KAAA,eAiFCQ,KACJ,eAAAhR,GACAC,GACA;AACA,EAAAwG,EAAA,MAAKiK,GAAU,MAAM3Q,GAAUC,GAAQC,CAAI;AACrC,QAAAiR,IAAUxL,EAAA,MAAKgL,GAAQ,CAAC;AAC9B,MAAIQ,KAAW,KAAY,OAAA,MAAM,2BAA2B;AAE5D,EAAAzK,EAAA,MAAKZ,GAAQ;AAAA,IACX,UAAUH,EAAA,MAAKgL,GAAQ,OAAO,CAACI,GAAKrI,MAAQqI,KAAOrI,EAAI,YAAY,IAAI,CAAC;AAAA,IACxE,OAAOyI,EAAQ;AAAA,IACf,QAAQA,EAAQ;AAAA,EAAA,IAEdzL,EAAA,KAAK,kBAAkBC,EAAA,MAAKG,EAAK;AACvC;AA/FK,IAAMsL,KAANb;;ACHA,MAAMc,KAAN,MAAMA,GAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyCtC,YACEb,GACAlL,IAAuB,IACvB;AA5CG,IAAAC,EAAA,MAAA+L;AAGL,IAAA1L,EAAA;AAEA,IAAAL,EAAA,MAAAO,IAAQ;AAAA;AAAA,MAEN,UAAU;AAAA,MACV,OAAO;AAAA,MACP,QAAQ;AAAA,IAAA;AAgBV,IAAAP,EAAA,MAAAgM,IAAY,IAAI;AAChB,IAAAhM,EAAA,MAAAiM,IAAY,IAAI;AAQhB,IAAAjM,EAAA,MAAAgB;AAmEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAX,EAAA,yBAGkB,OAAO7F,GAAGyG,MAAYA;AAGxC;AAAA,IAAAjB,EAAA,MAAA0F,IAAM;AACN,IAAA1F,EAAA,MAAAkM,GAAe;AA/Db,IAAA/K,EAAA,MAAKH,GAAQ;AAAA,MACX,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,GAAGjB;AAAA,IAAA,IAGL,KAAK,QAAQ0L,EAAA,MAAKM,IAAAI,IAAL,WAAWlB,GAAY,KAAK,OAAO;AAAA;AAAA,MAE9C,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,UAAUlL,EAAK,OAAO,QAAWK,EAAA,MAAKG,IAAM;AAAA,IAC5C,EAAA;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAxCA,IAAI,OAAO;AACF,WAAA;AAAA,MACL,GAAGH,EAAA,MAAKG;AAAA,MACR,YAAYjD,EAAmB;AAAA,MAC/B,WAAW;AAAA,IAAA;AAAA,EAEf;AAAA;AAAA;AAAA;AAAA,EAOA,aAA6B;AAC3B,WAAO,CAAC8C,EAAA,MAAK4L,KAAW5L,EAAA,MAAK6L,GAAS;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsFA,MAAM,KAAKzP,GAGR;AACD,QAAI,CAAC4D,EAAA,MAAKY,GAAM,QAAQxE,KAAQ4D,EAAA,MAAKG,IAAM;AAElC,aAAA,MAAM,KAAK,gBAAgB/D,GAAM,EAAE,OAAO,IAAI,OAAO,OAAA,CAAQ;AAGhE,UAAAwL,IAAYxL,IAAO4D,EAAA,MAAKsF;AAG9B,QAAIlJ,IAAO4D,EAAA,MAAKsF,OAAOsC,IAAY;AACjC,aAAA7G,EAAA,MAAKuE,IAAMlJ,IACX2E,EAAA,MAAK+K,GAAe,KAAK;AAAA,QACtB9L,EAAA,MAAKsF,MAAM,MAAOpI,EAAmB;AAAA,MAAA,IAEjC,MAAM,KAAK,gBAAgBd,GAAM;AAAA,QACtC,OAAO,CAAC,IAAI,aAAa,CAAC,GAAG,IAAI,aAAa,CAAC,CAAC;AAAA,QAChD,OAAO;AAAA,MAAA,CACR;AAGH,IAAA2E,EAAA,MAAKuE,IAAMlJ;AACX,UAAM1B,IAAW,KAAK;AAAA,MACnBkN,IAAY,MAAO1K,EAAmB;AAAA,IAAA,GAEnCsJ,IAASxG,EAAA,MAAK8L,KAAepR,GAC7BqH,IAAQ/B,EAAA,MAAKY,GAAM,OACrB;AAAA,MACErE,GAAsByD,EAAA,MAAK4L,KAAW5L,EAAA,MAAK8L,IAActF,CAAM;AAAA,MAC/DjK,GAAsByD,EAAA,MAAK6L,KAAW7L,EAAA,MAAK8L,IAActF,CAAM;AAAA,IAAA,IAEjE;AAAA,MACExG,EAAA,MAAK4L,IAAU,MAAM5L,EAAA,MAAK8L,IAActF,CAAM;AAAA,MAC9CxG,EAAA,MAAK6L,IAAU,MAAM7L,EAAA,MAAK8L,IAActF,CAAM;AAAA,IAAA;AAEpD,WAAAzF,EAAA,MAAK+K,GAAetF,IAEb,MAAM,KAAK,gBAAgBpK,GAAM,EAAE,OAAA2F,GAAO,OAAO,WAAW;AAAA,EACrE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,MAAM3F,GAAc;AACxB,UAAM,KAAK;AACX,UAAM1B,IAAW,KAAK,KAAM0B,IAAO,MAAOc,EAAmB,UAAU,GACjE2M,IAAW,IAAI6B;AAAA,MACnB,KAAK,aAAa,IAAI,CAACM,MAASA,EAAK,MAAM,GAAGtR,CAAQ,CAAC;AAAA,MACvDsF,EAAA,MAAKY;AAAA,IAAA,GAEDkJ,IAAY,IAAI4B;AAAA,MACpB,KAAK,WAAa,EAAA,IAAI,CAACM,MAASA,EAAK,MAAMtR,CAAQ,CAAC;AAAA,MACpDsF,EAAA,MAAKY;AAAA,IAAA;AAEA,WAAA,CAACiJ,GAAUC,CAAS;AAAA,EAC7B;AAAA,EAEA,MAAM,QAAQ;AACZ,UAAM,KAAK;AACX,UAAMnG,IAAO,IAAI+H,GAAU,KAAK,cAAc1L,EAAA,MAAKY,EAAK;AACxD,iBAAM+C,EAAK,OACJA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,UAAgB;AACT,IAAA5C,EAAA,MAAA6K,IAAY,IAAI,aAAa,CAAC,IAC9B7K,EAAA,MAAA8K,IAAY,IAAI,aAAa,CAAC,IACnC9L,EAAI,KAAK,6BAA6B;AAAA,EACxC;AACF;AA5LEI,KAAA,eAoBAyL,KAAA,eACAC,KAAA,eAQAjL,IAAA,eAlCK+K,KAAA,eA2DCI,oBACJlB,GACe;AACX,EAAAa,GAAU,OAAO,SACTA,GAAA,MAAM,IAAI,aAAa;AAAA,IAC/B,YAAYxO,EAAmB;AAAA,EAAA,CAChC;AAGG,QAAA+O,IAAS,YAAY,OACrB1D,IACJsC,aAAsB,iBAClB,MAAMqB,GAAgBrB,GAAYa,GAAU,GAAG,IAC/Cb;AAEN,EAAA9K,EAAI,KAAK,gCAAgC,YAAY,IAAA,IAAQkM,CAAM;AAE7D,QAAA5H,IAASrE,EAAA,MAAKY,GAAM;AAC1B,MAAIyD,MAAW;AACb,eAAW2H,KAAQzD;AACR,eAAArP,IAAI,GAAGA,IAAI8S,EAAK,QAAQ9S,KAAK,EAAQ,CAAA8S,EAAA9S,CAAC,KAAKmL;AAGxD,EAAArE,EAAA,MAAKG,IAAM,WAAYoI,EAAI,CAAC,EAAE,SAASrL,EAAmB,aAAc,KAEnE6D,EAAA,MAAA6K,IAAYrD,EAAI,CAAC,IAEtBxH,EAAA,MAAK8K,IAAYtD,EAAI,CAAC,KAAKvI,EAAA,MAAK4L,MAE5B7L,EAAA;AAAA,IACF;AAAA,IACA,YAAY,QAAQkM;AAAA,EAAA;AAExB,GAeA3G,KAAA,eACAwG,IAAA,eA3GA7L,EADWyL,IACJ,OAA2B;AAD7B,IAAMS,KAANT;AAkNP,eAAeQ,GACb5R,GACA/B,GACyB;AACzB,QAAMI,IAAM,MAAM,IAAI,SAAS2B,CAAM,EAAE,YAAY;AACnD,SAAOJ,GAAuB,MAAM3B,EAAI,gBAAgBI,CAAG,CAAC;AAC9D;;AC7NO,MAAMyT,KAAN,MAAMA,GAAiC;AAAA,EA4B5C,YAAYC,GAAiB;AAzB7B,IAAApM,EAAA;AAEA,IAAAL,EAAA,MAAAO,IAAQ;AAAA;AAAA,MAEN,UAAU;AAAA,MACV,OAAO;AAAA,MACP,QAAQ;AAAA,IAAA;AASV,IAAAP,EAAA,MAAA0M,IAAiB,MAAM;AAAA,IAAA;AAKd;AAAA;AAAA;AAAA,IAAArM,EAAA;AAET,IAAAL,EAAA,MAAA2M,IAA+B;AAE/B,IAAA3M,EAAA,MAAA4M;AAEE,IAAAzL,EAAA,MAAKyL,IAAMH,IACX,KAAK,aAAaA,EAAG,eAAe,EAAE,CAAC,KAAK,MAC5CrM,EAAA,MAAKG,IAAM,WAAW;AACtB,UAAMsM,IAAaJ,EAAG,eAAe,EAAE,CAAC;AACxC,IAAII,KAAc,QAChBA,EAAW,cAAc,UACzB,KAAK,QAAQ,IAAI,QAAQ,CAACpU,MAAY;AACpC,MAAA0I,EAAA,MAAKuL,IAAiBI,GAAsBD,GAAY,CAACnU,MAAQ;AAC1D,QAAA0H,EAAA,MAAAG,IAAM,QAAQ7H,EAAI,OAClB0H,EAAA,MAAAG,IAAM,SAAS7H,EAAI,QACxByI,EAAA,MAAKwL,IAAOjU,IACZD,EAAQ,KAAK,IAAI;AAAA,MAAA,CAClB;AAAA,IAAA,CACF,KAED,KAAK,QAAQ,QAAQ,QAAQ,KAAK,IAAI;AAAA,EAE1C;AAAA,EAlCA,IAAI,OAAO;AACF,WAAA;AAAA,MACL,GAAG2H,EAAA,MAAKG;AAAA,IAAA;AAAA,EAEZ;AAAA,EAgCA,MAAM,OAIH;AACM,WAAA;AAAA,MACL,OAAOH,EAAA,MAAKuM,OAAQ,OAAO,OAAO,MAAM,kBAAkBvM,EAAA,MAAKuM,GAAI;AAAA,MACnE,OAAO,CAAC;AAAA,MACR,OAAO;AAAA,IAAA;AAAA,EAEX;AAAA,EAEA,MAAM,QAAQ;AACL,WAAA,CAAC,MAAM,KAAK,MAAA,GAAS,MAAM,KAAK,OAAO;AAAA,EAChD;AAAA,EAEA,MAAM,QAAQ;AACZ,WAAO,IAAIH,GAAgBpM,EAAA,MAAKwM,IAAI,MAAO,CAAA;AAAA,EAC7C;AAAA,EAEA,UAAgB;AACT,IAAAxM,EAAA,MAAAwM,IAAI,YAAY,QAAQ,CAAC,MAAM,EAAE,MAAM,GAC5CxM,EAAA,MAAKsM,IAAL;AAAA,EACF;AACF;AAnEEnM,KAAA,eAaAmM,KAAA,eAOAC,KAAA,eAEAC,KAAA,eA1BAvM,EADWmM,IACJ,OAA2B;AAD7B,IAAMO,KAANP;AA0EP,SAASM,GACP5O,GACA8O,GACA;AACA,MAAIC,IAAS,IACTC;AACG,SAAAC;AAAA,IACL,IAAI,0BAA0B;AAAA,MAC5B,OAAAjP;AAAA,IACD,CAAA,EAAE;AAAA,IACH;AAAA,MACE,SAAS,OAAOqN,MAAU;AACxB,YAAI,CAAC0B,GAAQ;AACL,gBAAA,EAAE,eAAAG,GAAe,cAAAC,EAAiB,IAAA9B,GAClCpT,IAAQkV,KAAgB,GACxBjV,IAASgV,KAAiB,GAC1B1U,IAAM,IAAI,gBAAgBP,GAAOC,CAAM;AACpC,UAAA8U,IAAAxU,EAAI,WAAW,IAAI,GAC5BsU,EAAuBtU,CAAG,GACjBuU,IAAA;AAAA,QACX;AACO,QAAAC,EAAA,UAAU3B,GAAO,GAAG,CAAC,GAC5BA,EAAM,MAAM;AAAA,MACd;AAAA,MACA,QAAQ,YAAY;AAAA,MAAC;AAAA,IACvB;AAAA,EAAA;AAEJ;;ACpEO,MAAM+B,KAAN,MAAMA,GAAoC;AAAA,EA6C/C,YAAYC,GAAoCxN,GAA2B;AA7CtE,IAAAC,EAAA,MAAAwN;AACL,IAAAnN,EAAA;AAEA,IAAAL,EAAA,MAAAyN,GAA+B,CAAA;AAE/B,IAAAzN,EAAA,MAAAO,IAAQ;AAAA,MACN,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,UAAU;AAAA,IAAA;AAOZ,IAAAP,EAAA,MAAAgB,GAAuC;AAAA,MACrC,OAAO;AAAA,MACP,aAAa;AAAA,MACb,MAAM;AAAA,MACN,UAAU;AAAA,MACV,eAAe;AAAA,MACf,cAAc;AAAA,MACd,YAAY;AAAA,MACZ,aAAa;AAAA,MACb,WAAW;AAAA,MACX,SAAS;AAAA,MACT,UAAU;AAAA,MACV,YAAY;AAAA,QACV,SAAS;AAAA,QACT,SAAS;AAAA,QACT,MAAM;AAAA,QACN,OAAO;AAAA,MACT;AAAA,MACA,YAAY;AAAA,MACZ,aAAa;AAAA,IAAA;AAGf,IAAAhB,EAAA,MAAA2M;AACA,IAAA3M,EAAA,MAAA0N;AAEA,IAAA1N,EAAA,MAAA2N,GAA6B;AAE7B,IAAA3N,EAAA,MAAA4N,IAAc;AACd,IAAA5N,EAAA,MAAA6N,IAAe;;AAUb,QAPA1M,EAAA,MAAKsM,GAAa,MAAM,QAAQF,CAAO,IACnCA,IACAO,GAASP,CAAO,EAAE,IAAI,CAAC,EAAE,OAAA3Q,GAAO,KAAAC,GAAK,MAAAkR,SAAY;AAAA,MAC/C,OAAOnR,IAAQ;AAAA,MACf,KAAKC,IAAM;AAAA,MACX,MAAAkR;AAAA,IACA,EAAA,IACF3N,EAAA,MAAKqN,GAAW,WAAW,EAAG,OAAM,MAAM,sBAAsB;AAEpE,IAAAtM,EAAA,MAAKH,GAAQ,OAAO,OAAOZ,EAAA,MAAKY,IAAOjB,CAAI,IAE3CoB,EAAA,MAAK0M,IACH9N,EAAK,eAAe,OAAO,KAAKA,EAAK,YAAY,MAAM;AAEzD,UAAM,EAAE,UAAAiO,GAAU,YAAAC,GAAY,YAAAC,GAAY,aAAAC,GAAa,eAAAC,MACrDhO,EAAA,MAAKY;AACF,IAAAG,EAAA,MAAAyM,IAAcI,IAAW5N,EAAA,MAAKyN,MAAe,IAClD1M,EAAA,MAAKwL,GAAO,IAAI,gBAAgBuB,GAAYC,CAAW,IACvDhN,EAAA,MAAKuM,GAAOtN,EAAA,MAAKuM,GAAK,WAAW,IAAI,IACrCvM,EAAA,MAAKsN,GAAK,OAAO,GAAGM,CAAQ,MAAMC,CAAU,IAC5C7N,EAAA,MAAKsN,GAAK,YAAY,UACtBtN,EAAA,MAAKsN,GAAK,eAAe,OACpBtN,EAAA,MAAAsN,GAAK,gBAAgBU,KAAiB,OAE3CjN,EAAA,MAAKZ,IAAQ;AAAA,MACX,OAAO2N;AAAA,MACP,QAAQC;AAAA,MACR,YAAUpT,IAAAqF,EAAA,MAAKqN,GAAW,GAAG,EAAE,MAArB,gBAAA1S,EAAwB,QAAO;AAAA,IAAA,IAG3C,KAAK,QAAQ,QAAQ,QAAQ,KAAK,IAAI;AAAA,EACxC;AAAA,EAlEA,IAAI,OAAO;AACF,WAAA,EAAE,GAAGqF,EAAA,MAAKG;EACnB;AAAA;AAAA;AAAA;AAAA,EAoJA,MAAM,KAAK/D,GAGR;;AACD,QACE4D,EAAA,MAAKuN,MAAW,QAChBnR,KAAQ4D,EAAA,MAAKuN,GAAQ,aACrBnR,KAAQ4D,EAAA,MAAKuN,GAAQ,aAAavN,EAAA,MAAKuN,GAAQ,YAAY;AAE3D,aAAO,EAAE,OAAOvN,EAAA,MAAKuN,GAAQ,SAAS,OAAO;AAG/C,QAAIrU,IAAI;AACR,WAAOA,IAAI8G,EAAA,MAAKqN,GAAW,UACrB,EAAAjR,KAAQ4D,EAAA,MAAKqN,GAAWnU,CAAC,EAAE,MADEA,KAAK;AACtC;AAGI,UAAAyJ,IAAK3C,EAAA,MAAKqN,GAAWnU,CAAC,KAAK8G,EAAA,MAAKqN,GAAW,GAAG,EAAE;AACtD,QAAIjR,IAAOuG,EAAG,IAAY,QAAA,EAAE,OAAO;AAC/B,QAAAvG,IAAOuG,EAAG,OAAO;AAEd,MAAA3C,EAAA,MAAAsN,GAAK,UAAU,GAAG,GAAGtN,EAAA,MAAKuM,GAAK,OAAOvM,EAAA,MAAKuM,GAAK,MAAM;AAC3D,YAAM1J,IAAK,IAAI,WAAW7C,EAAA,MAAKuM,IAAM;AAAA,QACnC,WAAWnQ;AAAA;AAAA,QAEX,UAAUuG,EAAG,QAAQvG;AAAA,MAAA,CACtB;AACD,cAAAzB,IAAAqF,EAAA,MAAKuN,OAAL,QAAA5S,EAAc,SACdoG,EAAA,MAAKwM,GAAU1K,IAER,EAAE,OAAOA,EAAG,MAAM,GAAG,OAAO;IACrC;AAEK,IAAAwI,EAAA,MAAA+B,IAAAa,IAAA,WAAWtL,EAAG;AAEnB,UAAME,IAAK,IAAI,WAAW7C,EAAA,MAAKuM,IAAM;AAAA,MACnC,WAAWnQ;AAAA,MACX,UAAUuG,EAAG,MAAMvG;AAAA,IAAA,CACpB;AACD,YAAAd,IAAA0E,EAAA,MAAKuN,OAAL,QAAAjS,EAAc,SACdyF,EAAA,MAAKwM,GAAU1K,IAER,EAAE,OAAOA,EAAG,MAAM,GAAG,OAAO;EACrC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAMzG,GAAc;AACxB,UAAM,KAAK;AACX,QAAIuN,IAAS;AACb,aAASzQ,IAAI,GAAGA,IAAI8G,EAAA,MAAKqN,GAAW,QAAQnU,KAAK;AACzC,YAAAgV,IAAMlO,EAAA,MAAKqN,GAAWnU,CAAC;AACzB,UAAA,EAAAkD,IAAO8R,EAAI,QACN;AAAA,QAAAvE,IAAAzQ;AACT;AAAA;AAAA,IACF;AACA,QAAIyQ,MAAW,GAAU,OAAA,MAAM,4BAA4B;AAC3D,UAAME,IAAW7J,EAAA,MAAKqN,GAAW,MAAM,GAAG1D,CAAM,EAAE,IAAI,CAAC1I,OAAO,EAAE,GAAGA,IAAI;AACnE,QAAAkN,IAAYtE,EAAS,GAAG,EAAE,GAC1BuE,IAAc;AAElB,IAAID,KAAa,QAAQA,EAAU,MAAM/R,MACzBgS,IAAA;AAAA,MACZ,OAAO;AAAA,MACP,KAAKD,EAAU,MAAM/R;AAAA,MACrB,MAAM+R,EAAU;AAAA,IAAA,GAGlBA,EAAU,MAAM/R;AAEZ,UAAA0N,IAAY9J,EAAA,MAAKqN,GACpB,MAAM1D,CAAM,EACZ,IAAI,CAAC1I,OAAO,EAAE,GAAGA,GAAG,OAAOA,EAAE,QAAQ7E,GAAM,KAAK6E,EAAE,MAAM7E,EAAO,EAAA;AAClE,WAAIgS,KAAe,QAAgBtE,EAAA,QAAQsE,CAAW,GAC/C;AAAA,MACL,IAAIlB,GAAmBrD,GAAU7J,EAAA,MAAKY,EAAK;AAAA,MAC3C,IAAIsM,GAAmBpD,GAAW9J,EAAA,MAAKY,EAAK;AAAA,IAAA;AAAA,EAEhD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ;AACL,WAAA,IAAIsM,GAAmBlN,EAAA,MAAKqN,GAAW,MAAM,CAAC,GAAGrN,EAAA,MAAKY,EAAK;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAeyN,GAA0B;AAClC,IAAArO,EAAA,MAAAqN,GAAW,QAAQ,CAACpM,MAAM;AAC7B,MAAIA,EAAE,UAAUoN,EAAS,SAASpN,EAAE,QAAQoN,EAAS,QACnDpN,EAAE,OAAOoN,EAAS;AAAA,IACpB,CACD;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kBAA0B;AACxB,WAAOrO,EAAA,MAAKY,GAAM;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gBAAgB0N,GAAqB;;AACnC,QAAI,OAAOA,KAAU,YAAYA,IAAQ;AACjC,YAAA,IAAI,MAAM,4CAA4C;AAE9D,IAAAtO,EAAA,MAAKY,GAAM,eAAe0N,IAE1B3T,IAAAqF,EAAA,MAAKuN,OAAL,QAAA5S,EAAc,SACdoG,EAAA,MAAKwM,GAAU;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU;;AACR,KAAA5S,IAAAqF,EAAA,MAAKuN,OAAL,QAAA5S,EAAc;AAAA,EAChB;AACF;AA/RE0S,IAAA,eAEAlN,KAAA,eAUAS,IAAA,eAsBA2L,IAAA,eACAe,IAAA,eAEAC,IAAA,eAEAC,KAAA,eACAC,KAAA,eA3CKL,KAAA,eA+ELa,cAAWrW,GAAa;AAClB,EAAAmI,EAAA,KAAK,aAAanI,CAAG;AACzB,QAAM2W,IAAQ3W,EACX,MAAM;AAAA,CAAI,EACV,UACA,IAAI,CAACwG,MAAMA,EAAE,KAAM,CAAA,GAEhB,EAAE,OAAArG,GAAO,QAAAC,MAAWgI,EAAA,MAAKuM,IAEzB;AAAA,IACJ,OAAAiC;AAAA,IACA,UAAAZ;AAAA,IACA,aAAAa;AAAA,IACA,YAAAC;AAAA,IACA,aAAAC;AAAA,IACA,WAAAC;AAAA,IACA,SAAAC;AAAA,IACA,UAAAC;AAAA,IACA,cAAAC;AAAA,EAAA,IACE/O,EAAA,MAAKY,IACHrI,IAAMyH,EAAA,MAAKsN;AAEjB,EAAA/U,EAAI,UAAU,GAAG,GAAGR,GAAOC,CAAM,GACjCO,EAAI,cAAc;AAKlB,MAAIyW,IAAiBD;AACrB,aAAWE,KAAWV,GAAO;AACrB,UAAAW,IAAU3W,EAAI,YAAY0W,CAAO,GACjCE,IAAUpX,IAAQ;AACxB,IAAI0W,KAAe,SACjBlW,EAAI,gBAAgB,GACpBA,EAAI,gBAAgB,GACpBA,EAAI,aAAa,GAEjBA,EAAI,YAAYkW,GAChBlW,EAAI,cAAc,KACdA,EAAA;AAAA,MACF4W,IAAUD,EAAQ,wBAAwBlP,EAAA,MAAKyN;AAAA,MAC/CzV,IAASgX,IAAiBhP,EAAA,MAAKwN;AAAA,MAC/B0B,EAAQ,QAAQlP,EAAA,MAAKyN,MAAe;AAAA,MACpCzN,EAAA,MAAKwN;AAAA,IAAA,IAKTjV,EAAI,cAAcmW,EAAW,OAC7BnW,EAAI,gBAAgBmW,EAAW,SAC/BnW,EAAI,gBAAgBmW,EAAW,SAC/BnW,EAAI,aAAamW,EAAW,MAE5BnW,EAAI,cAAc,GAEdoW,KAAe,SACbpW,EAAA,YAAYqW,KAAahB,IAAW,GACpCiB,KAAW,SAAMtW,EAAI,UAAUsW,IAC/BC,KAAY,SAAMvW,EAAI,WAAWuW,IACrCvW,EAAI,cAAcoW,GACdpW,EAAA;AAAA,MACF0W;AAAA,MACAE;AAAA,MACAnX,IAASgX,IAAiBhP,EAAA,MAAKwN,MAAcxN,EAAA,MAAKyN;AAAA,IAAA,IAItDlV,EAAI,YAAYiW,GACZjW,EAAA;AAAA,MACF0W;AAAA,MACAE;AAAA,MACAnX,IAASgX,IAAiBhP,EAAA,MAAKwN,MAAcxN,EAAA,MAAKyN;AAAA,IAAA,GAIlCuB,KAAAhP,EAAA,MAAKwN,MAAcI,IAAW;AAAA,EAClD;AACF;AA5JK,IAAMwB,KAANlC;AAqSP,SAASmC,GAAiBjT,GAAc;AAChC,QAAAkT,IAAQlT,EAAK,MAAM,iCAAiC;AAC1D,MAAIkT,KAAS,KAAM,OAAM,MAAM,sBAAsBlT,CAAI,EAAE;AAE3D,QAAMmT,IAAQ,OAAOD,EAAM,CAAC,CAAC,GACvBE,IAAU,OAAOF,EAAM,CAAC,CAAC,GACzBG,IAAU,OAAOH,EAAM,CAAC,CAAC,GACzBI,IAAe,OAAOJ,EAAM,CAAC,CAAC;AAEpC,SAAOC,IAAQ,KAAK,KAAKC,IAAU,KAAKC,IAAUC,IAAe;AACnE;AAEA,SAAShC,GAASiC,GAAa;AAE3B,SAAAA,EACG,MAAM,OAAO,EACb,IAAI,CAAC1O,MAAMA,EAAE,KAAK,CAAC,EACnB,OAAO,CAAC2O,MAAQA,EAAI,SAAS,CAAC,EAE9B,IAAI,CAAC3O,OAAO;AAAA,IACX,SAASA;AAAA,IACT,OAAOA,EAAE;AAAA,MACP;AAAA,IACF;AAAA,IACA,EAED;AAAA,IACC,CAAC,EAAE,SAAAgO,EAAQ,GAAG3V,GAAKoG,MACjB;;AAAA,eAAE,QAAQ,KAAKuP,CAAO,OAAKtU,IAAA+E,EAAOpG,IAAM,CAAC,MAAd,gBAAAqB,EAAiB,UAAS;AAAA;AAAA,EAAA,EAGxD;AAAA,IACC,CAACyQ,GAAK,EAAE,SAAA6D,GAAS,OAAAK,QAAY;AAC3B,UAAIA,KAAS,MAAM;AACX,cAAAvI,IAAOqE,EAAI,GAAG,EAAE;AAClB,YAAArE,KAAQ,KAAa,QAAAqE;AAEzB,QAAArE,EAAK,QAAQA,EAAK,KAAK,WAAW,IAAIkI,IAAU;AAAA,EAAKA,CAAO;AAAA,MAAA;AAE5D,QAAA7D,EAAI,KAAK;AAAA,UACP,OAAOiE,GAAiBC,EAAM,CAAC,CAAC;AAAA,UAChC,KAAKD,GAAiBC,EAAM,CAAC,CAAC;AAAA,UAC9B,MAAM;AAAA,QAAA,CACP;AAGI,aAAAlE;AAAA,IACT;AAAA,IACA,CAAC;AAAA,EAAA;AAOT;;ACnYO,MAAMyE,GAAgB;AAAA,EAgB3B,cAAc;AAfd,IAAA5P,EAAA;AAWA,IAAAA,EAAA;AAEA,IAAAL,EAAA,MAAAkQ,IAAkB;AAGV,UAAA1S,IAAOa,GAAO;AACpB,QAAI8R,IAAkB;AACtB,SAAK,WAAW,IAAI;AAAA,MAClB;AAAA,QACE,OAAO,CAACC,MAAS;AACV,UAAA5S,EAAA,UAAU,CAACC,MAAS;;AACvB,kBAAM2B,KAAWrE,IAAA0C,EAAK,YAAY,CAAC,MAAlB,gBAAA1C,EAAqB;AACtC,YAAIqE,KAAY,QACd5B,EAAK,qBAAqB4B,GAAU,SAAS,EAAE,WAAW,KAAK;AAEjE,kBAAMC,KAAW3D,IAAA+B,EAAK,YAAY,CAAC,MAAlB,gBAAA/B,EAAqB;AACtC,YAAI2D,KAAY,QACd7B,EAAK,qBAAqB6B,GAAU,SAAS,EAAE,WAAW,KAAK,GAE5D+Q,EAAA,QAAQ,EAAE,WAAW,SAAS,MAAM,EAAE,MAAA3S,GAAM,MAAAD,EAAK,EAAA,CAAG,GACzDA,EAAK,MAAM;AAAA,UAAA;AAGb,gBAAM6S,IAAsC,CAAA;AAC5C,UAAA7S,EAAK,YAAY,CAAC8S,GAAI3V,GAAMsK,MAAY;AACtC,YAAAmL,EAAK,QAAQ;AAAA,cACX,WAAW;AAAA,cACX,MAAM,EAAE,IAAAE,GAAI,MAAA3V,GAAM,SAASsK,EAAQ,IAAI,CAAC5D,OAAO,EAAE,GAAGA,EAAA,EAAI,EAAE;AAAA,YAAA,CAC3D,GACDgP,EAAYC,CAAE,KAAKD,EAAYC,CAAE,KAAK,KAAKrL,EAAQ,QACnDzH,EAAK,mBAAmB8S,GAAID,EAAYC,CAAE,CAAC;AAAA,UAAA,GAG7C9S,EAAK,UAAU,MAAM;AACnB,YAAA4S,EAAK,MAAM;AAAA,UAAA;AAAA,QAEf;AAAA,QACA,QAAQ,MAAM;AACZ,UAAA5S,EAAK,KAAK,GACQ2S,IAAA;AAAA,QACpB;AAAA,MACF;AAAA,MACA;AAAA;AAAA,QAEE,eAAe;AAAA,MACjB;AAAA,IAAA,GAGG,KAAA,WAAW,IAAI,eAAe;AAAA,MACjC,OAAO,OAAOI,MAAW;AACvB,YAAIJ,GAAiB;AACnB,eAAK,SAAS;AACd;AAAA,QACF;AAEA,cAAMK,IAAWD,EAAO;AACxB,QAAAC,EAAS,YAAYpQ,EAAA,MAAK8P,KAC1B/O,EAAA,MAAK+O,IAAL9P,EAAA,MAAK8P,MAAmBM,EAAS,aACjChT,EAAK,aAAagT,CAAQ;AAAA,MAC5B;AAAA,MACA,OAAO,MAAM;;AACX,QAAAhT,EAAK,MAAM,GACXA,EAAK,KAAK,IACVzC,IAAAyC,EAAK,YAAL,QAAAzC,EAAA,KAAAyC;AAAA,MACF;AAAA,IAAA,CACD;AAAA,EACH;AACF;AAjEE0S,KAAA;ACLF,SAASO,GACPC,GACkD;AAClD,MAAIC,IAAe;AACnB,QAAMC,IAAQF,EAAU,OAClBG,IAAsD,CAAA;AAC5D,MAAIC,IAAgB;AAEpB,iBAAeC,IAAgB;AACvB,UAAAhY,IAAMiY,EAAQJ,GAAOD,CAAY;AACvC,IAAAA,IAAeC,EAAM,QAGrBC,EAAO,QAAQ,CAAC,EAAE,OAAA3S,GAAO,IAAAoS,QAAS;AAChC,YAAMjP,IAAInD,EAAM,QAAQ,GAAG,EAAE;AAC7B,MAAImD,KAAK,SACPyP,IAAgB,KAAK,IAAIA,GAAezP,EAAE,MAAMA,EAAE,QAAQ,IAE5DqP,EAAU,mBAAmBJ,GAAIpS,EAAM,QAAQ,MAAM,GACrDA,EAAM,UAAU;IAAC,CAClB,GACDwS,EAAU,QAAQ,IAClBA,EAAU,QAAQ,IACd3X,KAAO,QAAY,OAAAkY,KAAA,gBAAAA,EAAe,MAAMlY;AAAA,EAC9C;AAEA,MAAImY,IAA8B,CAAA;AAClC,WAASC,IAAe;AAClB,QAAAD,EAAc,SAAS,EAAU,QAAA;AAErC,UAAME,IAAUR,EAAM,UAAU,CAACxS,MAAQA,EAAI,SAAS,MAAM;AACxD,QAAAgT,MAAY,GAAW,QAAA;AAKvB,QAHJF,IAAgBN,EAAM,MAAM,GAAGQ,IAAU,CAAC,GAC1CT,IAAeS,IAAU,GAErBP,EAAO,WAAW;AACpB,eAASvX,IAAI,KAASA,KAAK,GAAG;AACtB,cAAA4E,IAAQwS,EAAU,aAAapX,CAAC;AACtC,YAAI4E,KAAS,KAAM;AACnB,QAAA2S,EAAO,KAAK,EAAE,OAAA3S,GAAO,IAAI5E,EAAG,CAAA;AAAA,MAC9B;AAGK,WAAA;AAAA,EACT;AAEA,MAAI+X,IAAU;AAEd,QAAMC,IAAW/P;AACjB,MAAI0P,IAEO;AAEX,QAAMM,KAAe,YAAY;AACf,IAAAN,IAAA,MAAMK,EAAS,gBAErBD,IAAA,KAAK,YAAY,MAAM;AAC3B,MAACF,OACSJ;OACb,GAAG;AAAA,EAAA;AAGR,MAAIS,IAAS;AACb,SAAO,YAAY;AACb,QAAAA,EAAc,OAAA,MAAM,eAAe;AAMvC,QALSA,IAAA,IAEH,MAAAD,GACN,cAAcF,CAAO,GAEjB,CAACF,EAAkB,KAAAF,KAAiB,KAAa,QAAA;AACrD,IAAAP,EAAU,MAAM,GAChB,MAAMK,EAAc,GACpB,OAAME,KAAA,gBAAAA,EAAe;AAErB,UAAMlM,IAAOmM,EAAc,KAAK,CAAC9S,MAAQA,EAAI,SAAS,MAAM;AAGxD,QAAA2G,KAAQ,KAAa,QAAA;AAEzB,IAAAA,EAAK,KAAK,WAAW+L;AAErB,UAAMW,IAASlQ,MACTxI,IAAMiY,EAAQE,GAAe,CAAC;AAC9B,iBAAA5P,GAAMmQ,GAAQ1Y,CAAG,GACvB,MAAMuI,GAAMmQ,GAAQH,GAAU,EAAE,WAAW,IAAO,GAE3C,MAAMG,EAAO;EAAO;AAGpB,WAAAT,EAAQlR,GAAsB4R,GAAqC;AACtE,QAAAA,KAAY5R,EAAO,OAAe,QAAA;AAEhC,UAAA6R,IAAK,IAAItT,GAAO;AACnB,IAAAsT,EAAA,aAAatT,GAAO,WAAW;AAElC,aAAS/E,IAAIoY,GAAUpY,IAAIwG,EAAO,QAAQxG;AACpC,MAAAwG,EAAOxG,CAAC,MAAM,SACXwG,EAAAxG,CAAC,EAAE,MAAMqY,CAAE,GAClB,OAAO7R,EAAOxG,CAAC;AAEV,WAAA,IAAI,WAAWqY,EAAG,MAAM;AAAA,EACjC;AACF;AAKA,SAASC,GACP1I,GAGA;AACA,QAAMnQ,IAAM,IAAI,YAAYmQ,EAAM,UAAU;AAC5C,EAAAA,EAAM,OAAOnQ,CAAG;AAChB,QAAM8Y,IAAM3I,EAAM;AACX,SAAA;AAAA,IACL,UAAUA,EAAM,YAAY;AAAA,IAC5B,KAAA2I;AAAA,IACA,KAAKA;AAAA,IACL,SAAS3I,EAAM,SAAS;AAAA,IACxB,MAAMnQ;AAAA,EAAA;AAEV;AAcA,eAAsB+Y,GACpBC,GACqC;AAC/B,QAAAC,IAAU3T,GAAO,cAEjB4T,IAAWxB,GAAsBuB,CAAO;AACxC,QAAAE,GAA0BH,GAASC,CAAO;AAC1C,QAAAG,IAAY,MAAMF;AACxB,MAAIE,KAAa,KAAY,OAAA,MAAM,oCAAoC;AAChE,SAAAA;AACT;AAEA,eAAeD,GACbH,GACAC,GACA;AACA,MAAI5S,IAAW,GACXgT,IAAO,GACPC,IAAO,GACPhT,IAAW,GACXiT,IAAO,GACPC,IAAO,GAEPC,IAAiB,MACjBC,IAAiB;AACrB,aAAW/X,KAAUqX;AACb,UAAA,IAAI,QAAc,OAAOtZ,MAAY;AACzC,MAAA0U,GAAezS,EAAO,YAAY,IAAIuV,GAAiB,CAAA,GAAG;AAAA,QACxD,QAAQxX;AAAA,QACR,SAAS,OAAO,EAAE,WAAAia,GAAW,MAAAvX,QAAW;AACtC,cAAIuX,MAAc,SAAS;AACnB,kBAAA,EAAE,gBAAAC,GAAgB,gBAAAC,EAAA,IAAmBrV;AAAA,cACzCpC,EAAK;AAAA,cACLA,EAAK;AAAA,YAAA;AAEH,YAAAiE,MAAa,KAAKuT,KAAkB,SAC3BvT,IAAA4S,EAAQ,SAASW,CAAc,IAExCtT,MAAa,KAAKuT,KAAkB,SAC3BvT,IAAA2S,EAAQ,SAASY,CAAc;AAAA,UAC5C,WACSF,MAAc,WAAW;AAC5B,kBAAA,EAAE,MAAA/X,GAAM,SAAAsK,EAAY,IAAA9J,GACpB0X,IAAUlY,MAAS,UAAUyE,IAAWC,GACxCyT,IAAYnY,MAAS,UAAUyX,IAAOE,GACtCS,IAAYpY,MAAS,UAAU0X,IAAOE;AAEpC,YAAAtN,EAAA,QAAQ,CAAC5D,MAAM;AACb,cAAA2Q,EAAA,UAAUa,GAASxR,EAAE,MAAM;AAAA,gBACjC,UAAUA,EAAE;AAAA,gBACZ,KAAKA,EAAE,MAAMyR;AAAA,gBACb,KAAKzR,EAAE,MAAM0R;AAAA,gBACb,SAAS1R,EAAE;AAAA,cAAA,CACZ;AAAA,YAAA,CACF;AAEK,kBAAA2R,IAAW/N,EAAQ,GAAG,EAAE;AAC9B,gBAAI+N,KAAY,KAAM;AACtB,YAAIrY,MAAS,UACC6X,IAAAQ,IACHrY,MAAS,YACN8X,IAAAO;AAAA,UAEhB;AAAA,QACF;AAAA,MAAA,CACD;AAAA,IAAA,CACF,GACGR,KAAa,SACfJ,KAAQI,EAAU,KAClBH,KAAQG,EAAU,MAEhBC,KAAa,SACfH,KAAQG,EAAU,KAClBF,KAAQE,EAAU;AAGxB;AAKA,eAAsBQ,GACpBvY,GACqC;AACrC,SAAO,MAAMoX,GAAc,CAACpX,CAAM,CAAC;AACrC;AASA,SAASwY,GACPC,GACA;AACA,MAAIC,IAAuB,CAAA;AACrB,QAAAC,IAAY,IAAI,aAAa;AAAA,IACjC,QAAQ,CAAC5Z,MAAO;AACd,MAAA2Z,EAAQ,KAAK3Z,CAAE;AAAA,IACjB;AAAA,IACA,OAAO0G,EAAI;AAAA,EAAA,CACZ;AACD,SAAAkT,EAAU,UAAUF,CAAM,GAEnB;AAAA,IACL,QAAQ,OAAOG,MAAoB;AAC9B,MAAAA,EAAA,QAAQ,CAACjS,MAAM;AACN,QAAAgS,EAAA;AAAA,UACR,IAAI,kBAAkB;AAAA,YACpB,MAAMhS,EAAE,UAAU,QAAQ;AAAA,YAC1B,WAAY,MAAMA,EAAE,MAAOA,EAAE;AAAA,YAC7B,UAAW,MAAMA,EAAE,WAAYA,EAAE;AAAA,YACjC,MAAMA,EAAE;AAAA,UAAA,CACT;AAAA,QAAA;AAAA,MACH,CACD,GAED,MAAMgS,EAAU;AAEhB,YAAMva,IAAKsa;AACX,aAAAA,IAAU,CAAA,GAEHta;AAAA,IACT;AAAA,IACA,OAAO,MAAM;AACX,MAAAua,EAAU,MAAM;AAAA,IAClB;AAAA,EAAA;AAEJ;AAIA,SAASE,GACPC,GACA/I,GACA;AACA,QAAMjD,IAAc;AAAA,IAClB,OAAOgM,EAAO;AAAA,IACd,YAAYA,EAAO;AAAA,IACnB,kBAAkBA,EAAO;AAAA,EAAA,GAGrBC,IAAY,IAAI,aAAa;AAAA,IACjC,QAAQ,CAACvK,MAAU;AACR,MAAAuB,EAAAmH,GAAoB1I,CAAK,CAAC;AAAA,IACrC;AAAA,IACA,OAAO,CAACzC,MAAQ;AACd,MAAAtG,EAAI,MAAM,uBAAuBsG,GAAK,aAAae,CAAW;AAAA,IAChE;AAAA,EAAA,CACD;AAED,EAAAiM,EAAU,UAAUjM,CAAW;AAG/B,MAAIkM,IAAsD;AAEjD,WAAAC,EAASxY,GAAoByY,GAAY;AAChD,WAAO,IAAI,UAAU;AAAA,MACnB,WAAWA;AAAA,MACX,kBAAkBJ,EAAO;AAAA,MACzB,gBAAgBrY,EAAK,SAASqY,EAAO;AAAA,MACrC,YAAYA,EAAO;AAAA,MACnB,QAAQ;AAAA,MACR,MAAArY;AAAA,IAAA,CACD;AAAA,EACH;AACO,SAAA;AAAA,IACL,QAAQ,OAAOA,GAAoByY,MAAe;AAChD,MAAIF,KAAY,QACdD,EAAU,OAAOE,EAASD,EAAS,MAAMA,EAAS,EAAE,CAAC,GAE5CA,IAAA,EAAE,MAAAvY,GAAM,IAAAyY;IACrB;AAAA,IACA,MAAM,YAAY;AAChB,MAAIF,KAAY,SAEdG,GAAUH,EAAS,MAAMF,EAAO,kBAAkBA,EAAO,UAAU,GACnEC,EAAU,OAAOE,EAASD,EAAS,MAAMA,EAAS,EAAE,CAAC,GAC1CA,IAAA,OAEb,MAAMD,EAAU,SAChBA,EAAU,MAAM;AAAA,IAClB;AAAA,EAAA;AAEJ;AAMA,SAASI,GAAUjY,GAAuBG,GAAiB+X,GAAoB;AACvE,QAAAC,IAAUnY,EAAQ,SAAS,GAE3BoY,IAAU,KAAK,IAAIF,IAAa,GAAGC,CAAO;AAChD,WAASza,IAAI,GAAGA,IAAI0a,GAAS1a;AAC3B,aAASC,IAAI,GAAGA,KAAKwC,GAASxC;AAE5B,MAAAqC,EAAQ,KAAK,MAAMmY,IAAUxa,CAAC,IAAID,CAAC,KAAKA,IAAI0a;AAGlD;AAWgB,SAAAC,GACdC,GACA/R,GAKA;AACA,EAAAhC,EAAI,KAAK,2BAA2B;AAAA,IAClC,QAAQgC,EAAM;AAAA,IACd,MAAMA,EAAM;AAAA,EAAA,CACb;AAEK,QAAA6P,IAAU3T,GAAO,cACjB,EAAE,QAAQ8T,GAAW,MAAMgC,MAAYC,GAAYpC,GAAS,GAAG;AAErE,MAAIqC,IAEO,MAEPC,IAEO,MAEPC,IAAgC,CAAA,GAEhCnV,IAAW,GACXC,IAAW,GACXmV,IAAc,GACdC,IAAc,IACdX,IAAaxW,EAAmB;AACpC,EAAA6P,GAAe+G,EAAU,YAAY,IAAIjE,GAAiB,CAAA,GAAG;AAAA,IAC3D,QAAQ,YAAY;AAClB,aAAMqE,KAAA,gBAAAA,EAAoB,SAC1BD,KAAA,QAAAA,EAAoB,SACZF;IACV;AAAA,IACA,SAAS,OAAO,EAAE,WAAAzB,GAAW,MAAAvX,QAAW;AACtC,UAAIuX,MAAc,SAAS;AACnB,cAAA,EAAE,gBAAAC,GAAgB,gBAAAC,GAAgB,kBAAA8B,MACtCnX,GAAkBpC,EAAK,MAAMA,EAAK,IAAI;AACpC,QAAAiE,MAAa,KAAKuT,KAAkB,SAC3BvT,IAAA4S,EAAQ,SAASW,CAAc;AAG5C,cAAMgC,IAAqB/B,KAAkB;AAAA,UAC3C,WAAW;AAAA,UACX,YAAYkB;AAAA,UACZ,eAAexW,EAAmB;AAAA,UAClC,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,QAAA;AAER,QAAI+B,MAAa,MACJA,IAAA2S,EAAQ,SAAS2C,CAAkB,GAC9Cb,KAAalB,KAAA,gBAAAA,EAAgB,eAAckB,GAC7BW,IAAA7B,KAAkB;AAElC,cAAMgC,KAAW,IAAI,aAAa,EAAE,YAAAd,EAAY,CAAA;AAChC,QAAAS,IAAAja;AAAA,UACd,MAAMsa,GAAS;AAAA,YACb,MAAM,IAAI,SAASzS,EAAM,MAAM,EAAE,YAAY;AAAA,UAC/C;AAAA,QAAA,GAGEuS,KAAoB,SACtBL,IAAqBnB,GAA4BwB,CAAgB,IAE9CJ,IAAAf;AAAA,UACnBmB,KAAoB;AAAA,YAClB,OACEC,EAAmB,SAAS,SACxBrX,EAAmB,QACnBqX,EAAmB;AAAA,YACzB,kBAAkBA,EAAmB;AAAA,YACrC,YAAYA,EAAmB;AAAA,UACjC;AAAA,UACA,CAACtT,OAAM2Q,EAAQ,UAAU3S,GAAUgC,GAAE,MAAMA,EAAC;AAAA,QAAA;AAAA,MAC9C,WACSqR,MAAc,WAAW;AAClC,cAAM,EAAE,IAAApC,GAAI,MAAA3V,GAAM,SAAAsK,EAAA,IAAY9J;AAC9B,YAAIR,MAAS,SAAS;AACZ,UAAAsK,EAAA,QAAQ,CAAC5D,MAAM2Q,EAAQ,UAAU1B,GAAIjP,EAAE,MAAMA,CAAC,CAAC,GAElDoT,KAAmB,MAAAI,EAAoB5P,CAAO;AACnD;AAAA,QACF;AAEA,QAAItK,MAAS,WAAe,MAAAma,EAA4B7P,CAAO;AAAA,MACjE;AAAA,IACF;AAAA,EAAA,CACD;AAED,WAAS8P,EAAmB9Y,GAAa;AACvC,UAAMnD,IAAKyb,EAAc;AAAA,MAAI,CAAC3a,MAC5BuI,EAAM,OACFxF,GAAsB/C,GAAS4a,GAAaA,IAAcvY,CAAG,IAC7DrC,EAAQ,MAAM4a,GAAaA,IAAcvY,CAAG;AAAA,IAAA;AAI9C,QAFWuY,KAAAvY,GAEXkG,EAAM,WAAW;AACnB,iBAAWpJ,KAAOD;AACP,iBAAAQ,IAAI,GAAGA,IAAIP,EAAI,QAAQO,IAAK,CAAAP,EAAIO,CAAC,KAAK6I,EAAM;AAGlD,WAAArJ;AAAA,EACT;AAEA,iBAAe+b,EAAoBG,GAA2B;AACtD,UAAAC,IAAYD,EAAa,CAAC,GAC1BhC,IAAWgC,EAAaA,EAAa,SAAS,CAAC,GAC/CE,IAAY,KAAK;AAAA,OACnBlC,EAAS,MAAMA,EAAS,WAAWiC,EAAU,OAC7CjC,EAAS,YACTc;AAAA,IAAA,GAEEqB,IAAena,GAAS,CAAC+Z,EAAmBG,CAAS,CAAC,CAAC;AACzD,IAAAC,EAAa,WAAW,MACRb,KAAA,QAAAA,EAAA;AAAA,MAClBa;AAAA,MACCF,EAAU,MAAMA,EAAU,YAAa;AAAA;AAAA,EAE5C;AAEA,iBAAeH,EAA4B7P,GAAsB;AAC/D,QAAIoP,KAAsB,KAAM;AAIhC,UAAMe,KAAgB,MAAMf,EAAmB,OAAOpP,CAAO,GAAG;AAAA,MAC9DzL;AAAA,IAAA,GAGI6b,IAAclc,GAAmBic,CAAY,GAC7Cb,IAAgBQ,EAAmBM,EAAY,CAAC,EAAE,MAAM,GACxDJ,IAAYhQ,EAAQ,CAAC;AAGP,IAAAqP,KAAA,QAAAA,EAAA;AAAA;AAAA,MAElBtZ,GAAS,CAACqa,GAAad,CAAa,CAAC;AAAA,MACpCU,EAAU,MAAMA,EAAU,YAAa;AAAA;AAAA,EAE5C;AAEO,SAAA9C;AACT;ACpgBA,MAAMmD,KAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAUfC,KAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GA0CjBC,KAAY,CAAC,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,CAAC,GACrDC,KAAgB,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAGzD,SAASC,GACPC,GACAC,GACAC,GACA;AACA,QAAMP,IAAeQ,GAAWH,GAAIA,EAAG,eAAeC,CAAQ,GACxDL,IAAiBO,GAAWH,GAAIA,EAAG,iBAAiBE,CAAQ,GAG5DE,IAAgBJ,EAAG;AAKzB,MAJGA,EAAA,aAAaI,GAAeT,CAAY,GACxCK,EAAA,aAAaI,GAAeR,CAAc,GAC7CI,EAAG,YAAYI,CAAa,GAExB,CAACJ,EAAG,oBAAoBI,GAAeJ,EAAG,WAAW;AACjD,UAAA;AAAA,MACJA,EAAG,kBAAkBI,CAAa,KAChC;AAAA,IAAA;AAIC,SAAAA;AACT;AAGA,SAASD,GAAWH,GAA2Bhb,GAAcmF,GAAgB;AACrE,QAAAkW,IAASL,EAAG,aAAahb,CAAI;AASnC,MANGgb,EAAA,aAAaK,GAAQlW,CAAM,GAG9B6V,EAAG,cAAcK,CAAM,GAGnB,CAACL,EAAG,mBAAmBK,GAAQL,EAAG,cAAc,GAAG;AAC/C,UAAAjO,IAASiO,EAAG,iBAAiBK,CAAM;AACzC,UAAAL,EAAG,aAAaK,CAAM,GAChB,MAAMtO,KAAU,yCAAyC;AAAA,EACjE;AAEO,SAAAsO;AACT;AAEA,SAASC,GACPN,GACAtd,GACA6d,GACA;AACG,EAAAP,EAAA,YAAYA,EAAG,YAAYO,CAAO,GAClCP,EAAA,WAAWA,EAAG,YAAY,GAAGA,EAAG,MAAMA,EAAG,MAAMA,EAAG,eAAetd,CAAG,GACvEsd,EAAG,WAAWA,EAAG,WAAW,GAAG,CAAC;AAClC;AAEA,SAASQ,GAAYR,GAA2B;AACxC,QAAAO,IAAUP,EAAG;AACnB,MAAIO,KAAW,KAAY,OAAA,MAAM,4BAA4B;AAC1D,EAAAP,EAAA,YAAYA,EAAG,YAAYO,CAAO;AAGrC,QAAME,IAAQ,GACRC,IAAiBV,EAAG,MACpBxd,IAAQ,GACRC,IAAS,GACTke,IAAS,GACTC,IAAYZ,EAAG,MACfa,IAAUb,EAAG,eACbc,IAAQ,IAAI,WAAW,CAAC,GAAG,GAAG,KAAK,GAAG,CAAC;AAC1C,SAAAd,EAAA;AAAA,IACDA,EAAG;AAAA,IACHS;AAAA,IACAC;AAAA,IACAle;AAAA,IACAC;AAAA,IACAke;AAAA,IACAC;AAAA,IACAC;AAAA,IACAC;AAAA,EAAA,GAGFd,EAAG,cAAcA,EAAG,YAAYA,EAAG,oBAAoBA,EAAG,MAAM,GAChEA,EAAG,cAAcA,EAAG,YAAYA,EAAG,oBAAoBA,EAAG,MAAM,GAChEA,EAAG,cAAcA,EAAG,YAAYA,EAAG,gBAAgBA,EAAG,aAAa,GACnEA,EAAG,cAAcA,EAAG,YAAYA,EAAG,gBAAgBA,EAAG,aAAa,GAE5DO;AACT;AASA,SAASQ,GACP3W,GAIA;AACA,QAAMrH,IACJ,cAAc,aACV,WAAW,SAAS,cAAc,QAAQ,IAC1C,IAAI,gBAAgBqH,EAAK,OAAOA,EAAK,MAAM;AACjD,EAAArH,EAAI,QAAQqH,EAAK,OACjBrH,EAAI,SAASqH,EAAK;AAEZ,QAAA4V,IAAKjd,EAAI,WAAW,UAAU;AAAA,IAClC,oBAAoB;AAAA,IACpB,OAAO;AAAA,EAAA,CACR;AAED,MAAIid,KAAM,KAAY,OAAA,MAAM,wBAAwB;AAEpD,QAAMI,IAAgBL,GAAkBC,GAAIL,IAAcC,EAAc;AACxE,EAAAI,EAAG,WAAWI,CAAa,GAExBJ,EAAA;AAAA,IACDA,EAAG,mBAAmBI,GAAe,UAAU;AAAA,IAC/ChW,EAAK,SAAS,IAAI,CAAC4W,MAAMA,IAAI,GAAG;AAAA,EAAA,GAE/BhB,EAAA;AAAA,IACDA,EAAG,mBAAmBI,GAAe,YAAY;AAAA,IACjDhW,EAAK;AAAA,EAAA,GAEJ4V,EAAA;AAAA,IACDA,EAAG,mBAAmBI,GAAe,YAAY;AAAA,IACjDhW,EAAK;AAAA,EAAA,GAEP4V,EAAG,UAAUA,EAAG,mBAAmBI,GAAe,OAAO,GAAGhW,EAAK,KAAK;AAEhE,QAAA6W,IAAYjB,EAAG;AAClB,EAAAA,EAAA,WAAWA,EAAG,cAAciB,CAAS,GACrCjB,EAAA,WAAWA,EAAG,cAAc,IAAI,aAAaH,EAAS,GAAGG,EAAG,WAAW;AAC1E,QAAMkB,IAAalB,EAAG,kBAAkBI,GAAe,YAAY;AAChE,EAAAJ,EAAA;AAAA,IACDkB;AAAA,IACA;AAAA,IACAlB,EAAG;AAAA,IACH;AAAA,IACA,aAAa,oBAAoB;AAAA,IACjC;AAAA,EAAA,GAEFA,EAAG,wBAAwBkB,CAAU;AAE/B,QAAAC,IAAiBnB,EAAG;AACvB,EAAAA,EAAA,WAAWA,EAAG,cAAcmB,CAAc,GAC1CnB,EAAA;AAAA,IACDA,EAAG;AAAA,IACH,IAAI,aAAaF,EAAa;AAAA,IAC9BE,EAAG;AAAA,EAAA;AAEL,QAAMoB,IAAapB,EAAG,kBAAkBI,GAAe,YAAY;AAChE,SAAAJ,EAAA;AAAA,IACDoB;AAAA,IACA;AAAA,IACApB,EAAG;AAAA,IACH;AAAA,IACA,aAAa,oBAAoB;AAAA,IACjC;AAAA,EAAA,GAEFA,EAAG,wBAAwBoB,CAAU,GAElCpB,EAAA,YAAYA,EAAG,qBAAqB,CAAC,GAEjC,EAAE,KAAAjd,GAAK,IAAAid;AAChB;AAUA,SAASqB,GAAYC,GAAuB;AAC1C,SAAOA,aAAqB,aACxB,EAAE,OAAOA,EAAU,YAAY,QAAQA,EAAU,YAAY,IAC7D,EAAE,OAAOA,EAAU,OAAO,QAAQA,EAAU;AAClD;AAEA,SAASC,GAAYD,GAAuB;AAEpC,QAAAte,IADM,IAAI,gBAAgB,GAAG,CAAC,EACpB,WAAW,IAAI;AAC3B,EAAAA,EAAA,UAAUse,GAAW,GAAG,CAAC;AACvB,QAAA;AAAA,IACJ,MAAM,CAACE,GAAGC,GAAGne,CAAC;AAAA,EAAA,IACZN,EAAI,aAAa,GAAG,GAAG,GAAG,CAAC;AACxB,SAAA,CAACwe,GAAGC,GAAGne,CAAC;AACjB;AAea,MAAAoe,KAAkB,CAC7BtX,MAGG;AACH,MAAIrH,IAAkD,MAClDid,IAAmC,MACnC2B,IAAOvX,EAAK,UACZmW,IAA+B;AAEnC,SAAO,OAAOe,MAA0B;AAatC,SAZIve,KAAO,QAAQid,KAAM,QAAQO,KAAW,UACtCoB,KAAQ,SAAaA,IAAAJ,GAAYD,CAAS,IAC7C,EAAE,KAAAve,GAAK,IAAAid,EAAG,IAAIe,GAAQ;AAAA,MACrB,GAAGM,GAAYC,CAAS;AAAA,MACxB,UAAUK;AAAA,MACV,GAAGvX;AAAA,IAAA,CACJ,GACDmW,IAAUC,GAAYR,CAAE,IAGZM,GAAAN,GAAIsB,GAAWf,CAAO,GAGlC,WAAW,cAAc,QACzBe,aAAqB,WAAW,YAChC;AACM,YAAAne,IAAK,IAAI,WAAWJ,GAAK;AAAA,QAC7B,OAAO;AAAA,QACP,WAAWue,EAAU;AAAA,QACrB,UAAUA,EAAU,YAAY;AAAA,MAAA,CACjC;AACD,aAAAA,EAAU,MAAM,GACTne;AAAA,IACT;AAEA,WAAO,kBAAkBJ,GAAK;AAAA,MAC5B,kBAAkBue,aAAqB,cAAc,UAAU;AAAA,IAAA,CAChE;AAAA,EAAA;AAEL;;ACpRO,MAAMM,KAAN,MAAMA,GAA+B;AAAA,EA4F1C,YACEC,GACAC,GACAC,GACAC,GACAC,GACA;AAlGG,IAAA5X,EAAA,MAAA6X;AACL,IAAA7X,EAAA,MAAA8X,IAAW,IAAIC;AAQf;AAAA;AAAA;AAAA;AAAA;AAAA,IAAA1X,EAAA,YAAKD,EAAA,MAAK0X,IAAS;AAEnB,IAAA9X,EAAA,MAAAgY,IAAK;AAUL,IAAAhY,EAAA,MAAAiY,IAAK;AAUL,IAAAjY,EAAA,MAAAkY,IAAK;AAUL,IAAAlY,EAAA,MAAAmY,IAAK;AAUL,IAAAnY,EAAA,MAAAoY,IAAS;AAuCT;AAAA;AAAA;AAAA;AAAA;AAAA,IAAApY,EAAA,MAAAqY,IAAuB;AA6BvB;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAhY,EAAA,0BAAmB;AAOnB;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA,EAAA,0BAAmB;AA3BjB,SAAK,IAAImX,KAAK,GACd,KAAK,IAAIC,KAAK,GACd,KAAK,IAAIC,KAAK,GACd,KAAK,IAAIC,KAAK,GACdxW,EAAA,MAAKkX,IAAUT,KAAU;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAzFA,IAAI,IAAI;AACN,WAAOxX,EAAA,MAAK4X;AAAA,EACd;AAAA,EACA,IAAI,EAAErB,GAAG;AACF,IAAAlL,EAAA,MAAAoM,IAAAS,IAAA,WAAc,KAAK3B;AAAA,EAC1B;AAAA,EAEA,IAAI,IAAI;AACN,WAAOvW,EAAA,MAAK6X;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,EAAEtB,GAAG;AACF,IAAAlL,EAAA,MAAAoM,IAAAS,IAAA,WAAc,KAAK3B;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,IAAI;AACN,WAAOvW,EAAA,MAAK8X;AAAA,EACd;AAAA,EACA,IAAI,EAAEvB,GAAG;AACF,IAAAlL,EAAA,MAAAoM,IAAAS,IAAA,WAAc,KAAK3B;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,IAAI;AACN,WAAOvW,EAAA,MAAK+X;AAAA,EACd;AAAA,EACA,IAAI,EAAExB,GAAG;AACF,IAAAlL,EAAA,MAAAoM,IAAAS,IAAA,WAAc,KAAK3B;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,QAAQ;AACV,WAAOvW,EAAA,MAAKgY;AAAA,EACd;AAAA,EACA,IAAI,MAAMzB,GAAG;AACN,IAAAlL,EAAA,MAAAoM,IAAAS,IAAA,WAAc,SAAS3B;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAgDA,IAAI,SAAiB;AACnB,UAAM,EAAE,GAAAa,GAAG,GAAAC,GAAG,GAAAC,GAAG,GAAAC,MAAM;AAChB,WAAA,EAAE,GAAGH,IAAIE,IAAI,GAAG,GAAGD,IAAIE,IAAI;EACpC;AAAA,EAgBA,QAAc;AACZ,UAAM,EAAE,GAAAH,GAAG,GAAAC,GAAG,GAAAC,GAAG,GAAAC,MAAM,MACjBY,IAAO,IAAIhB,GAAKC,GAAGC,GAAGC,GAAGC,GAAGvX,EAAA,MAAKiY,GAAO;AAC9C,WAAAE,EAAK,QAAQ,KAAK,OAClBA,EAAK,mBAAmB,KAAK,kBAC7BA,EAAK,mBAAmB,KAAK,kBACtBA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAASC,GAAYC,GAAqB;;AACxC,QAAI,EAAE,OAAAC,GAAO,QAAAC,GAAQ,GAAAnB,GAAG,GAAAC,GAAG,GAAAC,GAAG,GAAAC,EAAM,IAAA;AAE9B,UAAA7a,MAAM/B,IAAAqF,EAAA,MAAKiY,QAAL,gBAAAtd,EAAc,WAAU4d,GAC9BC,MAAMld,IAAA0E,EAAA,MAAKiY,QAAL,gBAAA3c,EAAc,UAASgd;AAG/B,IAAAtY,EAAA,MAAKiY,OAAW,SAClBb,IAAIA,IAAI1a,EAAI,GACZ2a,IAAIA,IAAI3a,EAAI;AAGR,UAAA+b,IAAML,IAAK1b,EAAI,GACfgc,IAAML,IAAK3b,EAAI;AAErB,QAAIic,IAAKF,GACLG,IAAKF;AAOL,WANAF,MAAQ,MAELG,IAAAF,IAAM,KAAK,IAAID,CAAG,IAAIE,IAAM,KAAK,IAAIF,CAAG,GACxCI,IAAAF,IAAM,KAAK,IAAIF,CAAG,IAAIC,IAAM,KAAK,IAAID,CAAG,IAG3C,EAAAG,IAAKvB,KAAKuB,IAAKvB,IAAIE,KAAKsB,IAAKvB,KAAKuB,IAAKvB,IAAIE;AAAA,EAGjD;AACF;AAxKEG,KAAA,eAUAE,KAAA,eAUAC,KAAA,eAUAC,KAAA,eAUAC,KAAA,eAUAC,KAAA,eAnDKP,KAAA,eA+DLS,KAAA,SAAcW,GAA4BtC,GAAW;AAC7C,QAAAuC,IAAU,KAAKD,CAAI,MAAMtC;AAC/B,UAAQsC,GAAM;AAAA,IACZ,KAAK;AACH,MAAA9X,EAAA,MAAK6W,IAAKrB;AACV;AAAA,IACF,KAAK;AACH,MAAAxV,EAAA,MAAK8W,IAAKtB;AACV;AAAA,IACF,KAAK;AACH,MAAAxV,EAAA,MAAK+W,IAAKvB;AACV;AAAA,IACF,KAAK;AACH,MAAAxV,EAAA,MAAKgX,IAAKxB;AACV;AAAA,IACF,KAAK;AACH,MAAAxV,EAAA,MAAKiX,IAASzB;AACd;AAAA,EACJ;AACI,EAAAuC,KAAc9Y,EAAA,MAAA0X,IAAS,KAAK,eAAe,EAAE,CAACmB,CAAI,GAAGtC,EAAA,CAAG;AAC9D,GAOA0B,KAAA;AA1FK,IAAMc,KAAN5B;;ACJA,MAAe6B,GAAW;AAAA,EAyE/B,cAAc;AArEd;AAAA;AAAA;AAAA,IAAA/Y,EAAA,cAAO,IAAI8Y;AAYX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAnZ,EAAA,MAAAqZ,IAAQ;AAAA,MACN,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,cAAc;AAAA,IAAA;AAShB,IAAArZ,EAAA,MAAA8X,IAAW,IAAIC;AAUf;AAAA;AAAA;AAAA;AAAA;AAAA,IAAA1X,EAAA,YAAKD,EAAA,MAAK0X,IAAS;AAEnB,IAAA9X,EAAA,MAAAsZ,IAAU;AAiBV;AAAA;AAAA;AAAA,IAAAjZ,EAAA,iBAAU;AAKV;AAAA;AAAA;AAAA,IAAAA,EAAA,cAAyC;AAEzC,IAAAL,EAAA,MAAAuZ,IAA6C;AAE7C,IAAAvZ,EAAA,MAAAwZ,GAA+C;AAK/C;AAAA;AAAA;AAAA,IAAAnZ,EAAA,eAAQ,QAAQ;AAGd,SAAK,KAAK,GAAG,eAAe,CAACoZ,MAAU;AACrC,MAAArZ,EAAA,MAAK0X,IAAS,KAAK,eAAe,EAAE,MAAM2B,GAAO;AAAA,IAAA,CAClD;AAAA,EACH;AAAA,EAxDA,IAAI,OAAmE;AACrE,WAAOrZ,EAAA,MAAKiZ;AAAA,EACd;AAAA,EACA,IAAI,KAAK1C,GAAgE;AAChE,WAAA,OAAOvW,EAAA,MAAKiZ,KAAO1C,CAAC;AAAA,EAC7B;AAAA,EAeA,IAAI,SAAiB;AACnB,WAAOvW,EAAA,MAAKkZ;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,OAAO3C,GAAW;AACd,UAAAuC,IAAU9Y,EAAA,MAAKkZ,QAAY3C;AACjC,IAAAxV,EAAA,MAAKmY,IAAU3C,IACXuC,aAAcpB,IAAS,KAAK,eAAe,EAAE,QAAQnB,GAAG;AAAA,EAC9D;AAAA,EA2BU,QACRhe,GACM;AACA,UAAA;AAAA,MACJ,MAAM,EAAE,QAAAggB,GAAQ,OAAAD,EAAM;AAAA,IACpB,IAAA;AACA,IAAA/f,EAAA;AAAA;AAAA,MAEF,KAAK,SAAS,eAAe,KAAK;AAAA,MAClC;AAAA;AAAA,MAEA;AAAA,MACA,KAAK,SAAS,aAAa,KAAK;AAAA;AAAA,MAEhCggB,EAAO;AAAA,MACPA,EAAO;AAAA,IAAA,GAGThgB,EAAI,QAAQ,KAAK,QAAQ,OAAO,IAAI,MAAM+f,CAAK,GAE/C/f,EAAI,cAAc,KAAK;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBA,aAAa+gB,GAAyB3Z,GAA4B;AAC3D,IAAAoB,EAAA,MAAAoY,IAAkB,OAAO,QAAQG,CAAQ,EAAE,IAAI,CAAC,CAACC,GAAGC,CAAG,MAAM;AAChE,YAAMC,IAAO,EAAE,MAAM,GAAG,IAAI,IAAI,EAAEF,CAAC,KAAK,OAAOA,EAAE,MAAM,GAAG,EAAE,CAAC;AAC7D,UAAI,MAAME,CAAI,KAAKA,IAAO,OAAOA,IAAO;AACtC,cAAM,MAAM,6BAA6B;AAEpC,aAAA,CAACA,IAAO,KAAKD,CAAG;AAAA,IAAA,CACxB,IACDzY,EAAA,MAAKqY,GAAc,OAAO,OAAO,CAAC,GAAGpZ,EAAA,MAAKoZ,IAAa;AAAA,MACrD,UAAUzZ,EAAK;AAAA,MACf,OAAOA,EAAK,SAAS;AAAA,MACrB,WAAWA,EAAK,aAAa;AAAA,IAAA,CAC9B;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQvD,GAAoB;AAExB,QAAA4D,EAAA,MAAKmZ,OAAmB,QACxBnZ,EAAA,MAAKoZ,MAAe,QACpBhd,IAAO4D,EAAA,MAAKoZ,GAAY;AAExB;AACF,UAAMM,IAAcC;AAAA,MAClBvd;AAAA,MACA4D,EAAA,MAAKmZ;AAAA,MACLnZ,EAAA,MAAKoZ;AAAA,IAAA;AAEP,eAAWG,KAAKG;AACd,cAAQH,GAAG;AAAA,QACT,KAAK;AACE,eAAA,UAAUG,EAAYH,CAAC;AAC5B;AAAA,QACF,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACH,eAAK,KAAKA,CAAC,IAAIG,EAAYH,CAAC;AAC5B;AAAA,MACJ;AAAA,EAEJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAkC7d,GAAW;AAC3C,IAAAqF,EAAArF,GAAOyd,IAAkBnZ,EAAA,MAAKmZ,MAC9BpY,EAAArF,GAAO0d,GAAcpZ,EAAA,MAAKoZ,KAC1B1d,EAAO,SAAS,KAAK,QACrBA,EAAO,UAAU,KAAK,SACtBA,EAAO,OAAO,KAAK,MACZA,EAAA,OAAO,KAAK,KAAK,MAAM,GAC9BA,EAAO,OAAO,EAAE,GAAG,KAAK,KAAK;AAAA,EAC/B;AAAA,EAEU,UAAU;AAClB,IAAAsE,EAAA,MAAK0X,IAAS;EAChB;AACF;AAvKEuB,KAAA,eAYAvB,KAAA,eAYAwB,KAAA,eAwBAC,KAAA,eAEAC,IAAA;AAuHc,SAAAO,GACdvd,GACAwd,GACAja,GACwB;AAClB,QAAAka,IAAazd,IAAOuD,EAAK;AAC/B,MAAIka,IAAala,EAAK,YAAYA,EAAK,kBAAkB;AAEnD,QAAAvB,IAAIyb,IAAala,EAAK,UAEtBma,IAAUD,MAAela,EAAK,WAAW,IAAIvB,IAAIuB,EAAK,UACtDrG,IAAMsgB,EAAG,UAAU,CAACjX,MAAOA,EAAG,CAAC,KAAKmX,CAAO;AAC7C,MAAAxgB,MAAQ,GAAI,QAAO;AAEjB,QAAAygB,IAAaH,EAAGtgB,IAAM,CAAC,GACvB0gB,IAAYJ,EAAGtgB,CAAG,GAClB2gB,IAAYD,EAAU,CAAC;AACzB,MAAAD,KAAc,KAAa,QAAAE;AACzB,QAAAC,IAAaH,EAAW,CAAC,GAEzBrhB,IAA6B,CAAA,GAE7ByhB,KACHL,IAAUC,EAAW,CAAC,MAAMC,EAAU,CAAC,IAAID,EAAW,CAAC;AAC1D,aAAWlB,KAAQoB,GAAW;AAC5B,UAAMle,IAAI8c;AACN,IAAAqB,EAAWne,CAAC,KAAK,SAGlBrD,EAAAqD,CAAC,KAAKke,EAAUle,CAAC,IAAIme,EAAWne,CAAC,KAAKoe,IAAeD,EAAWne,CAAC;AAAA,EACtE;AAEO,SAAArD;AACT;;AC7NO,MAAM0hB,KAAN,MAAMA,WAAwBpB,GAAW;AAAA,EAQ9C,YAAYrV,GAAa;AACjB;AARR,IAAA/D,EAAA,MAAAya;AAGA;AAAA,IAAAza,EAAA,MAAA0a,IAA2C;AAE3C,IAAA1a,EAAA,MAAAM,IAAa;AAIX,IAAAa,EAAA,MAAKsZ,IAAQ1W,IACR,KAAA,QAAQA,EAAK,MAAM,KAAK,CAAC,EAAE,OAAA5L,GAAO,QAAAC,GAAQ,UAAAuiB,QAAe;AACvD,WAAA,KAAK,IAAI,KAAK,KAAK,MAAM,IAAIxiB,IAAQ,KAAK,KAAK,GAC/C,KAAA,KAAK,IAAI,KAAK,KAAK,MAAM,IAAIC,IAAS,KAAK,KAAK,GAChD,KAAA,KAAK,WACR,KAAK,KAAK,aAAa,IAAIuiB,IAAW,KAAK,KAAK;AAAA,IAAA,CACnD;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,gBACJhiB,GACA6D,GAIC;;AACK,UAAAoX,IAAKpX,IAAO,KAAK,KAAK;AAC5B,SAAK,QAAQoX,CAAE,GACf,MAAM,QAAQjb,CAAG;AACjB,UAAM,EAAE,GAAA+e,GAAG,GAAAC,MAAM,KAAK,MAChB,EAAE,OAAAvV,GAAO,OAAAD,GAAO,OAAAyY,MAAU,MAAMxa,EAAA,MAAKqa,IAAM,KAAK7G,CAAE;AACpD,QAAAiH,IAAW1Y,KAAS;AAOxB,QANIA,KAAS,QAAQ,KAAK,KAAK,iBAAiB,MAC9C0Y,IAAW1Y,EAAM;AAAA,MAAI,CAACwG,MACpB5L,GAAsB4L,GAAK,KAAK,KAAK,YAAY;AAAA,IAAA,IAIjDiS,MAAU;AACL,aAAA;AAAA,QACL,OAAOC;AAAA,QACP,MAAM;AAAA,MAAA;AAIJ,UAAA5D,IAAY7U,KAAShC,EAAA,MAAKsa;AAChC,WAAIzD,KAAa,QACXte,EAAA,UAAUse,GAAW,CAACS,IAAI,GAAG,CAACC,IAAI,GAAGD,GAAGC,CAAC,GAG3CvV,KAAS,UACXrH,IAAAqF,EAAA,MAAKsa,QAAL,QAAA3f,EAAc,SACdoG,EAAA,MAAKuZ,IAAUtY,KAGV;AAAA,MACL,OAAOyY;AAAA,MACP,MAAM;AAAA,IAAA;AAAA,EAEV;AAAA,EAEA,MAAM,QAAQ;AACZ,UAAMC,IAAM,IAAIN,GAAgB,MAAMpa,EAAA,MAAKqa,IAAM,OAAO;AACxD,iBAAMK,EAAI,OACV,KAAK,YAAYA,CAAG,GACbA;AAAA,EACT;AAAA,EAEA,UAAgB;;AACd,IAAI1a,EAAA,MAAKE,QACTa,EAAA,MAAKb,IAAa,KAElBH,EAAI,KAAK,yBAAyB,GAClC,MAAM,QAAQ,IACdpF,IAAAqF,EAAA,MAAKsa,QAAL,QAAA3f,EAAc,SACdoG,EAAA,MAAKuZ,IAAU,OACfta,EAAA,MAAKqa,IAAM;EACb;AACF;AAjFEA,KAAA,eAGAC,KAAA,eAEApa,KAAA;AANK,IAAMya,KAANP;;ACCA,MAAMQ,KAAN,MAAMA,WAAsB5B,GAAW;AAAA,EAW5C,YAAYrV,GAAa;AACjB;AAZH,IAAA/D,EAAA,MAAAib;AACL,IAAAjb,EAAA,MAAAya;AAQA;AAAA;AAAA;AAAA,IAAApa,EAAA,iBAAU;AAcV;AAAA,IAAAL,EAAA,MAAA0a,IAA2C;AAC3C,IAAA1a,EAAA,MAAAkb,IAA6B,CAAA;AAC7B,IAAAlb,EAAA,MAAAmb,IAAW;AAgCX,IAAAnb,EAAA,MAAAob,IAAY;AA8BZ,IAAApb,EAAA,MAAAM,IAAa;AA1EX,IAAAa,EAAA,MAAKsZ,IAAQ1W,IACR,KAAA,QAAQA,EAAK,MAAM,KAAK,CAAC,EAAE,OAAA5L,GAAO,QAAAC,GAAQ,UAAAuiB,QAAe;AACvD,WAAA,KAAK,IAAI,KAAK,KAAK,MAAM,IAAIxiB,IAAQ,KAAK,KAAK,GAC/C,KAAA,KAAK,IAAI,KAAK,KAAK,MAAM,IAAIC,IAAS,KAAK,KAAK,GAChD,KAAA,KAAK,WACR,KAAK,KAAK,aAAa,IAAIuiB,IAAW,KAAK,KAAK;AAAA,IAAA,CACnD;AAAA,EACH;AAAA,EAlBA,UAAU;AACR,WAAOva,EAAA,MAAKqa;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EA+CA,SAASje,GAAc;AACjB,IAAA4D,EAAA,MAAKgb,QAAc5e,MACvBiP,EAAA,MAAKwP,IAAAI,IAAL,WAAa7e,IACb2E,EAAA,MAAKia,IAAY5e;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OACE7D,GACA6D,GAC2B;AAC3B,SAAK,QAAQA,CAAI,GACjB,MAAM,QAAQ7D,CAAG;AACjB,UAAM,EAAE,GAAA+e,GAAG,GAAAC,MAAM,KAAK;AACtB,IAAIvX,EAAA,MAAKgb,QAAc5e,KAAMiP,EAAA,MAAKwP,IAAAI,IAAL,WAAa7e,IAC1C2E,EAAA,MAAKia,IAAY5e;AAEjB,UAAM2F,IAAQ/B,EAAA,MAAK8a;AACnB,IAAA/Z,EAAA,MAAK+Z,IAAa;AAClB,UAAM9Y,IAAQhC,EAAA,MAAKsa;AACnB,WAAItY,KAAS,QAAUzJ,EAAA,UAAUyJ,GAAO,CAACsV,IAAI,GAAG,CAACC,IAAI,GAAGD,GAAGC,CAAC,GAErD,EAAE,OAAAxV,EAAM;AAAA,EACjB;AAAA,EAEA,YAAkCrG,GAAiB;AACjD,UAAM,YAAYA,CAAM,GACpBA,aAAkBkf,OACpBlf,EAAO,UAAU,KAAK;AAAA,EAE1B;AAAA,EAGA,UAAgB;;AACd,IAAIsE,EAAA,MAAKE,QACTa,EAAA,MAAKb,IAAa,KAElBH,EAAI,KAAK,uBAAuB,GAChC,MAAM,QAAQ,IACdpF,IAAAqF,EAAA,MAAKsa,QAAL,QAAA3f,EAAc,SACdoG,EAAA,MAAKuZ,IAAU;AAAA,EAEjB;AACF;AAjGED,KAAA,eAsBAC,KAAA,eACAQ,KAAA,eACAC,KAAA,eAzBKF,KAAA,eA0BLI,cAAQ7e,GAAc;AACpB,EAAI4D,EAAA,MAAK+a,QACTha,EAAA,MAAKga,IAAW,KAChB/a,EAAA,MAAKqa,IACF,KAAKje,IAAO,KAAK,KAAK,YAAY,EAClC,KAAK,CAAC,EAAE,OAAA4F,GAAO,OAAAD,EAAA,MAAY;;AAC1B,IAAIC,KAAS,UACXrH,IAAAqF,EAAA,MAAKsa,QAAL,QAAA3f,EAAc,SACdoG,EAAA,MAAKuZ,IAAUtY,KAAS,QAErBjB,EAAA,MAAA+Z,IAAa/Y,KAAS,KACvBA,KAAS,QAAQ,KAAK,KAAK,iBAAiB,KAC9ChB,EAAA,MAAK+Z,IAAa/Y,EAAM;AAAA,MAAI,CAACwG,MAC3B5L,GAAsB4L,GAAK,KAAK,KAAK,YAAY;AAAA,IAAA;AAAA,EAErD,CACD,EACA,QAAQ,MAAM;AACb,IAAAxH,EAAA,MAAKga,IAAW;AAAA,EAAA,CACjB;AACL,GAWAC,KAAA,eA8BA9a,KAAA;AAvFK,IAAMgb,KAANN,ICKHO,KAAS;AAKb,eAAeC,GAAmBC,GAAwB;AACpD,EAAAA,MAAa,OACf,MAAMlf,GAAM,EAAE,GACd,MAAMif,GAAmBC,CAAQ;AAErC;;AAqBO,MAAMC,GAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAuEtB,YAAY3b,IAAwB,IAAI;AAvEnC,IAAAC,EAAA,MAAA2b;AA4CL,IAAA3b,EAAA,MAAAE,GAAOC,EAAI,OAAO,MAAMob,IAAQ,GAAG;AAEnC,IAAAvb,EAAA,MAAAM,IAAa;AAEb,IAAAN,EAAA,MAAA4b,GAAyE,CAAA;AAEzE,IAAA5b,EAAA,MAAA2M;AAEA,IAAA3M,EAAA,MAAA0N;AAGA;AAAA,IAAA1N,EAAA,MAAA6b,IAAmC;AAEnC,IAAA7b,EAAA,MAAAgB;AAEA,IAAAhB,EAAA,MAAA8b;AAEA,IAAA9b,EAAA,MAAA8X,IAAW,IAAIC;AAIf,IAAA1X,EAAA,YAAKD,EAAA,MAAK0X,IAAS;AAOjB,UAAM,EAAE,OAAA3f,IAAQ,GAAG,QAAAC,IAAS,MAAM2H;AAClC,IAAAoB,EAAA,MAAKwL,IAAO,IAAI,gBAAgBxU,GAAOC,CAAM;AAEvC,UAAAO,IAAMyH,EAAA,MAAKuM,IAAK,WAAW,MAAM,EAAE,OAAO,IAAO;AACvD,QAAIhU,KAAO,KAAY,OAAA,MAAM,qCAAqC;AAClE,IAAAwI,EAAA,MAAKuM,IAAO/U,IACZwI,EAAA,MAAKH,IAAQ,OAAO;AAAA,MAClB;AAAA,QACE,SAAS;AAAA,QACT,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,YAAY;AAAA,QACZ,OAAO;AAAA,QACP,SAAS;AAAA,QACT,KAAK;AAAA,QACL,cAAc;AAAA,MAChB;AAAA,MACAjB;AAAA,IAAA,IAGGoB,EAAA,MAAA2a,IAAiB3jB,IAAQC,IAAS;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EArFA,aAAa,YACX2jB,IAKI,IACc;AAEf,YAAA,KAAK,mBAAmB,QACvB,KAAK,gBAAgB,QACrB,KAAK,gBAAgB,QACrB,KAAK,cAAc,QACnB,KAAK,gBAAgB,QACrB,KAAK,gBAAgB,QACrB,KAAK,aAAa,UAEhB,MAAM,KAAK,aAAa,kBAAkB;AAAA,MACxC,OAAOA,EAAK,cAAc;AAAA,MAC1B,OAAOA,EAAK,SAAS;AAAA,MACrB,QAAQA,EAAK,UAAU;AAAA,MACvB,SAASA,EAAK,WAAW;AAAA,IAAA,CAC1B,GACD,aACA,QAEA,MAAM,KAAK,aAAa,kBAAkB;AAAA,MACxC,OAAOze,EAAmB;AAAA,MAC1B,YAAYA,EAAmB;AAAA,MAC/B,kBAAkBA,EAAmB;AAAA,IAAA,CACtC,GACD,cACJ;AAAA,EAEJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0DA,MAAM,UACJ0e,GACAjc,IAA2B,IACZ;AACf,UAAMkc,IAAW;AAAA,MACf,MAAMC,GAAK,CAAC,KAAK,KAAK,KAAK,GAAG,GAAGF,EAAG,IAAI;AAAA,MACxC,MAAM,EAAE,GAAGA,EAAG,KAAK;AAAA,MACnB,QAAQA,EAAG;AAAA,IAAA;AAER,IAAA5b,EAAA,MAAAF,GAAK,KAAK,yBAAyB+b,CAAQ;AAC1C,UAAAE,IAAQ,MAAMH,EAAG;AAClB,IAAA5b,EAAA,MAAAF,GAAK,KAAK,6BAA6B,GAC5CE,EAAA,MAAKwb,GAAS;AAAA,MACZ,OAAO,OAAOO,GAAO;AAAA,QACnB,MAAMpc,EAAK,QAAQ;AAAA,QACnB,SAAS;AAAA,MAAA,CACV;AAAA,IAAA,GAEEK,EAAA,MAAAwb,GAAS,KAAK,CAAC,GAAG3iB,MAAM,EAAE,SAASA,EAAE,MAAM;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA,EAkCA,SAAqC;AACnC,QAAImH,EAAA,MAAKwb,GAAS,WAAW,EAAG,OAAM,MAAM,iBAAiB;AAE7D,UAAMQ,IAAUhc,EAAA,MAAKwb,GAAS,KAAK,CAAC7Y,MAAOA,EAAG,IAAI,GAE5CsZ,IACJD,KAAW,OACPA,EAAQ,KAAK,SAASA,EAAQ,KAAK,WACnC,KAAK;AAAA,MACH,GAAGhc,EAAA,MAAKwb,GAAS,IAAI,CAAC7Y,MAAOA,EAAG,KAAK,SAASA,EAAG,KAAK,QAAQ;AAAA,IAAA;AAEtE,QAAIsZ,MAAY;AACR,YAAA;AAAA,QACJ;AAAA,MAAA;AAIJ,IAAIA,MAAY,MACdjc,EAAA,MAAKF,GAAK;AAAA,MACR;AAAA,IAAA,GAIJE,EAAA,MAAKF,GAAK,KAAK,kCAAkCmc,CAAO,EAAE;AACpD,UAAAC,IAAQ7Q,EAAA,MAAKkQ,IAAAY,IAAL,WAAqBF;AAC/B,QAAAG,IAAW,YAAY;AAC3B,UAAMC,IAAgBhR,EAAA,MAAKkQ,IAAAe,IAAL,WAAUJ,GAAOD,GAAS;AAAA,MAC9C,YAAY,CAACM,MAAS;AACf,QAAAvc,EAAA,MAAAF,GAAK,MAAM,mBAAmByc,CAAI,GAClCvc,EAAA,MAAA0X,IAAS,KAAK,kBAAkB6E,CAAI;AAAA,MAC3C;AAAA,MACA,SAAS,YAAY;AACnB,cAAML,EAAM,SACZlc,EAAA,MAAKF,GAAK;AAAA,UACR;AAAA,UACA,YAAY,QAAQsc;AAAA,QAAA,GAEjBpc,EAAA,MAAA0X,IAAS,KAAK,kBAAkB,CAAC,GACtC,KAAK,QAAQ;AAAA,MACf;AAAA,MACA,SAAS,CAACrR,MAAQ;AACX,QAAArG,EAAA,MAAA0X,IAAS,KAAK,SAASrR,CAAG,GAC/BmW,EAAenW,CAAG,GAClB,KAAK,QAAQ;AAAA,MACf;AAAA,IAAA;AAGF,IAAAtF,EAAA,MAAK0a,IAAc,MAAM;AACT,MAAAY,KACdH,EAAM,MAAM,GACGM;IAAA;AAEjB,UAAM,EAAE,QAAAliB,GAAQ,MAAMkiB,EAAmB,IAAAxI;AAAA,MACvCkI,EAAM;AAAA,MACN;AAAA,MACA,KAAK;AAAA,IAAA;AAGA,WAAA5hB;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU;;AACR,IAAI0F,EAAA,MAAKE,QACTa,EAAA,MAAKb,IAAa,MAElBvF,IAAAqF,EAAA,MAAKyb,QAAL,QAAA9gB,EAAA,YACAqF,EAAA,MAAK0X,IAAS;EAChB;AA2FF;AA9QE5X,IAAA,eAEAI,KAAA,eAEAsb,IAAA,eAEAjP,KAAA,eAEAe,KAAA,eAGAmO,KAAA,eAEA7a,KAAA,eAEA8a,KAAA,eAEAhE,KAAA,eA7DK6D,KAAA,eAyHLY,cAAgB5B,GAAkB;AAC1B,QAAA,EAAE,KAAAkC,GAAK,OAAA1kB,GAAO,QAAAC,GAAQ,YAAA0kB,GAAY,SAAAC,GAAS,OAAA5a,GAAO,cAAA6a,EAAa,IACnE5c,EAAA,MAAKY;AAwBA,SAvBaic,GAAU;AAAA,IAC5B,OAAO7c,EAAA,MAAK0b,MACR;AAAA,MACE,OAAA3jB;AAAA,MACA,QAAAC;AAAA,MACA,WAAWykB;AAAA,MACX,OAAOC;AAAA,MACP,SAAAC;AAAA,MACA,iCACE3c,EAAA,MAAKY,IAAM;AAAA,IAAA,IAEf;AAAA,IACJ,OACEmB,MAAU,KACN,OACA;AAAA,MACE,OAAO;AAAA,MACP,YAAY7E,EAAmB;AAAA,MAC/B,cAAcA,EAAmB;AAAA,IACnC;AAAA,IACN,UAAAqd;AAAA,IACA,cAAAqC;AAAA,EAAA,CACD;AAEH,GA6EAN,KAAA,SACEJ,GACAD,GACA;AAAA,EACE,YAAAa;AAAA,EACA,SAAAC;AAAA,EACA,SAAAC;AAAA,GAMU;AACZ,MAAIC,IAAW;AACT,QAAA9W,IAAU,EAAE,SAAS;AAC3B,MAAIE,IAAoB;AAsDnB,GApDQ,YAAY;AACvB,UAAM,EAAE,KAAAoW,GAAK,SAAAS,GAAS,OAAOC,MAAgBnd,EAAA,MAAKY,KAC5Cwc,IAAY,KAAK,MAAM,MAAMX,CAAG,GAEhClkB,IAAMyH,EAAA,MAAKsN,KACX+P,IAAYC,GAAoB;AAAA,MACpC,KAAA/kB;AAAA,MACA,SAAA2kB;AAAA,MACA,SAASld,EAAA,MAAKwb;AAAA,MACd,SAAArV;AAAA,IAAA,CACD,GACKoX,IAAaC,GAAgB;AAAA,MACjC,OAAAtB;AAAA,MACA,KAAA3jB;AAAA,MACA,KAAKyH,EAAA,MAAKuM;AAAA,MACV,aAAA4Q;AAAA,MACA,eAAend,EAAA,MAAK0b;AAAA,MACpB,WAAA0B;AAAA,MACA,KAAAX;AAAA,IAAA,CACD;AAED,QAAIjJ,IAAK;AACT,eAAa;AACX,UAAInN,KAAO,KAAM;AAEf,UAAAF,EAAQ,WACP8V,MAAY,MAAazI,IAAKyI,KAC/Bjc,EAAA,MAAKwb,GAAS,WAAW,GACzB;AACK,QAAAiC,KACL,MAAMV,EAAQ;AACd;AAAA,MACF;AACA,MAAAE,IAAWzJ,IAAKyI;AAEhB,YAAM,EAAE,QAAAphB,GAAQ,aAAA6iB,EAAA,IAAgB,MAAML,EAAU7J,CAAE;AAClD,UAAIkK,GAAa;AACV,QAAAD,KACL,MAAMV,EAAQ;AACd;AAAA,MACF;AAEA,UAAI5W,EAAQ,QAAS;AAErB,MAAAoX,EAAW/J,GAAI3Y,CAAM,GAEf2Y,KAAA4J,GAEA,MAAAhC,GAAmBc,EAAM,kBAAkB;AAAA,IACnD;AAAA,EAAA,GAGG,EAAE,MAAM,CAACyB,MAAM;AACZ,IAAAtX,IAAAsX,GACD3d,EAAA,MAAAF,GAAK,MAAM6d,CAAC,GACZF,KACLT,EAAQW,CAAC;AAAA,EAAA,CACV;AAEK,QAAAC,IAAe,YAAY,MAAM;AACrC,IAAAd,EAAWG,CAAQ;AAAA,KAClB,GAAG,GAEAQ,IAAO,MAAM;AACjB,IAAItX,EAAQ,YACZA,EAAQ,UAAU,IAClB,cAAcyX,CAAY,GAC1B5d,EAAA,MAAKwb,GAAS,QAAQ,CAAC7Y,MAAOA,EAAG,SAAS;AAAA,EAAA;AAGrC,SAAA8a;AACT;AAGF,SAASH,GAAoB3d,GAK1B;AACD,QAAM,EAAE,KAAApH,GAAK,SAAA2kB,GAAS,SAAAW,GAAS,SAAA1X,MAAYxG,GACrC,EAAE,OAAA5H,GAAO,QAAAC,MAAWO,EAAI;AAC9B,SAAO,OAAOib,MAAe;AAC3B,IAAAjb,EAAI,YAAY2kB,GAChB3kB,EAAI,SAAS,GAAG,GAAGR,GAAOC,CAAM;AAEhC,UAAM6C,IAA2B,CAAA;AACjC,QAAI6iB,IAAc;AAClB,eAAWzc,KAAK4c,GAAS;AACvB,UAAI1X,EAAQ,QAAS;AACrB,UAAIqN,IAAKvS,EAAE,KAAK,UAAUA,EAAE,QAAS;AAErC,MAAA1I,EAAI,KAAK;AACH,YAAA,EAAE,OAAAwJ,GAAO,MAAAmB,EAAS,IAAA,MAAMjC,EAAE,gBAAgB1I,GAAKib,IAAKvS,EAAE,KAAK,MAAM;AACvE,MAAApG,EAAO,KAAKkH,CAAK,GACjBxJ,EAAI,QAAQ,IAIT0I,EAAE,KAAK,WAAW,KAAKuS,IAAKvS,EAAE,KAAK,SAASA,EAAE,KAAK,YACpDiC,OAEIjC,EAAE,SAAoByc,IAAA,KAE1Bzc,EAAE,QAAQ,GACVA,EAAE,UAAU;AAAA,IAEhB;AACO,WAAA;AAAA,MACL,QAAApG;AAAA,MACA,aAAA6iB;AAAA,IAAA;AAAA,EACF;AAEJ;AAEA,SAASF,GAAgB7d,GAQtB;AACD,QAAM,EAAE,KAAApH,GAAK,KAAAD,GAAK,aAAA6kB,GAAa,OAAAjB,GAAO,eAAA4B,GAAe,WAAAV,EAAc,IAAAzd,GAC7D,EAAE,OAAA5H,GAAO,QAAAC,EAAW,IAAAM;AAC1B,MAAIoC,IAAW;AAEf,QAAMqjB,IAAU,KAAK,MAAM,IAAIpe,EAAK,GAAG,GAEjCqe,IAAgBC,GAAoB,IAAI;AAEvC,SAAA,CAACzK,GAAY3Y,MAA6B;AAC/C,QAAIsiB,MAAgB;AAClB,iBAAW9jB,KAAM2kB,EAAcxK,GAAI3Y,CAAM,EAAG,CAAAqhB,EAAM,YAAY7iB,CAAE;AAGlE,QAAIykB,GAAe;AACX,YAAAjb,IAAK,IAAI,WAAWvK,GAAK;AAAA,QAC7B,UAAU8kB;AAAA,QACV,WAAW5J;AAAA,MAAA,CACZ;AAED,MAAA0I,EAAM,YAAYrZ,GAAI;AAAA,QACpB,UAAUnI,IAAWqjB,MAAY;AAAA,MAAA,CAClC,GACDxlB,EAAI,eAAe,GACnBA,EAAI,UAAU,GAAG,GAAGR,GAAOC,CAAM,GAErB0C,KAAA;AAAA,IACd;AAAA,EAAA;AAEJ;AAMO,SAASujB,GAAoBC,GAAkB;AAC9C,QAAAC,IAAaD,IAAWhhB,EAAmB,cAE3C1D,IAAU,IAAI,aAAa2kB,IAAa,CAAC;AAC/C,MAAIC,IAAY,GAEZC,IAAU;AACR,QAAAC,IAAcJ,IAAWhhB,EAAmB,aAAc,KAG1DqhB,IAAkB,IAAI,aAAaJ,CAAU,GAE7CK,IAAe,CAAChL,MAAe;AACnC,QAAIiL,IAAa;AACjB,UAAMC,IAAQ,KAAK,MAAMN,IAAYD,CAAU,GACzCzlB,IAAkB,CAAA;AAExB,aAASQ,IAAI,GAAGA,IAAIwlB,GAAOxlB;AACtB,MAAAR,EAAA;AAAA,QACD,IAAI,UAAU;AAAA,UACZ,WAAW2lB;AAAA,UACX,kBAAkBnhB,EAAmB;AAAA,UACrC,gBAAgBghB;AAAA,UAChB,YAAYhhB,EAAmB;AAAA,UAC/B,QAAQ;AAAA,UACR,MAAM1D,EAAQ,SAASilB,GAAYA,IAAaN,CAAU;AAAA,QAAA,CAC3D;AAAA,MAAA,GAEWM,KAAAN,GACHE,KAAAC;AAMN,SAJP9kB,EAAQ,IAAIA,EAAQ,SAASilB,GAAYL,CAAS,GAAG,CAAC,GACzCA,KAAAK,GAGNjL,IAAK6K,IAAUC;AACjB,MAAA5lB,EAAA;AAAA,QACD,IAAI,UAAU;AAAA,UACZ,WAAW2lB;AAAA,UACX,kBAAkBnhB,EAAmB;AAAA,UACrC,gBAAgBghB;AAAA,UAChB,YAAYhhB,EAAmB;AAAA,UAC/B,QAAQ;AAAA,UACR,MAAMqhB;AAAA,QAAA,CACP;AAAA,MAAA,GAEQF,KAAAC;AAEN,WAAA5lB;AAAA,EAAA;AAGF,SAAA,CAAC8a,GAAYmL,MAAkC;;AACpD,UAAM7jB,IAAS,KAAK,IAAI,GAAG6jB,EAAY,IAAI,CAAC/lB,MAAA;;AAAM,eAAA+B,IAAA/B,EAAE,CAAC,MAAH,gBAAA+B,EAAM,WAAU;AAAA,KAAC,CAAC;AACpE,aAASK,IAAS,GAAGA,IAASF,GAAQE,KAAU;AAC9C,UAAIC,IAAQ,GACRC,IAAQ;AACZ,eAASC,IAAW,GAAGA,IAAWwjB,EAAY,QAAQxjB,KAAY;AAChE,cAAMC,MAAMT,IAAAgkB,EAAYxjB,CAAQ,EAAE,CAAC,MAAvB,gBAAAR,EAA2BK,OAAW,GAE5CK,MAAMC,IAAAqjB,EAAYxjB,CAAQ,EAAE,CAAC,MAAvB,gBAAAG,EAA2BN,OAAWI;AACzC,QAAAH,KAAAG,GACAF,KAAAG;AAAA,MACX;AAEA,MAAA7B,EAAQ4kB,CAAS,IAAInjB,GACbzB,EAAA4kB,IAAY,CAAC,IAAIljB,GACZkjB,KAAA;AAAA,IACf;AAEA,WAAOI,EAAahL,CAAE;AAAA,EAAA;AAE1B;AAEA,SAASsI,GAA0C8C,GAAWpf,GAAQ;AACpE,SAAOof,EAAK;AAAA,IACV,CAACxT,GAAKyT,OACAzT,EAAAyT,CAAG,IAAIrf,EAAIqf,CAAG,GACXzT;AAAA,IAET,CAAC;AAAA,EAAA;AAEL;"}