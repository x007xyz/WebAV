{"version":3,"file":"av-recorder.js","sources":["../src/av-recorder.ts"],"sourcesContent":["import {\n  Log,\n  recodemux,\n  autoReadStream,\n  EventTool,\n  file2stream,\n} from '@webav/internal-utils';\nimport {\n  AVRecorderConf,\n  IStream,\n  IRecordeOpts as IRecordOpts,\n  TClearFn,\n} from './types';\n\ntype TState = 'inactive' | 'recording' | 'paused' | 'stopped';\n\n/**\n * 录制媒体流 MediaStream，生成 MP4 文件流\n *\n * 如果你期望录制为 WebM 格式，请使用 [MediaRecorder](https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder)\n *\n * @example\n * const recorder = new AVRecorder(\n * await navigator.mediaDevices.getUserMedia({\n *   video: true,\n *   audio: true,\n * })\n);\n\nrecorder.start() // => ReadableStream\n * @see [录制摄像头](https://webav-tech.github.io/WebAV/demo/4_1-recorder-usermedia)\n */\nexport class AVRecorder {\n  #state: TState = 'inactive';\n  get state(): TState {\n    return this.#state;\n  }\n  set state(_: TState) {\n    throw new Error('state is readonly');\n  }\n\n  #evtTool = new EventTool<{\n    stateChange: (state: TState) => void;\n  }>();\n  on = this.#evtTool.on;\n\n  #conf: Omit<IRecordOpts, 'timeSlice'>;\n\n  #recoderPauseCtrl: RecoderPauseCtrl;\n\n  constructor(inputMediaStream: MediaStream, conf: AVRecorderConf = {}) {\n    this.#conf = createRecoderConf(inputMediaStream, conf);\n    this.#recoderPauseCtrl = new RecoderPauseCtrl(this.#conf.video.expectFPS);\n  }\n\n  #stopStream = () => {};\n  /**\n   * 开始录制，返回 MP4 文件流\n   * @param timeSlice 控制流输出数据的时间间隔，单位毫秒\n   *\n   */\n  start(timeSlice: number = 500): ReadableStream<Uint8Array> {\n    if (this.#state === 'stopped') throw Error('AVRecorder is stopped');\n    Log.info('AVRecorder.start recoding');\n\n    const { streams } = this.#conf;\n\n    if (streams.audio == null && streams.video == null) {\n      throw new Error('No available tracks in MediaStream');\n    }\n\n    const { stream, exit } = startRecord(\n      { timeSlice, ...this.#conf },\n      this.#recoderPauseCtrl,\n      () => {\n        this.stop();\n      },\n    );\n    this.#stopStream();\n    this.#stopStream = exit;\n    return stream;\n  }\n\n  /**\n   * 暂停录制\n   */\n  pause(): void {\n    this.#state = 'paused';\n    this.#recoderPauseCtrl.pause();\n    this.#evtTool.emit('stateChange', this.#state);\n  }\n  /**\n   * 恢复录制\n   */\n  resume(): void {\n    if (this.#state === 'stopped') throw Error('AVRecorder is stopped');\n    this.#state = 'recording';\n    this.#recoderPauseCtrl.play();\n    this.#evtTool.emit('stateChange', this.#state);\n  }\n\n  /**\n   * 停止\n   */\n  async stop(): Promise<void> {\n    if (this.#state === 'stopped') return;\n    this.#state = 'stopped';\n\n    this.#stopStream();\n  }\n}\n\nfunction createRecoderConf(inputMS: MediaStream, userConf: AVRecorderConf) {\n  const conf = {\n    bitrate: 3e6,\n    expectFPS: 30,\n    videoCodec: 'avc1.42E032',\n    ...userConf,\n  };\n  const { streams, width, height, sampleRate, channelCount } =\n    extractMSSettings(inputMS);\n\n  const opts: Omit<IRecordOpts, 'timeSlice'> = {\n    video: {\n      width: width ?? 1280,\n      height: height ?? 720,\n      expectFPS: conf.expectFPS,\n      codec: conf.videoCodec,\n    },\n    audio: {\n      codec: 'aac',\n      sampleRate: sampleRate ?? 44100,\n      channelCount: channelCount ?? 2,\n    },\n    bitrate: conf.bitrate,\n    streams,\n  };\n  return opts;\n}\n\nfunction extractMSSettings(inputMS: MediaStream) {\n  const videoTrack = inputMS.getVideoTracks()[0];\n  const settings: MediaTrackSettings & { streams: IStream } = { streams: {} };\n  if (videoTrack != null) {\n    Object.assign(settings, videoTrack.getSettings());\n    settings.streams.video = new MediaStreamTrackProcessor({\n      track: videoTrack,\n    }).readable;\n  }\n\n  const audioTrack = inputMS.getAudioTracks()[0];\n  if (audioTrack != null) {\n    Object.assign(settings, audioTrack.getSettings());\n    Log.info('AVRecorder recording audioConf:', settings);\n    settings.streams.audio = new MediaStreamTrackProcessor({\n      track: audioTrack,\n    }).readable;\n  }\n\n  return settings;\n}\n\nclass RecoderPauseCtrl {\n  // 当前帧的偏移时间，用于计算帧的 timestamp\n  #offsetTime = performance.now();\n\n  // 编码上一帧的时间，用于计算出当前帧的持续时长\n  #lastTime = this.#offsetTime;\n\n  // 用于限制 帧率\n  #frameCnt = 0;\n\n  // 如果为true，则暂停编码数据\n  // 取消暂停时，需要减去\n  #paused = false;\n\n  // 触发暂停的时间，用于计算暂停持续了多久\n  #pauseTime = 0;\n\n  // 间隔多少帧生成一个关键帧\n  #gopSize = 30;\n\n  constructor(readonly expectFPS: number) {\n    this.#gopSize = Math.floor(expectFPS * 3);\n  }\n\n  start() {\n    this.#offsetTime = performance.now();\n    this.#lastTime = this.#offsetTime;\n  }\n\n  play() {\n    if (!this.#paused) return;\n    this.#paused = false;\n\n    this.#offsetTime += performance.now() - this.#pauseTime;\n    this.#lastTime += performance.now() - this.#pauseTime;\n  }\n\n  pause() {\n    if (this.#paused) return;\n    this.#paused = true;\n    this.#pauseTime = performance.now();\n  }\n\n  transfromVideo(frame: VideoFrame) {\n    const now = performance.now();\n    const offsetTime = now - this.#offsetTime;\n    if (\n      this.#paused ||\n      // 避免帧率超出期望太高\n      (this.#frameCnt / offsetTime) * 1000 > this.expectFPS\n    ) {\n      frame.close();\n      return;\n    }\n\n    const vf = new VideoFrame(frame, {\n      // timestamp 单位 微秒\n      timestamp: offsetTime * 1000,\n      duration: (now - this.#lastTime) * 1000,\n    });\n    this.#lastTime = now;\n\n    this.#frameCnt += 1;\n    frame.close();\n    return {\n      vf,\n      opts: { keyFrame: this.#frameCnt % this.#gopSize === 0 },\n    };\n  }\n\n  transformAudio(ad: AudioData) {\n    if (this.#paused) {\n      ad.close();\n      return;\n    }\n    return ad;\n  }\n}\n\nfunction startRecord(\n  opts: IRecordOpts,\n  ctrl: RecoderPauseCtrl,\n  onEnded: TClearFn,\n) {\n  let stopEncodeVideo: TClearFn | null = null;\n  let stopEncodeAudio: TClearFn | null = null;\n\n  const [hasVideoTrack, hasAudioTrack] = [\n    opts.streams.video != null,\n    opts.streams.audio != null && opts.audio != null,\n  ];\n\n  const recoder = recodemux({\n    video: hasVideoTrack\n      ? { ...opts.video, bitrate: opts.bitrate ?? 3_000_000 }\n      : null,\n    audio: hasAudioTrack ? opts.audio : null,\n  });\n\n  let stoped = false;\n  if (hasVideoTrack) {\n    let lastVf: VideoFrame | null = null;\n    let autoInsertVFTimer = 0;\n    const emitVf = (vf: VideoFrame) => {\n      clearTimeout(autoInsertVFTimer);\n\n      lastVf?.close();\n      lastVf = vf;\n      const vfWrap = ctrl.transfromVideo(vf.clone());\n      if (vfWrap == null) return;\n      recoder.encodeVideo(vfWrap.vf, vfWrap.opts);\n\n      // 录制静态画面，MediaStream 不出帧时，每秒插入一帧\n      autoInsertVFTimer = self.setTimeout(() => {\n        if (lastVf == null) return;\n        const newVf = new VideoFrame(lastVf, {\n          timestamp: lastVf.timestamp + 1e6,\n          duration: 1e6,\n        });\n        emitVf(newVf);\n      }, 1000);\n    };\n\n    ctrl.start();\n    const stopReadStream = autoReadStream(opts.streams.video!, {\n      onChunk: async (chunk: VideoFrame) => {\n        if (stoped) {\n          chunk.close();\n          return;\n        }\n        emitVf(chunk);\n      },\n      onDone: () => {},\n    });\n\n    stopEncodeVideo = () => {\n      stopReadStream();\n      clearTimeout(autoInsertVFTimer);\n      lastVf?.close();\n    };\n  }\n\n  if (hasAudioTrack) {\n    stopEncodeAudio = autoReadStream(opts.streams.audio!, {\n      onChunk: async (ad: AudioData) => {\n        if (stoped) {\n          ad.close();\n          return;\n        }\n        const newAD = ctrl.transformAudio(ad);\n        if (newAD != null) recoder.encodeAudio(ad);\n      },\n      onDone: () => {},\n    });\n  }\n\n  const { stream, stop: stopStream } = file2stream(\n    recoder.mp4file,\n    opts.timeSlice,\n    () => {\n      exit();\n      onEnded();\n    },\n  );\n\n  function exit() {\n    stoped = true;\n\n    stopEncodeVideo?.();\n    stopEncodeAudio?.();\n    recoder.close();\n    stopStream();\n  }\n\n  return { exit, stream };\n}\n"],"names":["AVRecorder","inputMediaStream","conf","__privateAdd","_state","_evtTool","EventTool","__publicField","__privateGet","_conf","_recoderPauseCtrl","_stopStream","__privateSet","createRecoderConf","RecoderPauseCtrl","_","timeSlice","Log","streams","stream","exit","startRecord","inputMS","userConf","width","height","sampleRate","channelCount","extractMSSettings","videoTrack","settings","audioTrack","expectFPS","_offsetTime","_lastTime","_frameCnt","_paused","_pauseTime","_gopSize","frame","now","offsetTime","vf","ad","opts","ctrl","onEnded","stopEncodeVideo","stopEncodeAudio","hasVideoTrack","hasAudioTrack","recoder","recodemux","stoped","lastVf","autoInsertVFTimer","emitVf","vfWrap","newVf","stopReadStream","autoReadStream","chunk","stopStream","file2stream"],"mappings":"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"}